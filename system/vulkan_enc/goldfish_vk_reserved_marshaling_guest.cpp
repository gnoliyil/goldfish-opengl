// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_reserved_marshaling_guest
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_reserved_marshaling_guest.h"


#include "goldfish_vk_extension_structs_guest.h"
#include "goldfish_vk_private_defs.h"

#include "Resources.h"


namespace goldfish_vk {

void reservedmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    const void* structExtension,
    uint8_t** ptr);

void reservedunmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    void* structExtension_out,
    uint8_t** ptr);

#ifdef VK_VERSION_1_0
void reservedmarshal_VkApplicationInfo(
    VulkanStreamGuest* vkStream,
    const VkApplicationInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pApplicationName;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pApplicationName)
        {
            {
                uint32_t l = forMarshaling->pApplicationName ? strlen(forMarshaling->pApplicationName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pApplicationName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pApplicationName ? strlen(forMarshaling->pApplicationName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pApplicationName, l);
            *ptr += l;
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->applicationVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pEngineName;
        memcpy((*ptr), &cgen_var_1, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pEngineName)
        {
            {
                uint32_t l = forMarshaling->pEngineName ? strlen(forMarshaling->pEngineName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pEngineName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pEngineName ? strlen(forMarshaling->pEngineName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pEngineName, l);
            *ptr += l;
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->engineVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkInstanceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkInstanceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkInstanceCreateFlags*)&forMarshaling->flags, sizeof(VkInstanceCreateFlags));
    *ptr += sizeof(VkInstanceCreateFlags);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pApplicationInfo;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pApplicationInfo)
    {
        reservedmarshal_VkApplicationInfo(vkStream, (const VkApplicationInfo*)(forMarshaling->pApplicationInfo), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = forMarshaling->enabledLayerCount;
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledLayerNames ? strlen(forMarshaling->ppEnabledLayerNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledLayerNames[i]), l);
                *ptr += l;
            }
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = forMarshaling->enabledExtensionCount;
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledExtensionNames ? strlen(forMarshaling->ppEnabledExtensionNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledExtensionNames[i]), l);
                *ptr += l;
            }
        }
    }
}

void reservedmarshal_VkAllocationCallbacks(
    VulkanStreamGuest* vkStream,
    const VkAllocationCallbacks* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
    uint64_t cgen_var_4 = (uint64_t)forMarshaling->pfnAllocation;
    memcpy((*ptr), &cgen_var_4, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_5 = (uint64_t)forMarshaling->pfnReallocation;
    memcpy((*ptr), &cgen_var_5, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_6 = (uint64_t)forMarshaling->pfnFree;
    memcpy((*ptr), &cgen_var_6, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_7 = (uint64_t)forMarshaling->pfnInternalAllocation;
    memcpy((*ptr), &cgen_var_7, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_8 = (uint64_t)forMarshaling->pfnInternalFree;
    memcpy((*ptr), &cgen_var_8, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkPhysicalDeviceFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustBufferAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imageCubeArray, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->independentBlend, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->geometryShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->tessellationShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sampleRateShading, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dualSrcBlend, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->logicOp, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiDrawIndirect, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthClamp, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBiasClamp, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fillModeNonSolid, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBounds, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->wideLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->largePoints, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->alphaToOne, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiViewport, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerAnisotropy, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionETC2, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionBC, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderClipDistance, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderCullDistance, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderResourceResidency, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderResourceMinLod, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseBinding, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency2Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency4Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency8Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency16Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyAliased, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variableMultisampleRate, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->inheritedQueries, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
}

void reservedmarshal_VkExtent3D(
    VulkanStreamGuest* vkStream,
    const VkExtent3D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->maxExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMipLevels, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->maxResourceSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkPhysicalDeviceLimits(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceLimits* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimension1D, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimension2D, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimension3D, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimensionCube, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTexelBufferElements, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxUniformBufferRange, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxStorageBufferRange, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPushConstantsSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputBindings, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (float*)&forMarshaling->maxSamplerLodBias, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxSamplerAnisotropy, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxViewports, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    *ptr += 2 * sizeof(uint32_t);
    memcpy(*ptr, (float*)forMarshaling->viewportBoundsRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportSubPixelBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_9 = (uint64_t)forMarshaling->minMemoryMapAlignment;
    memcpy((*ptr), &cgen_var_9, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (int32_t*)&forMarshaling->minTexelOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTexelOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->minTexelGatherOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (float*)&forMarshaling->minInterpolationOffset, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxInterpolationOffset, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFramebufferWidth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFramebufferHeight, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFramebufferLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxColorAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSampleMaskWords, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->timestampPeriod, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxClipDistances, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxCullDistances, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->discreteQueuePriorities, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (float*)forMarshaling->pointSizeRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (float*)forMarshaling->lineWidthRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->pointSizeGranularity, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->lineWidthGranularity, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->strictLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->standardSampleLocations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSparseProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyNonResidentStrict, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->driverVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vendorID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPhysicalDeviceType*)&forMarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    *ptr += sizeof(VkPhysicalDeviceType);
    memcpy(*ptr, (char*)forMarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (uint8_t*)forMarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    reservedmarshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forMarshaling->limits), ptr);
    reservedmarshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forMarshaling->sparseProperties), ptr);
}

void reservedmarshal_VkQueueFamilyProperties(
    VulkanStreamGuest* vkStream,
    const VkQueueFamilyProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkQueueFlags*)&forMarshaling->queueFlags, sizeof(VkQueueFlags));
    *ptr += sizeof(VkQueueFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->timestampValidBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->minImageTransferGranularity), ptr);
}

void reservedmarshal_VkMemoryType(
    VulkanStreamGuest* vkStream,
    const VkMemoryType* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkMemoryPropertyFlags*)&forMarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    *ptr += sizeof(VkMemoryPropertyFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMemoryHeap(
    VulkanStreamGuest* vkStream,
    const VkMemoryHeap* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkMemoryHeapFlags*)&forMarshaling->flags, sizeof(VkMemoryHeapFlags));
    *ptr += sizeof(VkMemoryHeapFlags);
}

void reservedmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMemoryProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        reservedmarshal_VkMemoryType(vkStream, (VkMemoryType*)(forMarshaling->memoryTypes + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryHeapCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        reservedmarshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forMarshaling->memoryHeaps + i), ptr);
    }
}

void reservedmarshal_VkDeviceQueueCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceQueueCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const float*)forMarshaling->pQueuePriorities, forMarshaling->queueCount * sizeof(const float));
    *ptr += forMarshaling->queueCount * sizeof(const float);
}

void reservedmarshal_VkDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceCreateFlags));
    *ptr += sizeof(VkDeviceCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueCreateInfoCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueCreateInfoCount; ++i)
    {
        reservedmarshal_VkDeviceQueueCreateInfo(vkStream, (const VkDeviceQueueCreateInfo*)(forMarshaling->pQueueCreateInfos + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = forMarshaling->enabledLayerCount;
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledLayerNames ? strlen(forMarshaling->ppEnabledLayerNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledLayerNames[i]), l);
                *ptr += l;
            }
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = forMarshaling->enabledExtensionCount;
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledExtensionNames ? strlen(forMarshaling->ppEnabledExtensionNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledExtensionNames[i]), l);
                *ptr += l;
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_10 = (uint64_t)(uintptr_t)forMarshaling->pEnabledFeatures;
    memcpy((*ptr), &cgen_var_10, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pEnabledFeatures)
    {
        reservedmarshal_VkPhysicalDeviceFeatures(vkStream, (const VkPhysicalDeviceFeatures*)(forMarshaling->pEnabledFeatures), ptr);
    }
}

void reservedmarshal_VkExtensionProperties(
    VulkanStreamGuest* vkStream,
    const VkExtensionProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (char*)forMarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkLayerProperties(
    VulkanStreamGuest* vkStream,
    const VkLayerProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (char*)forMarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->implementationVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void reservedmarshal_VkSubmitInfo(
    VulkanStreamGuest* vkStream,
    const VkSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_11_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->waitSemaphoreCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pWaitSemaphores[k]);
            memcpy(cgen_var_11_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->waitSemaphoreCount;
    }
    memcpy(*ptr, (const VkPipelineStageFlags*)forMarshaling->pWaitDstStageMask, forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    *ptr += forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->commandBufferCount)
    {
        uint8_t* cgen_var_12_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->commandBufferCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkCommandBuffer(forMarshaling->pCommandBuffers[k]);
            memcpy(cgen_var_12_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->commandBufferCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_13_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->signalSemaphoreCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pSignalSemaphores[k]);
            memcpy(cgen_var_13_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->signalSemaphoreCount;
    }
}

void reservedmarshal_VkMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkMemoryAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMappedMemoryRange(
    VulkanStreamGuest* vkStream,
    const VkMappedMemoryRange* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_14;
    *&cgen_var_14 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_14, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkMemoryRequirements(
    VulkanStreamGuest* vkStream,
    const VkMemoryRequirements* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->alignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkSparseImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkSparseImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageGranularity), ptr);
    memcpy(*ptr, (VkSparseImageFormatFlags*)&forMarshaling->flags, sizeof(VkSparseImageFormatFlags));
    *ptr += sizeof(VkSparseImageFormatFlags);
}

void reservedmarshal_VkSparseImageMemoryRequirements(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryRequirements* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->formatProperties), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->imageMipTailStride, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkSparseMemoryBind(
    VulkanStreamGuest* vkStream,
    const VkSparseMemoryBind* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->resourceOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_15;
    *&cgen_var_15 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_15, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    const VkSparseBufferMemoryBindInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_16;
    *&cgen_var_16 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_16, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        reservedmarshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i), ptr);
    }
}

void reservedmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    const VkSparseImageOpaqueMemoryBindInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_17;
    *&cgen_var_17 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_17, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        reservedmarshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i), ptr);
    }
}

void reservedmarshal_VkImageSubresource(
    VulkanStreamGuest* vkStream,
    const VkImageSubresource* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->arrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkOffset3D(
    VulkanStreamGuest* vkStream,
    const VkOffset3D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (int32_t*)&forMarshaling->x, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->y, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->z, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkSparseImageMemoryBind(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryBind* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forMarshaling->subresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->offset), ptr);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent), ptr);
    uint64_t cgen_var_18;
    *&cgen_var_18 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_18, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedmarshal_VkSparseImageMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryBindInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_19;
    *&cgen_var_19 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_19, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        reservedmarshal_VkSparseImageMemoryBind(vkStream, (const VkSparseImageMemoryBind*)(forMarshaling->pBinds + i), ptr);
    }
}

void reservedmarshal_VkBindSparseInfo(
    VulkanStreamGuest* vkStream,
    const VkBindSparseInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_20_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->waitSemaphoreCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pWaitSemaphores[k]);
            memcpy(cgen_var_20_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->waitSemaphoreCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferBindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bufferBindCount; ++i)
    {
        reservedmarshal_VkSparseBufferMemoryBindInfo(vkStream, (const VkSparseBufferMemoryBindInfo*)(forMarshaling->pBufferBinds + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageOpaqueBindCount; ++i)
    {
        reservedmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (const VkSparseImageOpaqueMemoryBindInfo*)(forMarshaling->pImageOpaqueBinds + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageBindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageBindCount; ++i)
    {
        reservedmarshal_VkSparseImageMemoryBindInfo(vkStream, (const VkSparseImageMemoryBindInfo*)(forMarshaling->pImageBinds + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_21_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->signalSemaphoreCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pSignalSemaphores[k]);
            memcpy(cgen_var_21_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->signalSemaphoreCount;
    }
}

void reservedmarshal_VkFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkFenceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFenceCreateFlags*)&forMarshaling->flags, sizeof(VkFenceCreateFlags));
    *ptr += sizeof(VkFenceCreateFlags);
}

void reservedmarshal_VkSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkSemaphoreCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSemaphoreCreateFlags*)&forMarshaling->flags, sizeof(VkSemaphoreCreateFlags));
    *ptr += sizeof(VkSemaphoreCreateFlags);
}

void reservedmarshal_VkEventCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkEventCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkEventCreateFlags*)&forMarshaling->flags, sizeof(VkEventCreateFlags));
    *ptr += sizeof(VkEventCreateFlags);
}

void reservedmarshal_VkQueryPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkQueryPoolCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkQueryPoolCreateFlags*)&forMarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    *ptr += sizeof(VkQueryPoolCreateFlags);
    memcpy(*ptr, (VkQueryType*)&forMarshaling->queryType, sizeof(VkQueryType));
    *ptr += sizeof(VkQueryType);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedmarshal_VkBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkBufferCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_22 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_22, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
}

void reservedmarshal_VkBufferViewCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkBufferViewCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBufferViewCreateFlags*)&forMarshaling->flags, sizeof(VkBufferViewCreateFlags));
    *ptr += sizeof(VkBufferViewCreateFlags);
    uint64_t cgen_var_23;
    *&cgen_var_23 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_23, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkImageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkImageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
    memcpy(*ptr, (VkImageType*)&forMarshaling->imageType, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipLevels, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->arrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_24 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_24, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkSubresourceLayout(
    VulkanStreamGuest* vkStream,
    const VkSubresourceLayout* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->rowPitch, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->arrayPitch, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->depthPitch, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkComponentMapping(
    VulkanStreamGuest* vkStream,
    const VkComponentMapping* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->r, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->g, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->b, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->a, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
}

void reservedmarshal_VkImageSubresourceRange(
    VulkanStreamGuest* vkStream,
    const VkImageSubresourceRange* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseMipLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->levelCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageViewCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkImageViewCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageViewCreateFlags*)&forMarshaling->flags, sizeof(VkImageViewCreateFlags));
    *ptr += sizeof(VkImageViewCreateFlags);
    uint64_t cgen_var_25;
    *&cgen_var_25 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_25, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageViewType*)&forMarshaling->viewType, sizeof(VkImageViewType));
    *ptr += sizeof(VkImageViewType);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components), ptr);
    reservedmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange), ptr);
}

void reservedmarshal_VkShaderModuleCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkShaderModuleCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkShaderModuleCreateFlags*)&forMarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    *ptr += sizeof(VkShaderModuleCreateFlags);
    uint64_t cgen_var_26 = (uint64_t)forMarshaling->codeSize;
    memcpy((*ptr), &cgen_var_26, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCode, (forMarshaling->codeSize / 4) * sizeof(const uint32_t));
    *ptr += (forMarshaling->codeSize / 4) * sizeof(const uint32_t);
}

void reservedmarshal_VkPipelineCacheCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineCacheCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCacheCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    *ptr += sizeof(VkPipelineCacheCreateFlags);
    uint64_t cgen_var_27 = (uint64_t)forMarshaling->initialDataSize;
    memcpy((*ptr), &cgen_var_27, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkSpecializationMapEntry(
    VulkanStreamGuest* vkStream,
    const VkSpecializationMapEntry* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->constantID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_28 = (uint64_t)forMarshaling->size;
    memcpy((*ptr), &cgen_var_28, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkSpecializationInfo(
    VulkanStreamGuest* vkStream,
    const VkSpecializationInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->mapEntryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->mapEntryCount; ++i)
    {
        reservedmarshal_VkSpecializationMapEntry(vkStream, (const VkSpecializationMapEntry*)(forMarshaling->pMapEntries + i), ptr);
    }
    uint64_t cgen_var_29 = (uint64_t)forMarshaling->dataSize;
    memcpy((*ptr), &cgen_var_29, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->dataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineShaderStageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineShaderStageCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    *ptr += sizeof(VkPipelineShaderStageCreateFlags);
    memcpy(*ptr, (VkShaderStageFlagBits*)&forMarshaling->stage, sizeof(VkShaderStageFlagBits));
    *ptr += sizeof(VkShaderStageFlagBits);
    uint64_t cgen_var_30;
    *&cgen_var_30 = get_host_u64_VkShaderModule((*&forMarshaling->module));
    memcpy(*ptr, (uint64_t*)&cgen_var_30, 1 * 8);
    *ptr += 1 * 8;
    {
        uint32_t l = forMarshaling->pName ? strlen(forMarshaling->pName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pName, l);
        *ptr += l;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_31 = (uint64_t)(uintptr_t)forMarshaling->pSpecializationInfo;
    memcpy((*ptr), &cgen_var_31, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSpecializationInfo)
    {
        reservedmarshal_VkSpecializationInfo(vkStream, (const VkSpecializationInfo*)(forMarshaling->pSpecializationInfo), ptr);
    }
}

void reservedmarshal_VkVertexInputBindingDescription(
    VulkanStreamGuest* vkStream,
    const VkVertexInputBindingDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkVertexInputRate*)&forMarshaling->inputRate, sizeof(VkVertexInputRate));
    *ptr += sizeof(VkVertexInputRate);
}

void reservedmarshal_VkVertexInputAttributeDescription(
    VulkanStreamGuest* vkStream,
    const VkVertexInputAttributeDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->location, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineVertexInputStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineVertexInputStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    *ptr += sizeof(VkPipelineVertexInputStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDescriptionCount; ++i)
    {
        reservedmarshal_VkVertexInputBindingDescription(vkStream, (const VkVertexInputBindingDescription*)(forMarshaling->pVertexBindingDescriptions + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexAttributeDescriptionCount; ++i)
    {
        reservedmarshal_VkVertexInputAttributeDescription(vkStream, (const VkVertexInputAttributeDescription*)(forMarshaling->pVertexAttributeDescriptions + i), ptr);
    }
}

void reservedmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineInputAssemblyStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineInputAssemblyStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    *ptr += sizeof(VkPipelineInputAssemblyStateCreateFlags);
    memcpy(*ptr, (VkPrimitiveTopology*)&forMarshaling->topology, sizeof(VkPrimitiveTopology));
    *ptr += sizeof(VkPrimitiveTopology);
    memcpy(*ptr, (VkBool32*)&forMarshaling->primitiveRestartEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineTessellationStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineTessellationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    *ptr += sizeof(VkPipelineTessellationStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->patchControlPoints, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkViewport(
    VulkanStreamGuest* vkStream,
    const VkViewport* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (float*)&forMarshaling->x, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->y, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->width, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->height, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->minDepth, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxDepth, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkOffset2D(
    VulkanStreamGuest* vkStream,
    const VkOffset2D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (int32_t*)&forMarshaling->x, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->y, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkExtent2D(
    VulkanStreamGuest* vkStream,
    const VkExtent2D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkRect2D(
    VulkanStreamGuest* vkStream,
    const VkRect2D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineViewportStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineViewportStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    *ptr += sizeof(VkPipelineViewportStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_32 = (uint64_t)(uintptr_t)forMarshaling->pViewports;
    memcpy((*ptr), &cgen_var_32, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkViewport(vkStream, (const VkViewport*)(forMarshaling->pViewports + i), ptr);
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->scissorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_33 = (uint64_t)(uintptr_t)forMarshaling->pScissors;
    memcpy((*ptr), &cgen_var_33, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->scissorCount; ++i)
        {
            reservedmarshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pScissors + i), ptr);
        }
    }
}

void reservedmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineRasterizationStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineRasterizationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    *ptr += sizeof(VkPipelineRasterizationStateCreateFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthClampEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkPolygonMode*)&forMarshaling->polygonMode, sizeof(VkPolygonMode));
    *ptr += sizeof(VkPolygonMode);
    memcpy(*ptr, (VkCullModeFlags*)&forMarshaling->cullMode, sizeof(VkCullModeFlags));
    *ptr += sizeof(VkCullModeFlags);
    memcpy(*ptr, (VkFrontFace*)&forMarshaling->frontFace, sizeof(VkFrontFace));
    *ptr += sizeof(VkFrontFace);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBiasEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->depthBiasConstantFactor, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->depthBiasClamp, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->depthBiasSlopeFactor, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->lineWidth, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineMultisampleStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineMultisampleStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    *ptr += sizeof(VkPipelineMultisampleStateCreateFlags);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sampleShadingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->minSampleShading, sizeof(float));
    *ptr += sizeof(float);
    // WARNING PTR CHECK
    uint64_t cgen_var_34 = (uint64_t)(uintptr_t)forMarshaling->pSampleMask;
    memcpy((*ptr), &cgen_var_34, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSampleMask)
    {
        memcpy(*ptr, (const VkSampleMask*)forMarshaling->pSampleMask, (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        *ptr += (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask);
    }
    memcpy(*ptr, (VkBool32*)&forMarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->alphaToOneEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkStencilOpState(
    VulkanStreamGuest* vkStream,
    const VkStencilOpState* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStencilOp*)&forMarshaling->failOp, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy(*ptr, (VkStencilOp*)&forMarshaling->passOp, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy(*ptr, (VkStencilOp*)&forMarshaling->depthFailOp, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy(*ptr, (VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy(*ptr, (uint32_t*)&forMarshaling->compareMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->writeMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->reference, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineDepthStencilStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineDepthStencilStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    *ptr += sizeof(VkPipelineDepthStencilStateCreateFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthWriteEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkCompareOp*)&forMarshaling->depthCompareOp, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->stencilTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->front), ptr);
    reservedmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->back), ptr);
    memcpy(*ptr, (float*)&forMarshaling->minDepthBounds, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxDepthBounds, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStreamGuest* vkStream,
    const VkPipelineColorBlendAttachmentState* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkBool32*)&forMarshaling->blendEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendOp*)&forMarshaling->colorBlendOp, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendOp*)&forMarshaling->alphaBlendOp, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy(*ptr, (VkColorComponentFlags*)&forMarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
    *ptr += sizeof(VkColorComponentFlags);
}

void reservedmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineColorBlendStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineColorBlendStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    *ptr += sizeof(VkPipelineColorBlendStateCreateFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->logicOpEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkLogicOp*)&forMarshaling->logicOp, sizeof(VkLogicOp));
    *ptr += sizeof(VkLogicOp);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        reservedmarshal_VkPipelineColorBlendAttachmentState(vkStream, (const VkPipelineColorBlendAttachmentState*)(forMarshaling->pAttachments + i), ptr);
    }
    memcpy(*ptr, (float*)forMarshaling->blendConstants, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineDynamicStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineDynamicStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    *ptr += sizeof(VkPipelineDynamicStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dynamicStateCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkDynamicState*)forMarshaling->pDynamicStates, forMarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    *ptr += forMarshaling->dynamicStateCount * sizeof(const VkDynamicState);
}

void reservedmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkGraphicsPipelineCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint32_t hasRasterization = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasRasterization = (((0 == forMarshaling->pRasterizationState)) ? (0) : (!((*(forMarshaling->pRasterizationState)).rasterizerDiscardEnable)));
        uint32_t cgen_var_35 = (uint32_t)hasRasterization;
        memcpy((*ptr), &cgen_var_35, 4);
        android::base::Stream::toBe32((uint8_t*)(*ptr));
        *ptr += 4;
    }
    uint32_t hasTessellation = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasTessellation = arrayany(forMarshaling->pStages, 0, forMarshaling->stageCount, [](VkPipelineShaderStageCreateInfo s) { return ((s.stage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT) || (s.stage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT)); });
        uint32_t cgen_var_36 = (uint32_t)hasTessellation;
        memcpy((*ptr), &cgen_var_36, 4);
        android::base::Stream::toBe32((uint8_t*)(*ptr));
        *ptr += 4;
    }
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_37 = (uint64_t)(uintptr_t)forMarshaling->pVertexInputState;
        memcpy((*ptr), &cgen_var_37, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pVertexInputState))
    {
        reservedmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_38 = (uint64_t)(uintptr_t)forMarshaling->pInputAssemblyState;
        memcpy((*ptr), &cgen_var_38, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pInputAssemblyState))
    {
        reservedmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (const VkPipelineInputAssemblyStateCreateInfo*)(forMarshaling->pInputAssemblyState), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_39 = (uint64_t)(uintptr_t)forMarshaling->pTessellationState;
    memcpy((*ptr), &cgen_var_39, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTessellationState)
    {
        if (hasTessellation)
        {
            reservedmarshal_VkPipelineTessellationStateCreateInfo(vkStream, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_40 = (uint64_t)(uintptr_t)forMarshaling->pViewportState;
    memcpy((*ptr), &cgen_var_40, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewportState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineViewportStateCreateInfo(vkStream, (const VkPipelineViewportStateCreateInfo*)(forMarshaling->pViewportState), ptr);
        }
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_41 = (uint64_t)(uintptr_t)forMarshaling->pRasterizationState;
        memcpy((*ptr), &cgen_var_41, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pRasterizationState))
    {
        reservedmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, (const VkPipelineRasterizationStateCreateInfo*)(forMarshaling->pRasterizationState), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_42 = (uint64_t)(uintptr_t)forMarshaling->pMultisampleState;
    memcpy((*ptr), &cgen_var_42, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pMultisampleState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, (const VkPipelineMultisampleStateCreateInfo*)(forMarshaling->pMultisampleState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_43 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilState;
    memcpy((*ptr), &cgen_var_43, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (const VkPipelineDepthStencilStateCreateInfo*)(forMarshaling->pDepthStencilState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_44 = (uint64_t)(uintptr_t)forMarshaling->pColorBlendState;
    memcpy((*ptr), &cgen_var_44, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pColorBlendState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, (const VkPipelineColorBlendStateCreateInfo*)(forMarshaling->pColorBlendState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_45 = (uint64_t)(uintptr_t)forMarshaling->pDynamicState;
    memcpy((*ptr), &cgen_var_45, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDynamicState)
    {
        reservedmarshal_VkPipelineDynamicStateCreateInfo(vkStream, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState), ptr);
    }
    uint64_t cgen_var_46;
    *&cgen_var_46 = get_host_u64_VkPipelineLayout((*&forMarshaling->layout));
    memcpy(*ptr, (uint64_t*)&cgen_var_46, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_47;
    *&cgen_var_47 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_47, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_48;
    *&cgen_var_48 = get_host_u64_VkPipeline((*&forMarshaling->basePipelineHandle));
    memcpy(*ptr, (uint64_t*)&cgen_var_48, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkComputePipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkComputePipelineCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forMarshaling->stage), ptr);
    uint64_t cgen_var_49;
    *&cgen_var_49 = get_host_u64_VkPipelineLayout((*&forMarshaling->layout));
    memcpy(*ptr, (uint64_t*)&cgen_var_49, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_50;
    *&cgen_var_50 = get_host_u64_VkPipeline((*&forMarshaling->basePipelineHandle));
    memcpy(*ptr, (uint64_t*)&cgen_var_50, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkPushConstantRange(
    VulkanStreamGuest* vkStream,
    const VkPushConstantRange* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->size, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineLayoutCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    *ptr += sizeof(VkPipelineLayoutCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->setLayoutCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->setLayoutCount)
    {
        uint8_t* cgen_var_51_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->setLayoutCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkDescriptorSetLayout(forMarshaling->pSetLayouts[k]);
            memcpy(cgen_var_51_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->setLayoutCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->pushConstantRangeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pushConstantRangeCount; ++i)
    {
        reservedmarshal_VkPushConstantRange(vkStream, (const VkPushConstantRange*)(forMarshaling->pPushConstantRanges + i), ptr);
    }
}

void reservedmarshal_VkSamplerCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkSamplerCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSamplerCreateFlags*)&forMarshaling->flags, sizeof(VkSamplerCreateFlags));
    *ptr += sizeof(VkSamplerCreateFlags);
    memcpy(*ptr, (VkFilter*)&forMarshaling->magFilter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy(*ptr, (VkFilter*)&forMarshaling->minFilter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy(*ptr, (VkSamplerMipmapMode*)&forMarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    *ptr += sizeof(VkSamplerMipmapMode);
    memcpy(*ptr, (VkSamplerAddressMode*)&forMarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy(*ptr, (VkSamplerAddressMode*)&forMarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy(*ptr, (VkSamplerAddressMode*)&forMarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy(*ptr, (float*)&forMarshaling->mipLodBias, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->anisotropyEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->maxAnisotropy, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->compareEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy(*ptr, (float*)&forMarshaling->minLod, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxLod, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBorderColor*)&forMarshaling->borderColor, sizeof(VkBorderColor));
    *ptr += sizeof(VkBorderColor);
    memcpy(*ptr, (VkBool32*)&forMarshaling->unnormalizedCoordinates, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDescriptorSetLayoutBinding(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutBinding* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    // WARNING PTR CHECK
    uint64_t cgen_var_52 = (uint64_t)(uintptr_t)forMarshaling->pImmutableSamplers;
    memcpy((*ptr), &cgen_var_52, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pImmutableSamplers)
    {
        if (forMarshaling->descriptorCount)
        {
            uint8_t* cgen_var_53_ptr = (uint8_t*)(*ptr);
            for (uint32_t k = 0; k < forMarshaling->descriptorCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSampler(forMarshaling->pImmutableSamplers[k]);
                memcpy(cgen_var_53_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *ptr += 8 * forMarshaling->descriptorCount;
        }
    }
}

void reservedmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDescriptorSetLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    *ptr += sizeof(VkDescriptorSetLayoutCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindingCount; ++i)
    {
        reservedmarshal_VkDescriptorSetLayoutBinding(vkStream, (const VkDescriptorSetLayoutBinding*)(forMarshaling->pBindings + i), ptr);
    }
}

void reservedmarshal_VkDescriptorPoolSize(
    VulkanStreamGuest* vkStream,
    const VkDescriptorPoolSize* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->type, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorPoolCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDescriptorPoolCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    *ptr += sizeof(VkDescriptorPoolCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSets, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->poolSizeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->poolSizeCount; ++i)
    {
        reservedmarshal_VkDescriptorPoolSize(vkStream, (const VkDescriptorPoolSize*)(forMarshaling->pPoolSizes + i), ptr);
    }
}

void reservedmarshal_VkDescriptorSetAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_54;
    *&cgen_var_54 = get_host_u64_VkDescriptorPool((*&forMarshaling->descriptorPool));
    memcpy(*ptr, (uint64_t*)&cgen_var_54, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->descriptorSetCount)
    {
        uint8_t* cgen_var_55_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->descriptorSetCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkDescriptorSetLayout(forMarshaling->pSetLayouts[k]);
            memcpy(cgen_var_55_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->descriptorSetCount;
    }
}

void reservedmarshal_VkDescriptorImageInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorImageInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_56;
    *&cgen_var_56 = get_host_u64_VkSampler((*&forMarshaling->sampler));
    memcpy(*ptr, (uint64_t*)&cgen_var_56, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_57;
    *&cgen_var_57 = get_host_u64_VkImageView((*&forMarshaling->imageView));
    memcpy(*ptr, (uint64_t*)&cgen_var_57, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->imageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkDescriptorBufferInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorBufferInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_58;
    *&cgen_var_58 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_58, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkWriteDescriptorSet(
    VulkanStreamGuest* vkStream,
    const VkWriteDescriptorSet* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_59;
    *&cgen_var_59 = get_host_u64_VkDescriptorSet((*&forMarshaling->dstSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_59, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    // WARNING PTR CHECK
    uint64_t cgen_var_60 = (uint64_t)(uintptr_t)forMarshaling->pImageInfo;
    memcpy((*ptr), &cgen_var_60, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pImageInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == forMarshaling->descriptorType))))
        {
            for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
            {
                reservedmarshal_VkDescriptorImageInfo(vkStream, (const VkDescriptorImageInfo*)(forMarshaling->pImageInfo + i), ptr);
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_61 = (uint64_t)(uintptr_t)forMarshaling->pBufferInfo;
    memcpy((*ptr), &cgen_var_61, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pBufferInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == forMarshaling->descriptorType))))
        {
            for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
            {
                reservedmarshal_VkDescriptorBufferInfo(vkStream, (const VkDescriptorBufferInfo*)(forMarshaling->pBufferInfo + i), ptr);
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_62 = (uint64_t)(uintptr_t)forMarshaling->pTexelBufferView;
    memcpy((*ptr), &cgen_var_62, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTexelBufferView)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == forMarshaling->descriptorType))))
        {
            if (forMarshaling->descriptorCount)
            {
                uint8_t* cgen_var_63_ptr = (uint8_t*)(*ptr);
                for (uint32_t k = 0; k < forMarshaling->descriptorCount; ++k)
                {
                    uint64_t tmpval = get_host_u64_VkBufferView(forMarshaling->pTexelBufferView[k]);
                    memcpy(cgen_var_63_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
                *ptr += 8 * forMarshaling->descriptorCount;
            }
        }
    }
}

void reservedmarshal_VkCopyDescriptorSet(
    VulkanStreamGuest* vkStream,
    const VkCopyDescriptorSet* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_64;
    *&cgen_var_64 = get_host_u64_VkDescriptorSet((*&forMarshaling->srcSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_64, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_65;
    *&cgen_var_65 = get_host_u64_VkDescriptorSet((*&forMarshaling->dstSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_65, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkFramebufferCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkFramebufferCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFramebufferCreateFlags*)&forMarshaling->flags, sizeof(VkFramebufferCreateFlags));
    *ptr += sizeof(VkFramebufferCreateFlags);
    uint64_t cgen_var_66;
    *&cgen_var_66 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_66, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->attachmentCount)
    {
        uint8_t* cgen_var_67_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->attachmentCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkImageView(forMarshaling->pAttachments[k]);
            memcpy(cgen_var_67_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->attachmentCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAttachmentDescription(
    VulkanStreamGuest* vkStream,
    const VkAttachmentDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkAttachmentReference(
    VulkanStreamGuest* vkStream,
    const VkAttachmentReference* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkSubpassDescription(
    VulkanStreamGuest* vkStream,
    const VkSubpassDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy(*ptr, (uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pInputAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_68 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    memcpy((*ptr), &cgen_var_68, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            reservedmarshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_69 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    memcpy((*ptr), &cgen_var_69, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilAttachment)
    {
        reservedmarshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forMarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedmarshal_VkSubpassDependency(
    VulkanStreamGuest* vkStream,
    const VkSubpassDependency* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
}

void reservedmarshal_VkRenderPassCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentDescription(vkStream, (const VkAttachmentDescription*)(forMarshaling->pAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        reservedmarshal_VkSubpassDescription(vkStream, (const VkSubpassDescription*)(forMarshaling->pSubpasses + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        reservedmarshal_VkSubpassDependency(vkStream, (const VkSubpassDependency*)(forMarshaling->pDependencies + i), ptr);
    }
}

void reservedmarshal_VkCommandPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandPoolCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkCommandPoolCreateFlags*)&forMarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    *ptr += sizeof(VkCommandPoolCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkCommandBufferAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_70;
    *&cgen_var_70 = get_host_u64_VkCommandPool((*&forMarshaling->commandPool));
    memcpy(*ptr, (uint64_t*)&cgen_var_70, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkCommandBufferLevel*)&forMarshaling->level, sizeof(VkCommandBufferLevel));
    *ptr += sizeof(VkCommandBufferLevel);
    memcpy(*ptr, (uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkCommandBufferInheritanceInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferInheritanceInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_71;
    *&cgen_var_71 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_71, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_72;
    *&cgen_var_72 = get_host_u64_VkFramebuffer((*&forMarshaling->framebuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_72, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkBool32*)&forMarshaling->occlusionQueryEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkQueryControlFlags*)&forMarshaling->queryFlags, sizeof(VkQueryControlFlags));
    *ptr += sizeof(VkQueryControlFlags);
    memcpy(*ptr, (VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedmarshal_VkCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkCommandBufferUsageFlags*)&forMarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    *ptr += sizeof(VkCommandBufferUsageFlags);
    // WARNING PTR CHECK
    uint64_t cgen_var_73 = (uint64_t)(uintptr_t)forMarshaling->pInheritanceInfo;
    memcpy((*ptr), &cgen_var_73, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pInheritanceInfo)
    {
        reservedmarshal_VkCommandBufferInheritanceInfo(vkStream, (const VkCommandBufferInheritanceInfo*)(forMarshaling->pInheritanceInfo), ptr);
    }
}

void reservedmarshal_VkBufferCopy(
    VulkanStreamGuest* vkStream,
    const VkBufferCopy* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkImageSubresourceLayers(
    VulkanStreamGuest* vkStream,
    const VkImageSubresourceLayers* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageCopy(
    VulkanStreamGuest* vkStream,
    const VkImageCopy* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset), ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkImageBlit(
    VulkanStreamGuest* vkStream,
    const VkImageBlit* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->srcOffsets + i), ptr);
    }
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->dstOffsets + i), ptr);
    }
}

void reservedmarshal_VkBufferImageCopy(
    VulkanStreamGuest* vkStream,
    const VkBufferImageCopy* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->imageOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageExtent), ptr);
}

void reservedmarshal_VkClearColorValue(
    VulkanStreamGuest* vkStream,
    const VkClearColorValue* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (float*)forMarshaling->float32, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedmarshal_VkClearDepthStencilValue(
    VulkanStreamGuest* vkStream,
    const VkClearDepthStencilValue* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (float*)&forMarshaling->depth, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stencil, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkClearValue(
    VulkanStreamGuest* vkStream,
    const VkClearValue* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forMarshaling->color), ptr);
}

void reservedmarshal_VkClearAttachment(
    VulkanStreamGuest* vkStream,
    const VkClearAttachment* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorAttachment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkClearValue(vkStream, (VkClearValue*)(&forMarshaling->clearValue), ptr);
}

void reservedmarshal_VkClearRect(
    VulkanStreamGuest* vkStream,
    const VkClearRect* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->rect), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageResolve(
    VulkanStreamGuest* vkStream,
    const VkImageResolve* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset), ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkMemoryBarrier(
    VulkanStreamGuest* vkStream,
    const VkMemoryBarrier* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
}

void reservedmarshal_VkBufferMemoryBarrier(
    VulkanStreamGuest* vkStream,
    const VkBufferMemoryBarrier* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_74;
    *&cgen_var_74 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_74, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkImageMemoryBarrier(
    VulkanStreamGuest* vkStream,
    const VkImageMemoryBarrier* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->oldLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->newLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_75;
    *&cgen_var_75 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_75, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange), ptr);
}

void reservedmarshal_VkRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_76;
    *&cgen_var_76 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_76, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_77;
    *&cgen_var_77 = get_host_u64_VkFramebuffer((*&forMarshaling->framebuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_77, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->renderArea), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->clearValueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_78 = (uint64_t)(uintptr_t)forMarshaling->pClearValues;
    memcpy((*ptr), &cgen_var_78, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->clearValueCount; ++i)
        {
            reservedmarshal_VkClearValue(vkStream, (const VkClearValue*)(forMarshaling->pClearValues + i), ptr);
        }
    }
}

void reservedmarshal_VkDispatchIndirectCommand(
    VulkanStreamGuest* vkStream,
    const VkDispatchIndirectCommand* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->x, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->y, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->z, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDrawIndexedIndirectCommand(
    VulkanStreamGuest* vkStream,
    const VkDrawIndexedIndirectCommand* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->vertexOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDrawIndirectCommand(
    VulkanStreamGuest* vkStream,
    const VkDrawIndirectCommand* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkBaseOutStructure(
    VulkanStreamGuest* vkStream,
    const VkBaseOutStructure* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
}

void reservedmarshal_VkBaseInStructure(
    VulkanStreamGuest* vkStream,
    const VkBaseInStructure* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
}

#endif
#ifdef VK_VERSION_1_1
void reservedmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSubgroupProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->supportedStages, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (VkSubgroupFeatureFlags*)&forMarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    *ptr += sizeof(VkSubgroupFeatureFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->quadOperationsInAllStages, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkBindBufferMemoryInfo(
    VulkanStreamGuest* vkStream,
    const VkBindBufferMemoryInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_79;
    *&cgen_var_79 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_79, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_80;
    *&cgen_var_80 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_80, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkBindImageMemoryInfo(
    VulkanStreamGuest* vkStream,
    const VkBindImageMemoryInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_81;
    *&cgen_var_81 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_81, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_82;
    *&cgen_var_82 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_82, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevice16BitStorageFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMemoryDedicatedRequirements(
    VulkanStreamGuest* vkStream,
    const VkMemoryDedicatedRequirements* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkMemoryDedicatedAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_83;
    *&cgen_var_83 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_83, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_84;
    *&cgen_var_84 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_84, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStreamGuest* vkStream,
    const VkMemoryAllocateFlagsInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMemoryAllocateFlags*)&forMarshaling->flags, sizeof(VkMemoryAllocateFlags));
    *ptr += sizeof(VkMemoryAllocateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupRenderPassBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->deviceRenderAreaCount; ++i)
    {
        reservedmarshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDeviceRenderAreas + i), ptr);
    }
}

void reservedmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupCommandBufferBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceGroupSubmitInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pWaitSemaphoreDeviceIndices, forMarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    *ptr += forMarshaling->waitSemaphoreCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCommandBufferDeviceMasks, forMarshaling->commandBufferCount * sizeof(const uint32_t));
    *ptr += forMarshaling->commandBufferCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pSignalSemaphoreDeviceIndices, forMarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    *ptr += forMarshaling->signalSemaphoreCount * sizeof(const uint32_t);
}

void reservedmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupBindSparseInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->resourceDeviceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryDeviceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    const VkBindBufferMemoryDeviceGroupInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forMarshaling->deviceIndexCount * sizeof(const uint32_t);
}

void reservedmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    const VkBindImageMemoryDeviceGroupInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forMarshaling->deviceIndexCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->splitInstanceBindRegionCount; ++i)
    {
        reservedmarshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pSplitInstanceBindRegions + i), ptr);
    }
}

void reservedmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceGroupProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPhysicalDevice*)forMarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subsetAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupDeviceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->physicalDeviceCount)
    {
        uint8_t* cgen_var_85_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->physicalDeviceCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkPhysicalDevice(forMarshaling->pPhysicalDevices[k]);
            memcpy(cgen_var_85_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->physicalDeviceCount;
    }
}

void reservedmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    const VkBufferMemoryRequirementsInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_86;
    *&cgen_var_86 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_86, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    const VkImageMemoryRequirementsInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_87;
    *&cgen_var_87 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_87, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    const VkImageSparseMemoryRequirementsInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_88;
    *&cgen_var_88 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_88, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    const VkMemoryRequirements2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forMarshaling->memoryRequirements), ptr);
}

void reservedmarshal_VkSparseImageMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryRequirements2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forMarshaling->memoryRequirements), ptr);
}

void reservedmarshal_VkPhysicalDeviceFeatures2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceFeatures2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forMarshaling->features), ptr);
}

void reservedmarshal_VkPhysicalDeviceProperties2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forMarshaling->properties), ptr);
}

void reservedmarshal_VkFormatProperties2(
    VulkanStreamGuest* vkStream,
    const VkFormatProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forMarshaling->formatProperties), ptr);
}

void reservedmarshal_VkImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    const VkImageFormatProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceImageFormatInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
}

void reservedmarshal_VkQueueFamilyProperties2(
    VulkanStreamGuest* vkStream,
    const VkQueueFamilyProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forMarshaling->queueFamilyProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMemoryProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forMarshaling->memoryProperties), ptr);
}

void reservedmarshal_VkSparseImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    const VkSparseImageFormatProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->properties), ptr);
}

void reservedmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSparseImageFormatInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
}

void reservedmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevicePointClippingProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
    *ptr += sizeof(VkPointClippingBehavior);
}

void reservedmarshal_VkInputAttachmentAspectReference(
    VulkanStreamGuest* vkStream,
    const VkInputAttachmentAspectReference* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->inputAttachmentIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassInputAttachmentAspectCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->aspectReferenceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->aspectReferenceCount; ++i)
    {
        reservedmarshal_VkInputAttachmentAspectReference(vkStream, (const VkInputAttachmentAspectReference*)(forMarshaling->pAspectReferences + i), ptr);
    }
}

void reservedmarshal_VkImageViewUsageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkImageViewUsageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineTessellationDomainOriginStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkTessellationDomainOrigin*)&forMarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
    *ptr += sizeof(VkTessellationDomainOrigin);
}

void reservedmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassMultiviewCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pViewMasks, forMarshaling->subpassCount * sizeof(const uint32_t));
    *ptr += forMarshaling->subpassCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const int32_t*)forMarshaling->pViewOffsets, forMarshaling->dependencyCount * sizeof(const int32_t));
    *ptr += forMarshaling->dependencyCount * sizeof(const int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->correlationMaskCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCorrelationMasks, forMarshaling->correlationMaskCount * sizeof(const uint32_t));
    *ptr += forMarshaling->correlationMaskCount * sizeof(const uint32_t);
}

void reservedmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMultiviewFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMultiviewProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceVariablePointerFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceVariablePointerFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProtectedMemoryFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProtectedMemoryProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceQueueInfo2(
    VulkanStreamGuest* vkStream,
    const VkDeviceQueueInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkProtectedSubmitInfo(
    VulkanStreamGuest* vkStream,
    const VkProtectedSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedSubmit, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkSamplerYcbcrConversionCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkSamplerYcbcrModelConversion*)&forMarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy(*ptr, (VkSamplerYcbcrRange*)&forMarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    reservedmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components), ptr);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->xChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->yChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy(*ptr, (VkFilter*)&forMarshaling->chromaFilter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy(*ptr, (VkBool32*)&forMarshaling->forceExplicitReconstruction, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStreamGuest* vkStream,
    const VkSamplerYcbcrConversionInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_89;
    *&cgen_var_89 = get_host_u64_VkSamplerYcbcrConversion((*&forMarshaling->conversion));
    memcpy(*ptr, (uint64_t*)&cgen_var_89, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStreamGuest* vkStream,
    const VkBindImagePlaneMemoryInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStreamGuest* vkStream,
    const VkImagePlaneMemoryRequirementsInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkSamplerYcbcrConversionImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStreamGuest* vkStream,
    const VkDescriptorUpdateTemplateEntry* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    uint64_t cgen_var_90 = (uint64_t)forMarshaling->offset;
    memcpy((*ptr), &cgen_var_90, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_91 = (uint64_t)forMarshaling->stride;
    memcpy((*ptr), &cgen_var_91, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorUpdateTemplateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDescriptorUpdateTemplateCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    *ptr += sizeof(VkDescriptorUpdateTemplateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorUpdateEntryCount; ++i)
    {
        reservedmarshal_VkDescriptorUpdateTemplateEntry(vkStream, (const VkDescriptorUpdateTemplateEntry*)(forMarshaling->pDescriptorUpdateEntries + i), ptr);
    }
    memcpy(*ptr, (VkDescriptorUpdateTemplateType*)&forMarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    *ptr += sizeof(VkDescriptorUpdateTemplateType);
    uint64_t cgen_var_92;
    *&cgen_var_92 = get_host_u64_VkDescriptorSetLayout((*&forMarshaling->descriptorSetLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_92, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_93;
    *&cgen_var_93 = get_host_u64_VkPipelineLayout((*&forMarshaling->pipelineLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_93, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->set, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkExternalMemoryProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkExternalMemoryFeatureFlags*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    *ptr += sizeof(VkExternalMemoryFeatureFlags);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalImageFormatInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedmarshal_VkExternalImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalBufferInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy(*ptr, (VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedmarshal_VkExternalBufferProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalBufferProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceIDProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceIDProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    *ptr += VK_LUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryImageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryBufferCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkExportMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalFenceInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

void reservedmarshal_VkExternalFenceProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalFenceProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy(*ptr, (VkExternalFenceFeatureFlags*)&forMarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
    *ptr += sizeof(VkExternalFenceFeatureFlags);
}

void reservedmarshal_VkExportFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExportFenceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
}

void reservedmarshal_VkExportSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExportSemaphoreCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
}

void reservedmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalSemaphoreInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

void reservedmarshal_VkExternalSemaphoreProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalSemaphoreProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy(*ptr, (VkExternalSemaphoreFeatureFlags*)&forMarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
    *ptr += sizeof(VkExternalSemaphoreFeatureFlags);
}

void reservedmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMaintenance3Properties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkDescriptorSetLayoutSupport(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutSupport* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->supported, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceShaderDrawParameterFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_surface
void reservedmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedmarshal_VkSurfaceFormatKHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceFormatKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkColorSpaceKHR*)&forMarshaling->colorSpace, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
}

#endif
#ifdef VK_KHR_swapchain
void reservedmarshal_VkSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSwapchainCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSwapchainCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    *ptr += sizeof(VkSwapchainCreateFlagsKHR);
    uint64_t cgen_var_94;
    *&cgen_var_94 = get_host_u64_VkSurfaceKHR((*&forMarshaling->surface));
    memcpy(*ptr, (uint64_t*)&cgen_var_94, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkFormat*)&forMarshaling->imageFormat, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkColorSpaceKHR*)&forMarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->imageUsage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->imageSharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_95 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_95, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (VkCompositeAlphaFlagBitsKHR*)&forMarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagBitsKHR);
    memcpy(*ptr, (VkPresentModeKHR*)&forMarshaling->presentMode, sizeof(VkPresentModeKHR));
    *ptr += sizeof(VkPresentModeKHR);
    memcpy(*ptr, (VkBool32*)&forMarshaling->clipped, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_96;
    *&cgen_var_96 = get_host_u64_VkSwapchainKHR((*&forMarshaling->oldSwapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_96, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkPresentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_97_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->waitSemaphoreCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pWaitSemaphores[k]);
            memcpy(cgen_var_97_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->waitSemaphoreCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->swapchainCount)
    {
        uint8_t* cgen_var_98_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->swapchainCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkSwapchainKHR(forMarshaling->pSwapchains[k]);
            memcpy(cgen_var_98_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->swapchainCount;
    }
    memcpy(*ptr, (const uint32_t*)forMarshaling->pImageIndices, forMarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forMarshaling->swapchainCount * sizeof(const uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_99 = (uint64_t)(uintptr_t)forMarshaling->pResults;
    memcpy((*ptr), &cgen_var_99, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pResults)
    {
        memcpy(*ptr, (VkResult*)forMarshaling->pResults, forMarshaling->swapchainCount * sizeof(VkResult));
        *ptr += forMarshaling->swapchainCount * sizeof(VkResult);
    }
}

void reservedmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImageSwapchainCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_100;
    *&cgen_var_100 = get_host_u64_VkSwapchainKHR((*&forMarshaling->swapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_100, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkBindImageMemorySwapchainInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_101;
    *&cgen_var_101 = get_host_u64_VkSwapchainKHR((*&forMarshaling->swapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_101, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAcquireNextImageInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkAcquireNextImageInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_102;
    *&cgen_var_102 = get_host_u64_VkSwapchainKHR((*&forMarshaling->swapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_102, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_103;
    *&cgen_var_103 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_103, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_104;
    *&cgen_var_104 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_104, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupPresentCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)forMarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

void reservedmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupPresentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceMasks, forMarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forMarshaling->swapchainCount * sizeof(const uint32_t);
    memcpy(*ptr, (VkDeviceGroupPresentModeFlagBitsKHR*)&forMarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagBitsKHR);
}

void reservedmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupSwapchainCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

#endif
#ifdef VK_KHR_display
void reservedmarshal_VkDisplayPropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_105;
    *&cgen_var_105 = get_host_u64_VkDisplayKHR((*&forMarshaling->display));
    memcpy(*ptr, (uint64_t*)&cgen_var_105, 1 * 8);
    *ptr += 1 * 8;
    {
        uint32_t l = forMarshaling->displayName ? strlen(forMarshaling->displayName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->displayName, l);
        *ptr += l;
    }
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalDimensions), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalResolution), ptr);
    memcpy(*ptr, (VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy(*ptr, (VkBool32*)&forMarshaling->planeReorderPossible, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->persistentContent, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDisplayModeParametersKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModeParametersKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->visibleRegion), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->refreshRate, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDisplayModePropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_106;
    *&cgen_var_106 = get_host_u64_VkDisplayModeKHR((*&forMarshaling->displayMode));
    memcpy(*ptr, (uint64_t*)&cgen_var_106, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters), ptr);
}

void reservedmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModeCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplayModeCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    *ptr += sizeof(VkDisplayModeCreateFlagsKHR);
    reservedmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters), ptr);
}

void reservedmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkDisplayPlaneAlphaFlagsKHR*)&forMarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagsKHR);
    reservedmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minSrcPosition), ptr);
    reservedmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxSrcPosition), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minSrcExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSrcExtent), ptr);
    reservedmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minDstPosition), ptr);
    reservedmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxDstPosition), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minDstExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxDstExtent), ptr);
}

void reservedmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlanePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    uint64_t cgen_var_107;
    *&cgen_var_107 = get_host_u64_VkDisplayKHR((*&forMarshaling->currentDisplay));
    memcpy(*ptr, (uint64_t*)&cgen_var_107, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->currentStackIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplaySurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplaySurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    *ptr += sizeof(VkDisplaySurfaceCreateFlagsKHR);
    uint64_t cgen_var_108;
    *&cgen_var_108 = get_host_u64_VkDisplayModeKHR((*&forMarshaling->displayMode));
    memcpy(*ptr, (uint64_t*)&cgen_var_108, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->planeStackIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (float*)&forMarshaling->globalAlpha, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkDisplayPlaneAlphaFlagBitsKHR*)&forMarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagBitsKHR);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent), ptr);
}

#endif
#ifdef VK_KHR_display_swapchain
void reservedmarshal_VkDisplayPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPresentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->srcRect), ptr);
    reservedmarshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->dstRect), ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->persistent, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_xlib_surface
void reservedmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkXlibSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkXlibSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXlibSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_109 = (uint64_t)(uintptr_t)forMarshaling->dpy;
    memcpy((*ptr), &cgen_var_109, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->dpy)
    {
        memcpy(*ptr, (Display*)forMarshaling->dpy, sizeof(Display));
        *ptr += sizeof(Display);
    }
    memcpy(*ptr, (Window*)&forMarshaling->window, sizeof(Window));
    *ptr += sizeof(Window);
}

#endif
#ifdef VK_KHR_xcb_surface
void reservedmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkXcbSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkXcbSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXcbSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_110 = (uint64_t)(uintptr_t)forMarshaling->connection;
    memcpy((*ptr), &cgen_var_110, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->connection)
    {
        memcpy(*ptr, (xcb_connection_t*)forMarshaling->connection, sizeof(xcb_connection_t));
        *ptr += sizeof(xcb_connection_t);
    }
    memcpy(*ptr, (xcb_window_t*)&forMarshaling->window, sizeof(xcb_window_t));
    *ptr += sizeof(xcb_window_t);
}

#endif
#ifdef VK_KHR_wayland_surface
void reservedmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkWaylandSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkWaylandSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWaylandSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_111 = (uint64_t)(uintptr_t)forMarshaling->display;
    memcpy((*ptr), &cgen_var_111, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->display)
    {
        memcpy(*ptr, (wl_display*)forMarshaling->display, sizeof(wl_display));
        *ptr += sizeof(wl_display);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_112 = (uint64_t)(uintptr_t)forMarshaling->surface;
    memcpy((*ptr), &cgen_var_112, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->surface)
    {
        memcpy(*ptr, (wl_surface*)forMarshaling->surface, sizeof(wl_surface));
        *ptr += sizeof(wl_surface);
    }
}

#endif
#ifdef VK_KHR_mir_surface
void reservedmarshal_VkMirSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkMirSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMirSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkMirSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkMirSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_113 = (uint64_t)(uintptr_t)forMarshaling->connection;
    memcpy((*ptr), &cgen_var_113, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->connection)
    {
        memcpy(*ptr, (MirConnection*)forMarshaling->connection, sizeof(MirConnection));
        *ptr += sizeof(MirConnection);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_114 = (uint64_t)(uintptr_t)forMarshaling->mirSurface;
    memcpy((*ptr), &cgen_var_114, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->mirSurface)
    {
        memcpy(*ptr, (MirSurface*)forMarshaling->mirSurface, sizeof(MirSurface));
        *ptr += sizeof(MirSurface);
    }
}

#endif
#ifdef VK_KHR_android_surface
void reservedmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkAndroidSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAndroidSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkAndroidSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_115 = (uint64_t)(uintptr_t)forMarshaling->window;
    memcpy((*ptr), &cgen_var_115, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->window)
    {
        memcpy(*ptr, (ANativeWindow*)forMarshaling->window, sizeof(ANativeWindow));
        *ptr += sizeof(ANativeWindow);
    }
}

#endif
#ifdef VK_KHR_win32_surface
void reservedmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkWin32SurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkWin32SurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWin32SurfaceCreateFlagsKHR);
    memcpy(*ptr, (HINSTANCE*)&forMarshaling->hinstance, sizeof(HINSTANCE));
    *ptr += sizeof(HINSTANCE);
    memcpy(*ptr, (HWND*)&forMarshaling->hwnd, sizeof(HWND));
    *ptr += sizeof(HWND);
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void reservedmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_116 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_116, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryWin32HandlePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryGetWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_117;
    *&cgen_var_117 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_117, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_memory_fd
void reservedmarshal_VkImportMemoryFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*ptr, (int*)&forMarshaling->fd, sizeof(int));
    *ptr += sizeof(int);
}

void reservedmarshal_VkMemoryFdPropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryFdPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMemoryGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryGetFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_118;
    *&cgen_var_118 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_118, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->acquireCount)
    {
        uint8_t* cgen_var_119_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->acquireCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pAcquireSyncs[k]);
            memcpy(cgen_var_119_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->acquireCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint64_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pAcquireTimeouts, forMarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->releaseCount)
    {
        uint8_t* cgen_var_120_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->releaseCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pReleaseSyncs[k]);
            memcpy(cgen_var_120_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->releaseCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forMarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void reservedmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportSemaphoreWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_121;
    *&cgen_var_121 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_121, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkExportSemaphoreWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_122 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_122, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkD3D12FenceSubmitInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_123 = (uint64_t)(uintptr_t)forMarshaling->pWaitSemaphoreValues;
    memcpy((*ptr), &cgen_var_123, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pWaitSemaphoreValues)
    {
        memcpy(*ptr, (const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_124 = (uint64_t)(uintptr_t)forMarshaling->pSignalSemaphoreValues;
    memcpy((*ptr), &cgen_var_124, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSignalSemaphoreValues)
    {
        memcpy(*ptr, (const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t);
    }
}

void reservedmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSemaphoreGetWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_125;
    *&cgen_var_125 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_125, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void reservedmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportSemaphoreFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_126;
    *&cgen_var_126 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_126, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy(*ptr, (int*)&forMarshaling->fd, sizeof(int));
    *ptr += sizeof(int);
}

void reservedmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSemaphoreGetFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_127;
    *&cgen_var_127 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_127, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_push_descriptor
void reservedmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPushDescriptors, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void reservedmarshal_VkRectLayerKHR(
    VulkanStreamGuest* vkStream,
    const VkRectLayerKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPresentRegionKHR(
    VulkanStreamGuest* vkStream,
    const VkPresentRegionKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->rectangleCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_128 = (uint64_t)(uintptr_t)forMarshaling->pRectangles;
    memcpy((*ptr), &cgen_var_128, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->rectangleCount; ++i)
        {
            reservedmarshal_VkRectLayerKHR(vkStream, (const VkRectLayerKHR*)(forMarshaling->pRectangles + i), ptr);
        }
    }
}

void reservedmarshal_VkPresentRegionsKHR(
    VulkanStreamGuest* vkStream,
    const VkPresentRegionsKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_129 = (uint64_t)(uintptr_t)forMarshaling->pRegions;
    memcpy((*ptr), &cgen_var_129, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            reservedmarshal_VkPresentRegionKHR(vkStream, (const VkPresentRegionKHR*)(forMarshaling->pRegions + i), ptr);
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void reservedmarshal_VkAttachmentDescription2KHR(
    VulkanStreamGuest* vkStream,
    const VkAttachmentDescription2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkAttachmentReference2KHR(
    VulkanStreamGuest* vkStream,
    const VkAttachmentReference2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedmarshal_VkSubpassDescription2KHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassDescription2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pInputAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_130 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    memcpy((*ptr), &cgen_var_130, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            reservedmarshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_131 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    memcpy((*ptr), &cgen_var_131, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilAttachment)
    {
        reservedmarshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forMarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedmarshal_VkSubpassDependency2KHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassDependency2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
    memcpy(*ptr, (int32_t*)&forMarshaling->viewOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkRenderPassCreateInfo2KHR(
    VulkanStreamGuest* vkStream,
    const VkRenderPassCreateInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentDescription2KHR(vkStream, (const VkAttachmentDescription2KHR*)(forMarshaling->pAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        reservedmarshal_VkSubpassDescription2KHR(vkStream, (const VkSubpassDescription2KHR*)(forMarshaling->pSubpasses + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        reservedmarshal_VkSubpassDependency2KHR(vkStream, (const VkSubpassDependency2KHR*)(forMarshaling->pDependencies + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCorrelatedViewMasks, forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    *ptr += forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t);
}

void reservedmarshal_VkSubpassBeginInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassBeginInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSubpassContents*)&forMarshaling->contents, sizeof(VkSubpassContents));
    *ptr += sizeof(VkSubpassContents);
}

void reservedmarshal_VkSubpassEndInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassEndInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
}

#endif
#ifdef VK_KHR_shared_presentable_image
void reservedmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkSharedPresentSurfaceCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void reservedmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportFenceWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_132;
    *&cgen_var_132 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_132, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkExportFenceWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_133 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_133, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkFenceGetWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_134;
    *&cgen_var_134 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_134, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_fence_fd
void reservedmarshal_VkImportFenceFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportFenceFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_135;
    *&cgen_var_135 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_135, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy(*ptr, (int*)&forMarshaling->fd, sizeof(int));
    *ptr += sizeof(int);
}

void reservedmarshal_VkFenceGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkFenceGetFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_136;
    *&cgen_var_136 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_136, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSurfaceInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_137;
    *&cgen_var_137 = get_host_u64_VkSurfaceKHR((*&forMarshaling->surface));
    memcpy(*ptr, (uint64_t*)&cgen_var_137, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkSurfaceCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceCapabilities2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forMarshaling->surfaceCapabilities), ptr);
}

void reservedmarshal_VkSurfaceFormat2KHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceFormat2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forMarshaling->surfaceFormat), ptr);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void reservedmarshal_VkDisplayProperties2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayProperties2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forMarshaling->displayProperties), ptr);
}

void reservedmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneProperties2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forMarshaling->displayPlaneProperties), ptr);
}

void reservedmarshal_VkDisplayModeProperties2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModeProperties2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forMarshaling->displayModeProperties), ptr);
}

void reservedmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_138;
    *&cgen_var_138 = get_host_u64_VkDisplayModeKHR((*&forMarshaling->mode));
    memcpy(*ptr, (uint64_t*)&cgen_var_138, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneCapabilities2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forMarshaling->capabilities), ptr);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void reservedmarshal_VkImageFormatListCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImageFormatListCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
    *ptr += forMarshaling->viewFormatCount * sizeof(const VkFormat);
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void reservedmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevice8BitStorageFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_shader_float16_int8
void reservedmarshal_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceShaderFloat16Int8Features* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_ANDROID_native_buffer
void reservedmarshal_VkNativeBufferANDROID(
    VulkanStreamGuest* vkStream,
    const VkNativeBufferANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_139 = (uint64_t)(uintptr_t)forMarshaling->handle;
    memcpy((*ptr), &cgen_var_139, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->handle)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->handle, sizeof(const uint32_t));
        *ptr += sizeof(const uint32_t);
    }
    memcpy(*ptr, (int*)&forMarshaling->stride, sizeof(int));
    *ptr += sizeof(int);
    memcpy(*ptr, (int*)&forMarshaling->format, sizeof(int));
    *ptr += sizeof(int);
    memcpy(*ptr, (int*)&forMarshaling->usage, sizeof(int));
    *ptr += sizeof(int);
    memcpy(*ptr, (uint64_t*)&forMarshaling->consumer, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->producer, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_debug_report
void reservedmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugReportCallbackCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    *ptr += sizeof(VkDebugReportFlagsEXT);
    uint64_t cgen_var_140 = (uint64_t)forMarshaling->pfnCallback;
    memcpy((*ptr), &cgen_var_140, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_141 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_141, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void reservedmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStreamGuest* vkStream,
    const VkPipelineRasterizationStateRasterizationOrderAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRasterizationOrderAMD*)&forMarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
    *ptr += sizeof(VkRasterizationOrderAMD);
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void reservedmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugMarkerObjectNameInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy(*ptr, (uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    {
        uint32_t l = forMarshaling->pObjectName ? strlen(forMarshaling->pObjectName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pObjectName, l);
        *ptr += l;
    }
}

void reservedmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugMarkerObjectTagInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy(*ptr, (uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_142 = (uint64_t)forMarshaling->tagSize;
    memcpy((*ptr), &cgen_var_142, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forMarshaling->tagSize * sizeof(const uint8_t);
}

void reservedmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugMarkerMarkerInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    {
        uint32_t l = forMarshaling->pMarkerName ? strlen(forMarshaling->pMarkerName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pMarkerName, l);
        *ptr += l;
    }
    memcpy(*ptr, (float*)forMarshaling->color, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void reservedmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkDedicatedAllocationImageCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkDedicatedAllocationBufferCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkDedicatedAllocationMemoryAllocateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_143;
    *&cgen_var_143 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_143, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_144;
    *&cgen_var_144 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_144, 1 * 8);
    *ptr += 1 * 8;
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void reservedmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStreamGuest* vkStream,
    const VkTextureLODGatherFormatPropertiesAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_shader_info
void reservedmarshal_VkShaderResourceUsageAMD(
    VulkanStreamGuest* vkStream,
    const VkShaderResourceUsageAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->numUsedVgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numUsedSgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_145 = (uint64_t)forMarshaling->ldsUsageSizeInBytes;
    memcpy((*ptr), &cgen_var_145, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_146 = (uint64_t)forMarshaling->scratchMemUsageInBytes;
    memcpy((*ptr), &cgen_var_146, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkShaderStatisticsInfoAMD(
    VulkanStreamGuest* vkStream,
    const VkShaderStatisticsInfoAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    reservedmarshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forMarshaling->resourceUsage), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numPhysicalVgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numPhysicalSgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numAvailableVgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numAvailableSgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void reservedmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStreamGuest* vkStream,
    const VkExternalImageFormatPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    reservedmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties), ptr);
    memcpy(*ptr, (VkExternalMemoryFeatureFlagsNV*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    *ptr += sizeof(VkExternalMemoryFeatureFlagsNV);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory
void reservedmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryImageCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

void reservedmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryAllocateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory_win32
void reservedmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryWin32HandleInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
}

void reservedmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryWin32HandleInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_147 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_147, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStreamGuest* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->acquireCount)
    {
        uint8_t* cgen_var_148_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->acquireCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pAcquireSyncs[k]);
            memcpy(cgen_var_148_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->acquireCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint64_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pAcquireTimeoutMilliseconds, forMarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->releaseCount)
    {
        uint8_t* cgen_var_149_ptr = (uint8_t*)(*ptr);
        for (uint32_t k = 0; k < forMarshaling->releaseCount; ++k)
        {
            uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pReleaseSyncs[k]);
            memcpy(cgen_var_149_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *ptr += 8 * forMarshaling->releaseCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forMarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_EXT_validation_flags
void reservedmarshal_VkValidationFlagsEXT(
    VulkanStreamGuest* vkStream,
    const VkValidationFlagsEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkValidationCheckEXT*)forMarshaling->pDisabledValidationChecks, forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    *ptr += forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT);
}

#endif
#ifdef VK_NN_vi_surface
void reservedmarshal_VkViSurfaceCreateInfoNN(
    VulkanStreamGuest* vkStream,
    const VkViSurfaceCreateInfoNN* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkViSurfaceCreateFlagsNN*)&forMarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    *ptr += sizeof(VkViSurfaceCreateFlagsNN);
    // WARNING PTR CHECK
    uint64_t cgen_var_150 = (uint64_t)(uintptr_t)forMarshaling->window;
    memcpy((*ptr), &cgen_var_150, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->window)
    {
        memcpy(*ptr, (void*)forMarshaling->window, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void reservedmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkConditionalRenderingBeginInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_151;
    *&cgen_var_151 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_151, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkConditionalRenderingFlagsEXT*)&forMarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
    *ptr += sizeof(VkConditionalRenderingFlagsEXT);
}

void reservedmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conditionalRendering, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->inheritedConditionalRendering, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conditionalRenderingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NVX_device_generated_commands
void reservedmarshal_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanStreamGuest* vkStream,
    const VkDeviceGeneratedCommandsFeaturesNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->computeBindingPointSupport, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanStreamGuest* vkStream,
    const VkDeviceGeneratedCommandsLimitsNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxIndirectCommandsLayoutTokenCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxObjectEntryCounts, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSequenceCountBufferOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSequenceIndexBufferOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minCommandsTokenBufferOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkIndirectCommandsTokenNVX(
    VulkanStreamGuest* vkStream,
    const VkIndirectCommandsTokenNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkIndirectCommandsTokenTypeNVX*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    *ptr += sizeof(VkIndirectCommandsTokenTypeNVX);
    uint64_t cgen_var_152;
    *&cgen_var_152 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_152, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkIndirectCommandsLayoutTokenNVX(
    VulkanStreamGuest* vkStream,
    const VkIndirectCommandsLayoutTokenNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkIndirectCommandsTokenTypeNVX*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    *ptr += sizeof(VkIndirectCommandsTokenTypeNVX);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindingUnit, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dynamicCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkIndirectCommandsLayoutCreateInfoNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy(*ptr, (VkIndirectCommandsLayoutUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNVX));
    *ptr += sizeof(VkIndirectCommandsLayoutUsageFlagsNVX);
    memcpy(*ptr, (uint32_t*)&forMarshaling->tokenCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->tokenCount; ++i)
    {
        reservedmarshal_VkIndirectCommandsLayoutTokenNVX(vkStream, (const VkIndirectCommandsLayoutTokenNVX*)(forMarshaling->pTokens + i), ptr);
    }
}

void reservedmarshal_VkCmdProcessCommandsInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkCmdProcessCommandsInfoNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_153;
    *&cgen_var_153 = get_host_u64_VkObjectTableNVX((*&forMarshaling->objectTable));
    memcpy(*ptr, (uint64_t*)&cgen_var_153, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_154;
    *&cgen_var_154 = get_host_u64_VkIndirectCommandsLayoutNVX((*&forMarshaling->indirectCommandsLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_154, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->indirectCommandsTokenCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->indirectCommandsTokenCount; ++i)
    {
        reservedmarshal_VkIndirectCommandsTokenNVX(vkStream, (const VkIndirectCommandsTokenNVX*)(forMarshaling->pIndirectCommandsTokens + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_155;
    *&cgen_var_155 = get_host_u64_VkCommandBuffer((*&forMarshaling->targetCommandBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_155, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_156;
    *&cgen_var_156 = get_host_u64_VkBuffer((*&forMarshaling->sequencesCountBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_156, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_157;
    *&cgen_var_157 = get_host_u64_VkBuffer((*&forMarshaling->sequencesIndexBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_157, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkCmdReserveSpaceForCommandsInfoNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_158;
    *&cgen_var_158 = get_host_u64_VkObjectTableNVX((*&forMarshaling->objectTable));
    memcpy(*ptr, (uint64_t*)&cgen_var_158, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_159;
    *&cgen_var_159 = get_host_u64_VkIndirectCommandsLayoutNVX((*&forMarshaling->indirectCommandsLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_159, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkObjectTableCreateInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableCreateInfoNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkObjectEntryTypeNVX*)forMarshaling->pObjectEntryTypes, forMarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    *ptr += forMarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pObjectEntryCounts, forMarshaling->objectCount * sizeof(const uint32_t));
    *ptr += forMarshaling->objectCount * sizeof(const uint32_t);
    memcpy(*ptr, (const VkObjectEntryUsageFlagsNVX*)forMarshaling->pObjectEntryUsageFlags, forMarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    *ptr += forMarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxUniformBuffersPerDescriptor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxStorageBuffersPerDescriptor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxStorageImagesPerDescriptor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSampledImagesPerDescriptor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPipelineLayouts, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkObjectTableEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableEntryNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy(*ptr, (VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
}

void reservedmarshal_VkObjectTablePipelineEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTablePipelineEntryNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy(*ptr, (VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_160;
    *&cgen_var_160 = get_host_u64_VkPipeline((*&forMarshaling->pipeline));
    memcpy(*ptr, (uint64_t*)&cgen_var_160, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkObjectTableDescriptorSetEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableDescriptorSetEntryNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy(*ptr, (VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_161;
    *&cgen_var_161 = get_host_u64_VkPipelineLayout((*&forMarshaling->pipelineLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_161, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_162;
    *&cgen_var_162 = get_host_u64_VkDescriptorSet((*&forMarshaling->descriptorSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_162, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkObjectTableVertexBufferEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableVertexBufferEntryNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy(*ptr, (VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_163;
    *&cgen_var_163 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_163, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkObjectTableIndexBufferEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableIndexBufferEntryNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy(*ptr, (VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_164;
    *&cgen_var_164 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_164, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
}

void reservedmarshal_VkObjectTablePushConstantEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTablePushConstantEntryNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy(*ptr, (VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_165;
    *&cgen_var_165 = get_host_u64_VkPipelineLayout((*&forMarshaling->pipelineLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_165, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void reservedmarshal_VkViewportWScalingNV(
    VulkanStreamGuest* vkStream,
    const VkViewportWScalingNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (float*)&forMarshaling->xcoeff, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->ycoeff, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineViewportWScalingStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->viewportWScalingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_166 = (uint64_t)(uintptr_t)forMarshaling->pViewportWScalings;
    memcpy((*ptr), &cgen_var_166, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkViewportWScalingNV(vkStream, (const VkViewportWScalingNV*)(forMarshaling->pViewportWScalings + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void reservedmarshal_VkSurfaceCapabilities2EXT(
    VulkanStreamGuest* vkStream,
    const VkSurfaceCapabilities2EXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkSurfaceCounterFlagsEXT*)&forMarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_EXT_display_control
void reservedmarshal_VkDisplayPowerInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDisplayPowerInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplayPowerStateEXT*)&forMarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
    *ptr += sizeof(VkDisplayPowerStateEXT);
}

void reservedmarshal_VkDeviceEventInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDeviceEventInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceEventTypeEXT*)&forMarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
    *ptr += sizeof(VkDeviceEventTypeEXT);
}

void reservedmarshal_VkDisplayEventInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDisplayEventInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplayEventTypeEXT*)&forMarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
    *ptr += sizeof(VkDisplayEventTypeEXT);
}

void reservedmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkSwapchainCounterCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSurfaceCounterFlagsEXT*)&forMarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_GOOGLE_display_timing
void reservedmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkRefreshCycleDurationGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint64_t*)&forMarshaling->refreshDuration, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkPastPresentationTimingGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->actualPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->earliestPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->presentMargin, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPresentTimeGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkPresentTimeGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkPresentTimesInfoGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_167 = (uint64_t)(uintptr_t)forMarshaling->pTimes;
    memcpy((*ptr), &cgen_var_167, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            reservedmarshal_VkPresentTimeGOOGLE(vkStream, (const VkPresentTimeGOOGLE*)(forMarshaling->pTimes + i), ptr);
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void reservedmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->perViewPositionAllComponents, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_viewport_swizzle
void reservedmarshal_VkViewportSwizzleNV(
    VulkanStreamGuest* vkStream,
    const VkViewportSwizzleNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
}

void reservedmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineViewportSwizzleStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineViewportSwizzleStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_168 = (uint64_t)(uintptr_t)forMarshaling->pViewportSwizzles;
    memcpy((*ptr), &cgen_var_168, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkViewportSwizzleNV(vkStream, (const VkViewportSwizzleNV*)(forMarshaling->pViewportSwizzles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void reservedmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDiscardRectangles, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT);
    memcpy(*ptr, (VkDiscardRectangleModeEXT*)&forMarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    *ptr += sizeof(VkDiscardRectangleModeEXT);
    memcpy(*ptr, (uint32_t*)&forMarshaling->discardRectangleCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_169 = (uint64_t)(uintptr_t)forMarshaling->pDiscardRectangles;
    memcpy((*ptr), &cgen_var_169, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->discardRectangleCount; ++i)
        {
            reservedmarshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDiscardRectangles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void reservedmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (float*)&forMarshaling->primitiveOverestimationSize, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->primitiveUnderestimation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    memcpy(*ptr, (VkConservativeRasterizationModeEXT*)&forMarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    *ptr += sizeof(VkConservativeRasterizationModeEXT);
    memcpy(*ptr, (float*)&forMarshaling->extraPrimitiveOverestimationSize, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void reservedmarshal_VkXYColorEXT(
    VulkanStreamGuest* vkStream,
    const VkXYColorEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (float*)&forMarshaling->x, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->y, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkHdrMetadataEXT(
    VulkanStreamGuest* vkStream,
    const VkHdrMetadataEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryRed), ptr);
    reservedmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryGreen), ptr);
    reservedmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryBlue), ptr);
    reservedmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->whitePoint), ptr);
    memcpy(*ptr, (float*)&forMarshaling->maxLuminance, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->minLuminance, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxContentLightLevel, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxFrameAverageLightLevel, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_MVK_ios_surface
void reservedmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    const VkIOSSurfaceCreateInfoMVK* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkIOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkIOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    uint64_t cgen_var_170 = (uint64_t)(uintptr_t)forMarshaling->pView;
    memcpy((*ptr), &cgen_var_170, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pView)
    {
        memcpy(*ptr, (const void*)forMarshaling->pView, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_macos_surface
void reservedmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    const VkMacOSSurfaceCreateInfoMVK* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMacOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkMacOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    uint64_t cgen_var_171 = (uint64_t)(uintptr_t)forMarshaling->pView;
    memcpy((*ptr), &cgen_var_171, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pView)
    {
        memcpy(*ptr, (const void*)forMarshaling->pView, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void reservedmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsObjectNameInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy(*ptr, (uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_172 = (uint64_t)(uintptr_t)forMarshaling->pObjectName;
        memcpy((*ptr), &cgen_var_172, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pObjectName)
        {
            {
                uint32_t l = forMarshaling->pObjectName ? strlen(forMarshaling->pObjectName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pObjectName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pObjectName ? strlen(forMarshaling->pObjectName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pObjectName, l);
            *ptr += l;
        }
    }
}

void reservedmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsObjectTagInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy(*ptr, (uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_173 = (uint64_t)forMarshaling->tagSize;
    memcpy((*ptr), &cgen_var_173, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forMarshaling->tagSize * sizeof(const uint8_t);
}

void reservedmarshal_VkDebugUtilsLabelEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsLabelEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    {
        uint32_t l = forMarshaling->pLabelName ? strlen(forMarshaling->pLabelName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pLabelName, l);
        *ptr += l;
    }
    memcpy(*ptr, (float*)forMarshaling->color, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsMessengerCallbackDataEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_174 = (uint64_t)(uintptr_t)forMarshaling->pMessageIdName;
        memcpy((*ptr), &cgen_var_174, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pMessageIdName)
        {
            {
                uint32_t l = forMarshaling->pMessageIdName ? strlen(forMarshaling->pMessageIdName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pMessageIdName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pMessageIdName ? strlen(forMarshaling->pMessageIdName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pMessageIdName, l);
            *ptr += l;
        }
    }
    memcpy(*ptr, (int32_t*)&forMarshaling->messageIdNumber, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    {
        uint32_t l = forMarshaling->pMessage ? strlen(forMarshaling->pMessage): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pMessage, l);
        *ptr += l;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueLabelCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_175 = (uint64_t)(uintptr_t)forMarshaling->pQueueLabels;
    memcpy((*ptr), &cgen_var_175, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueLabelCount; ++i)
        {
            reservedmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pQueueLabels + i), ptr);
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->cmdBufLabelCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_176 = (uint64_t)(uintptr_t)forMarshaling->pCmdBufLabels;
    memcpy((*ptr), &cgen_var_176, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->cmdBufLabelCount; ++i)
        {
            reservedmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pCmdBufLabels + i), ptr);
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_177 = (uint64_t)(uintptr_t)forMarshaling->pObjects;
    memcpy((*ptr), &cgen_var_177, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->objectCount; ++i)
        {
            reservedmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forMarshaling->pObjects + i), ptr);
        }
    }
}

void reservedmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsMessengerCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugUtilsMessengerCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCreateFlagsEXT);
    memcpy(*ptr, (VkDebugUtilsMessageSeverityFlagsEXT*)&forMarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageSeverityFlagsEXT);
    memcpy(*ptr, (VkDebugUtilsMessageTypeFlagsEXT*)&forMarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    uint64_t cgen_var_178 = (uint64_t)forMarshaling->pfnUserCallback;
    memcpy((*ptr), &cgen_var_178, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_179 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_179, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void reservedmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStreamGuest* vkStream,
    const VkAndroidHardwareBufferUsageANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    const VkAndroidHardwareBufferPropertiesANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    reservedmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->samplerYcbcrConversionComponents), ptr);
    memcpy(*ptr, (VkSamplerYcbcrModelConversion*)&forMarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy(*ptr, (VkSamplerYcbcrRange*)&forMarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
}

void reservedmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    const VkImportAndroidHardwareBufferInfoANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (AHardwareBuffer*)forMarshaling->buffer, sizeof(AHardwareBuffer));
    *ptr += sizeof(AHardwareBuffer);
}

void reservedmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_180;
    *&cgen_var_180 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_180, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkExternalFormatANDROID(
    VulkanStreamGuest* vkStream,
    const VkExternalFormatANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void reservedmarshal_VkSamplerReductionModeCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkSamplerReductionModeCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSamplerReductionModeEXT*)&forMarshaling->reductionMode, sizeof(VkSamplerReductionModeEXT));
    *ptr += sizeof(VkSamplerReductionModeEXT);
}

void reservedmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void reservedmarshal_VkSampleLocationEXT(
    VulkanStreamGuest* vkStream,
    const VkSampleLocationEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (float*)&forMarshaling->x, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->y, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkSampleLocationsInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkSampleLocationsInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->sampleLocationGridSize), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sampleLocationsCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationsCount; ++i)
    {
        reservedmarshal_VkSampleLocationEXT(vkStream, (const VkSampleLocationEXT*)(forMarshaling->pSampleLocations + i), ptr);
    }
}

void reservedmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    const VkAttachmentSampleLocationsEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo), ptr);
}

void reservedmarshal_VkSubpassSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    const VkSubpassSampleLocationsEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo), ptr);
}

void reservedmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkRenderPassSampleLocationsBeginInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        reservedmarshal_VkAttachmentSampleLocationsEXT(vkStream, (const VkAttachmentSampleLocationsEXT*)(forMarshaling->pAttachmentInitialSampleLocations + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->postSubpassSampleLocationsCount; ++i)
    {
        reservedmarshal_VkSubpassSampleLocationsEXT(vkStream, (const VkSubpassSampleLocationsEXT*)(forMarshaling->pPostSubpassSampleLocations + i), ptr);
    }
}

void reservedmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineSampleLocationsStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sampleLocationsEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo), ptr);
}

void reservedmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize), ptr);
    memcpy(*ptr, (float*)forMarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variableSampleLocations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMultisamplePropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkMultisamplePropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    reservedmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize), ptr);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendAllOperations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->srcPremultiplied, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dstPremultiplied, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBlendOverlapEXT*)&forMarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
    *ptr += sizeof(VkBlendOverlapEXT);
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void reservedmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineCoverageToColorStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCoverageToColorStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageToColorStateCreateFlagsNV);
    memcpy(*ptr, (VkBool32*)&forMarshaling->coverageToColorEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->coverageToColorLocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void reservedmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineCoverageModulationStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCoverageModulationStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageModulationStateCreateFlagsNV);
    memcpy(*ptr, (VkCoverageModulationModeNV*)&forMarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    *ptr += sizeof(VkCoverageModulationModeNV);
    memcpy(*ptr, (VkBool32*)&forMarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->coverageModulationTableCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_181 = (uint64_t)(uintptr_t)forMarshaling->pCoverageModulationTable;
    memcpy((*ptr), &cgen_var_181, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pCoverageModulationTable)
    {
        memcpy(*ptr, (const float*)forMarshaling->pCoverageModulationTable, forMarshaling->coverageModulationTableCount * sizeof(const float));
        *ptr += forMarshaling->coverageModulationTableCount * sizeof(const float);
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void reservedmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkValidationCacheCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkValidationCacheCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    *ptr += sizeof(VkValidationCacheCreateFlagsEXT);
    uint64_t cgen_var_182 = (uint64_t)forMarshaling->initialDataSize;
    memcpy((*ptr), &cgen_var_182, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkShaderModuleValidationCacheCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    uint64_t cgen_var_183;
    *&cgen_var_183 = get_host_u64_VkValidationCacheEXT((*&forMarshaling->validationCache));
    memcpy(*ptr, (uint64_t*)&cgen_var_183, 1 * 8);
    *ptr += 1 * 8;
}

#endif
#ifdef VK_EXT_descriptor_indexing
void reservedmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkDescriptorBindingFlagsEXT*)forMarshaling->pBindingFlags, forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
    *ptr += forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT);
}

void reservedmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDescriptorCounts, forMarshaling->descriptorSetCount * sizeof(const uint32_t));
    *ptr += forMarshaling->descriptorSetCount * sizeof(const uint32_t);
}

void reservedmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void reservedmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkQueueGlobalPriorityEXT*)&forMarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
    *ptr += sizeof(VkQueueGlobalPriorityEXT);
}

#endif
#ifdef VK_EXT_external_memory_host
void reservedmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryHostPointerInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_184 = (uint64_t)(uintptr_t)forMarshaling->pHostPointer;
    memcpy((*ptr), &cgen_var_184, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pHostPointer)
    {
        memcpy(*ptr, (void*)forMarshaling->pHostPointer, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkMemoryHostPointerPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void reservedmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceShaderCorePropertiesAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderEngineCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->simdPerComputeUnit, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->wavefrontSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sgprsPerSimd, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vgprsPerSimd, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minVgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vgprAllocationGranularity, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void reservedmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStreamGuest* vkStream,
    const VkVertexInputBindingDivisorDescriptionEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDivisorCount; ++i)
    {
        reservedmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (const VkVertexInputBindingDivisorDescriptionEXT*)(forMarshaling->pVertexBindingDivisors + i), ptr);
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void reservedmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStreamGuest* vkStream,
    const VkQueueFamilyCheckpointPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
}

void reservedmarshal_VkCheckpointDataNV(
    VulkanStreamGuest* vkStream,
    const VkCheckpointDataNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineStageFlagBits*)&forMarshaling->stage, sizeof(VkPipelineStageFlagBits));
    *ptr += sizeof(VkPipelineStageFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_185 = (uint64_t)(uintptr_t)forMarshaling->pCheckpointMarker;
    memcpy((*ptr), &cgen_var_185, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pCheckpointMarker)
    {
        memcpy(*ptr, (void*)forMarshaling->pCheckpointMarker, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
#ifdef VK_GOOGLE_color_buffer
void reservedmarshal_VkImportColorBufferGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkImportColorBufferGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorBuffer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImportBufferGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkImportBufferGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->buffer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImportPhysicalAddressGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkImportPhysicalAddressGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    reservedmarshal_extension_struct(vkStream, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->physicalAddress, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy(*ptr, (uint32_t*)&forMarshaling->tilingParameter, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
#endif
#ifdef VK_GOOGLE_async_command_buffers
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
#endif
#ifdef VK_GOOGLE_address_space_info
#endif
#ifdef VK_GOOGLE_free_memory_sync
#endif
#ifdef VK_GOOGLE_async_queue_submit
#endif
#ifdef VK_GOOGLE_linear_image_layout
#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_GOOGLE_queue_submit_with_commands
#endif
void reservedmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    const void* structExtension,
    uint8_t** ptr)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension);
    uint32_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), structExtension);
    if (!currExtSize && structExtension)
    {
        // unknown struct extension; skip and call on its pNext field
        reservedmarshal_extension_struct(vkStream, (void*)structAccess->pNext, ptr);
        return;
    }
    else
    {
        // known or null extension struct
        memcpy(*ptr, &currExtSize, sizeof(uint32_t));;
        android::base::Stream::toBe32((uint8_t*)*ptr); *ptr += sizeof(uint32_t);
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    memcpy(*ptr, structExtension, sizeof(VkStructureType)); *ptr += sizeof(VkStructureType);
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceSubgroupProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            reservedmarshal_VkPhysicalDevice16BitStorageFeatures(vkStream, reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            reservedmarshal_VkMemoryDedicatedRequirements(vkStream, reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            reservedmarshal_VkMemoryDedicatedAllocateInfo(vkStream, reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            reservedmarshal_VkMemoryAllocateFlagsInfo(vkStream, reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            reservedmarshal_VkDeviceGroupRenderPassBeginInfo(vkStream, reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            reservedmarshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            reservedmarshal_VkDeviceGroupSubmitInfo(vkStream, reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            reservedmarshal_VkDeviceGroupBindSparseInfo(vkStream, reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedmarshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedmarshal_VkBindImageMemoryDeviceGroupInfo(vkStream, reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            reservedmarshal_VkDeviceGroupDeviceCreateInfo(vkStream, reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            reservedmarshal_VkPhysicalDeviceFeatures2(vkStream, reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDevicePointClippingProperties(vkStream, reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            reservedmarshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            reservedmarshal_VkImageViewUsageCreateInfo(vkStream, reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            reservedmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            reservedmarshal_VkRenderPassMultiviewCreateInfo(vkStream, reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceMultiviewFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceMultiviewProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceVariablePointerFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceVariablePointerFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            reservedmarshal_VkProtectedSubmitInfo(vkStream, reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            reservedmarshal_VkSamplerYcbcrConversionInfo(vkStream, reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            reservedmarshal_VkBindImagePlaneMemoryInfo(vkStream, reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            reservedmarshal_VkImagePlaneMemoryRequirementsInfo(vkStream, reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            reservedmarshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            reservedmarshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            reservedmarshal_VkExternalImageFormatProperties(vkStream, reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceIDProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            reservedmarshal_VkExternalMemoryImageCreateInfo(vkStream, reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            reservedmarshal_VkExternalMemoryBufferCreateInfo(vkStream, reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            reservedmarshal_VkExportMemoryAllocateInfo(vkStream, reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            reservedmarshal_VkExportFenceCreateInfo(vkStream, reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            reservedmarshal_VkExportSemaphoreCreateInfo(vkStream, reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceMaintenance3Properties(vkStream, reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedmarshal_VkImageSwapchainCreateInfoKHR(vkStream, reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            reservedmarshal_VkBindImageMemorySwapchainInfoKHR(vkStream, reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            reservedmarshal_VkDeviceGroupPresentInfoKHR(vkStream, reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedmarshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            reservedmarshal_VkDisplayPresentInfoKHR(vkStream, reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkImportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkExportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            reservedmarshal_VkImportMemoryFdInfoKHR(vkStream, reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            reservedmarshal_VkD3D12FenceSubmitInfoKHR(vkStream, reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            reservedmarshal_VkPresentRegionsKHR(vkStream, reinterpret_cast<const VkPresentRegionsKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            reservedmarshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkExportFenceWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            reservedmarshal_VkImageFormatListCreateInfoKHR(vkStream, reinterpret_cast<const VkImageFormatListCreateInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shader_float16_int8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceShaderFloat16Int8Features(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            reservedmarshal_VkNativeBufferANDROID(vkStream, reinterpret_cast<const VkNativeBufferANDROID*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            reservedmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            reservedmarshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            reservedmarshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            reservedmarshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            reservedmarshal_VkExternalMemoryImageCreateInfoNV(vkStream, reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedmarshal_VkExportMemoryAllocateInfoNV(vkStream, reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedmarshal_VkImportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedmarshal_VkExportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            reservedmarshal_VkValidationFlagsEXT(vkStream, reinterpret_cast<const VkValidationFlagsEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            reservedmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            reservedmarshal_VkSwapchainCounterCreateInfoEXT(vkStream, reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            reservedmarshal_VkPresentTimesInfoGOOGLE(vkStream, reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            reservedmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            reservedmarshal_VkAndroidHardwareBufferUsageANDROID(vkStream, reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            reservedmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            reservedmarshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            reservedmarshal_VkExternalFormatANDROID(vkStream, reinterpret_cast<const VkExternalFormatANDROID*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkSamplerReductionModeCreateInfoEXT(vkStream, reinterpret_cast<const VkSamplerReductionModeCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            reservedmarshal_VkSampleLocationsInfoEXT(vkStream, reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            reservedmarshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(vkStream, reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            reservedmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(vkStream, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            reservedmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(vkStream, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            reservedmarshal_VkImportMemoryHostPointerInfoEXT(vkStream, reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            reservedmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            reservedmarshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            reservedmarshal_VkImportColorBufferGOOGLE(vkStream, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            reservedmarshal_VkImportBufferGOOGLE(vkStream, reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            reservedmarshal_VkImportPhysicalAddressGOOGLE(vkStream, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), ptr);
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}


} // namespace goldfish_vk
