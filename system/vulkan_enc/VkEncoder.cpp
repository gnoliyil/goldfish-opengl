// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkEncoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkEncoder.h"


#include "IOStream.h"
#include "Resources.h"
#include "ResourceTracker.h"
#include "Validation.h"
#include "VulkanStreamGuest.h"

#include "android/base/AlignedBuf.h"
#include "android/base/BumpPool.h"
#include "android/base/synchronization/AndroidLock.h"

#include <cutils/properties.h>

#include "goldfish_vk_marshaling_guest.h"
#include "goldfish_vk_reserved_marshaling_guest.h"
#include "goldfish_vk_deepcopy_guest.h"
#include "goldfish_vk_counting_guest.h"
#include "goldfish_vk_handlemap_guest.h"
#include "goldfish_vk_private_defs.h"
#include "goldfish_vk_transform_guest.h"

#include <unordered_map>



namespace goldfish_vk {



using namespace goldfish_vk;

using android::aligned_buf_alloc;
using android::aligned_buf_free;
using android::base::guest::AutoLock;
using android::base::guest::Lock;
using android::base::BumpPool;

#include "VkEncoder.cpp.inl"

#define VALIDATE_RET(retType, success, validate) \
    retType goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != success) return goldfish_vk_validateResult; \

#define VALIDATE_VOID(validate) \
    VkResult goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != VK_SUCCESS) return; \

#ifdef VK_VERSION_1_0
VkResult VkEncoder::vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstanceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkInstanceCreateInfo*)pool->alloc(sizeof(const VkInstanceCreateInfo));
        deepcopy_VkInstanceCreateInfo(pool, pCreateInfo, (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkInstanceCreateInfo(sResourceTracker, (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        count_VkInstanceCreateInfo(sFeatureBits, (VkInstanceCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_0;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateInstance = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateInstance);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateInstance = OP_vkCreateInstance;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    reservedmarshal_VkInstanceCreateInfo(stream, (VkInstanceCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pInstance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_3, (VkInstance*)pInstance, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    stream->read(&vkCreateInstance_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateInstance(this, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateInstance_VkResult_return;
}

void VkEncoder::vkDestroyInstance(
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_4;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyInstance = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyInstance);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyInstance = OP_vkDestroyInstance;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_5;
    *&cgen_var_5 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_5, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_6 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_6, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkInstance((VkInstance*)&instance);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkEnumeratePhysicalDevices(
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    local_instance = instance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_7;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDevices)
        {
            if ((*(pPhysicalDeviceCount)))
            {
                *countPtr += (*(pPhysicalDeviceCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDevices = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDevices);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDevices = OP_vkEnumeratePhysicalDevices;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDevices, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDevices, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_9;
    *&cgen_var_9 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_9, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
    memcpy((*streamPtrPtr), &cgen_var_10, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_11 = (uint64_t)(uintptr_t)pPhysicalDevices;
    memcpy((*streamPtrPtr), &cgen_var_11, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDevices)
    {
        if ((*(pPhysicalDeviceCount)))
        {
            uint8_t* cgen_var_12_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < (*(pPhysicalDeviceCount)); ++k)
            {
                uint64_t tmpval = (uint64_t)(pPhysicalDevices[k]);
                memcpy(cgen_var_12_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * (*(pPhysicalDeviceCount));
        }
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceCount;
    check_pPhysicalDeviceCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceCount)
    {
        if (!(check_pPhysicalDeviceCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->setHandleMapping(sResourceTracker->createMapping());
    // WARNING PTR CHECK
    VkPhysicalDevice* check_pPhysicalDevices;
    check_pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)stream->getBe64();
    if (pPhysicalDevices)
    {
        if (!(check_pPhysicalDevices))
        {
            fprintf(stderr, "fatal: pPhysicalDevices inconsistent between guest and host\n");
        }
        if ((*(pPhysicalDeviceCount)))
        {
            uint64_t* cgen_var_15;
            stream->alloc((void**)&cgen_var_15, (*(pPhysicalDeviceCount)) * 8);
            stream->read((uint64_t*)cgen_var_15, (*(pPhysicalDeviceCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_15, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
        }
    }
    stream->unsetHandleMapping();
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDevices_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_16;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceFeatures(sFeatureBits, (VkPhysicalDeviceFeatures*)(pFeatures), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFeatures);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFeatures = OP_vkGetPhysicalDeviceFeatures;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_17;
    *&cgen_var_17 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_17, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures), streamPtrPtr);
    unmarshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures(sResourceTracker, (VkPhysicalDeviceFeatures*)(pFeatures));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_18;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        count_VkFormatProperties(sFeatureBits, (VkFormatProperties*)(pFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFormatProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties = OP_vkGetPhysicalDeviceFormatProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_19;
    *&cgen_var_19 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_19, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    reservedmarshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties), streamPtrPtr);
    unmarshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties(sResourceTracker, (VkFormatProperties*)(pFormatProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_20;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageType);
        *countPtr += sizeof(VkImageTiling);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(VkImageCreateFlags);
        count_VkImageFormatProperties(sFeatureBits, (VkImageFormatProperties*)(pImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceImageFormatProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties = OP_vkGetPhysicalDeviceImageFormatProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_21;
    *&cgen_var_21 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_21, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageType*)&local_type, sizeof(VkImageType));
    *streamPtrPtr += sizeof(VkImageType);
    memcpy(*streamPtrPtr, (VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    *streamPtrPtr += sizeof(VkImageTiling);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    *streamPtrPtr += sizeof(VkImageCreateFlags);
    reservedmarshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties), streamPtrPtr);
    unmarshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties(sResourceTracker, (VkImageFormatProperties*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_22;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceProperties(sFeatureBits, (VkPhysicalDeviceProperties*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceProperties = OP_vkGetPhysicalDeviceProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_23;
    *&cgen_var_23 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_23, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties(sResourceTracker, (VkPhysicalDeviceProperties*)(pProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceProperties(this, physicalDevice, pProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_24;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                count_VkQueueFamilyProperties(sFeatureBits, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties = OP_vkGetPhysicalDeviceQueueFamilyProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_25;
    *&cgen_var_25 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_25, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_26 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_26, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_27 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    memcpy((*streamPtrPtr), &cgen_var_27, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            reservedmarshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties(sResourceTracker, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_30;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceMemoryProperties(sFeatureBits, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMemoryProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties = OP_vkGetPhysicalDeviceMemoryProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_31;
    *&cgen_var_31 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_31, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties(sResourceTracker, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceMemoryProperties(this, physicalDevice, pMemoryProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

PFN_vkVoidFunction VkEncoder::vkGetInstanceProcAddr(
    VkInstance instance,
    const char* pName,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    char* local_pName;
    local_instance = instance;
    // Avoiding deepcopy for pName
    local_pName = (char*)pName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_32;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t) + (local_pName ? strlen(local_pName) : 0);
    }
    uint32_t packetSize_vkGetInstanceProcAddr = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetInstanceProcAddr);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetInstanceProcAddr = OP_vkGetInstanceProcAddr;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetInstanceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetInstanceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_33;
    *&cgen_var_33 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_33, 1 * 8);
    *streamPtrPtr += 1 * 8;
    {
        uint32_t l = local_pName ? strlen(local_pName): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pName, l);
        *streamPtrPtr += l;
    }
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction VkEncoder::vkGetDeviceProcAddr(
    VkDevice device,
    const char* pName,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    char* local_pName;
    local_device = device;
    // Avoiding deepcopy for pName
    local_pName = (char*)pName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_34;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t) + (local_pName ? strlen(local_pName) : 0);
    }
    uint32_t packetSize_vkGetDeviceProcAddr = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceProcAddr);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceProcAddr = OP_vkGetDeviceProcAddr;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_35;
    *&cgen_var_35 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_35, 1 * 8);
    *streamPtrPtr += 1 * 8;
    {
        uint32_t l = local_pName ? strlen(local_pName): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pName, l);
        *streamPtrPtr += l;
    }
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

VkResult VkEncoder::vkCreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDeviceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDeviceCreateInfo*)pool->alloc(sizeof(const VkDeviceCreateInfo));
        deepcopy_VkDeviceCreateInfo(pool, pCreateInfo, (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDeviceCreateInfo(sResourceTracker, (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_36;
        *countPtr += 1 * 8;
        count_VkDeviceCreateInfo(sFeatureBits, (VkDeviceCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_37;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDevice = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDevice);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDevice = OP_vkCreateDevice;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_38;
    *&cgen_var_38 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_38, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceCreateInfo(stream, (VkDeviceCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_39 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_39, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_40;
    *&cgen_var_40 = (uint64_t)((*pDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_40, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_41;
    stream->read((uint64_t*)&cgen_var_41, 8);
    stream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_41, (VkDevice*)pDevice, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDevice_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateDevice(this, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDevice_VkResult_return;
}

void VkEncoder::vkDestroyDevice(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    sResourceTracker->on_vkDestroyDevice_pre(this, device, pAllocator);
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_42;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDevice = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDevice);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDevice = OP_vkDestroyDevice;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_43;
    *&cgen_var_43 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_43, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_44 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_44, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDevice((VkDevice*)&device);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    char* local_pLayerName;
    // Avoiding deepcopy for pLayerName
    local_pLayerName = (char*)pLayerName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        if (sFeatureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
        {
            // WARNING PTR CHECK
            *countPtr += 8;
            if (local_pLayerName)
            {
                *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
            }
        }
        else
        {
            *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkExtensionProperties(sFeatureBits, (VkExtensionProperties*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceExtensionProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateInstanceExtensionProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateInstanceExtensionProperties = OP_vkEnumerateInstanceExtensionProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    if (stream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_45 = (uint64_t)(uintptr_t)local_pLayerName;
        memcpy((*streamPtrPtr), &cgen_var_45, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
        if (local_pLayerName)
        {
            {
                uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
                memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
                *streamPtrPtr += sizeof(uint32_t);
                memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
                *streamPtrPtr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
            memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
            *streamPtrPtr += sizeof(uint32_t);
            memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
            *streamPtrPtr += l;
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_46 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_46, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_47 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_47, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkExtensionProperties(sResourceTracker, (VkExtensionProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    char* local_pLayerName;
    local_physicalDevice = physicalDevice;
    // Avoiding deepcopy for pLayerName
    local_pLayerName = (char*)pLayerName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_50;
        *countPtr += 1 * 8;
        if (sFeatureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
        {
            // WARNING PTR CHECK
            *countPtr += 8;
            if (local_pLayerName)
            {
                *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
            }
        }
        else
        {
            *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkExtensionProperties(sFeatureBits, (VkExtensionProperties*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceExtensionProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateDeviceExtensionProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateDeviceExtensionProperties = OP_vkEnumerateDeviceExtensionProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_51;
    *&cgen_var_51 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_51, 1 * 8);
    *streamPtrPtr += 1 * 8;
    if (stream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_52 = (uint64_t)(uintptr_t)local_pLayerName;
        memcpy((*streamPtrPtr), &cgen_var_52, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
        if (local_pLayerName)
        {
            {
                uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
                memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
                *streamPtrPtr += sizeof(uint32_t);
                memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
                *streamPtrPtr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
            memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
            *streamPtrPtr += sizeof(uint32_t);
            memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
            *streamPtrPtr += l;
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_53 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_53, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_54 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_54, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkExtensionProperties(sResourceTracker, (VkExtensionProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    size_t count = 0;
    size_t* countPtr = &count;
    {
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkLayerProperties(sFeatureBits, (VkLayerProperties*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceLayerProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateInstanceLayerProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateInstanceLayerProperties = OP_vkEnumerateInstanceLayerProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateInstanceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateInstanceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    // WARNING PTR CHECK
    uint64_t cgen_var_57 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_57, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_58 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_58, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkLayerProperties(sResourceTracker, (VkLayerProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_61;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkLayerProperties(sFeatureBits, (VkLayerProperties*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceLayerProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateDeviceLayerProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateDeviceLayerProperties = OP_vkEnumerateDeviceLayerProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateDeviceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateDeviceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_62;
    *&cgen_var_62 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_62, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_63 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_63, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_64 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_64, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkLayerProperties(sResourceTracker, (VkLayerProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}

void VkEncoder::vkGetDeviceQueue(
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_queueFamilyIndex;
    uint32_t local_queueIndex;
    local_device = device;
    local_queueFamilyIndex = queueFamilyIndex;
    local_queueIndex = queueIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_67;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_68;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetDeviceQueue = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceQueue);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceQueue = OP_vkGetDeviceQueue;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceQueue, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceQueue, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_69;
    *&cgen_var_69 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_69, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    /* is handle, possibly out */;
    uint64_t cgen_var_70;
    *&cgen_var_70 = (uint64_t)((*pQueue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_70, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_71;
    stream->read((uint64_t*)&cgen_var_71, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_71, (VkQueue*)pQueue, 1);
    stream->unsetHandleMapping();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkQueueSubmit(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_submitCount;
    VkSubmitInfo* local_pSubmits;
    VkFence local_fence;
    local_queue = queue;
    local_submitCount = submitCount;
    local_pSubmits = nullptr;
    if (pSubmits)
    {
        local_pSubmits = (VkSubmitInfo*)pool->alloc(((submitCount)) * sizeof(const VkSubmitInfo));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            deepcopy_VkSubmitInfo(pool, pSubmits + i, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    local_fence = fence;
    if (local_pSubmits)
    {
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            transform_tohost_VkSubmitInfo(sResourceTracker, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_72;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            count_VkSubmitInfo(sFeatureBits, (VkSubmitInfo*)(local_pSubmits + i), countPtr);
        }
        uint64_t cgen_var_73;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueSubmit = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSubmit);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSubmit = OP_vkQueueSubmit;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSubmit, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSubmit, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_74;
    *&cgen_var_74 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_74, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_submitCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        reservedmarshal_VkSubmitInfo(stream, (VkSubmitInfo*)(local_pSubmits + i), streamPtrPtr);
    }
    uint64_t cgen_var_75;
    *&cgen_var_75 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_75, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueSubmit_VkResult_return;
}

VkResult VkEncoder::vkQueueWaitIdle(
    VkQueue queue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_76;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueWaitIdle = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueWaitIdle);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueWaitIdle = OP_vkQueueWaitIdle;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_77;
    *&cgen_var_77 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_77, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkDeviceWaitIdle(
    VkDevice device,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    local_device = device;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_78;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkDeviceWaitIdle = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDeviceWaitIdle);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDeviceWaitIdle = OP_vkDeviceWaitIdle;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDeviceWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDeviceWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_79;
    *&cgen_var_79 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_79, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDeviceWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkAllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryAllocateInfo* local_pAllocateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkMemoryAllocateInfo*)pool->alloc(sizeof(const VkMemoryAllocateInfo));
        deepcopy_VkMemoryAllocateInfo(pool, pAllocateInfo, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocateInfo)
    {
        transform_tohost_VkMemoryAllocateInfo(sResourceTracker, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_80;
        *countPtr += 1 * 8;
        count_VkMemoryAllocateInfo(sFeatureBits, (VkMemoryAllocateInfo*)(local_pAllocateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_81;
        *countPtr += 8;
    }
    uint32_t packetSize_vkAllocateMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAllocateMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAllocateMemory = OP_vkAllocateMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAllocateMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAllocateMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_82;
    *&cgen_var_82 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_82, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryAllocateInfo(stream, (VkMemoryAllocateInfo*)(local_pAllocateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_83 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_83, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_84;
    *&cgen_var_84 = (uint64_t)((*pMemory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_84, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_85;
    stream->read((uint64_t*)&cgen_var_85, 8);
    stream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_85, (VkDeviceMemory*)pMemory, 1);
    stream->unsetHandleMapping();
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAllocateMemory_VkResult_return;
}

void VkEncoder::vkFreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_86;
        *countPtr += 1 * 8;
        uint64_t cgen_var_87;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkFreeMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeMemory = OP_vkFreeMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_88;
    *&cgen_var_88 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_88, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_89;
    *&cgen_var_89 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_89, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_90 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_90, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkMapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData,
    uint32_t doLock)
{
    (void)doLock;
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    vkMapMemory_VkResult_return = sResourceTracker->on_vkMapMemory(this, VK_SUCCESS, device, memory, offset, size, flags, ppData);
    return vkMapMemory_VkResult_return;
}

void VkEncoder::vkUnmapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    uint32_t doLock)
{
    (void)doLock;
    sResourceTracker->on_vkUnmapMemory(this, device, memory);
}

VkResult VkEncoder::vkFlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkFlushMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(sResourceTracker, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_91;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            count_VkMappedMemoryRange(sFeatureBits, (VkMappedMemoryRange*)(local_pMemoryRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkFlushMappedMemoryRanges = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFlushMappedMemoryRanges);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFlushMappedMemoryRanges = OP_vkFlushMappedMemoryRanges;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFlushMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFlushMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_92;
    *&cgen_var_92 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_92, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        reservedmarshal_VkMappedMemoryRange(stream, (VkMappedMemoryRange*)(local_pMemoryRanges + i), streamPtrPtr);
    }
    if (!sResourceTracker->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = sResourceTracker->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? sResourceTracker->getMappedSize(memory) : size;
            if (!hostPtr) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->write(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->write(targetRange, actualSize);
        }
    }
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult VkEncoder::vkInvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkInvalidateMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(sResourceTracker, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_93;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            count_VkMappedMemoryRange(sFeatureBits, (VkMappedMemoryRange*)(local_pMemoryRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkInvalidateMappedMemoryRanges = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkInvalidateMappedMemoryRanges);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkInvalidateMappedMemoryRanges = OP_vkInvalidateMappedMemoryRanges;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkInvalidateMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkInvalidateMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_94;
    *&cgen_var_94 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_94, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        reservedmarshal_VkMappedMemoryRange(stream, (VkMappedMemoryRange*)(local_pMemoryRanges + i), streamPtrPtr);
    }
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    if (!sResourceTracker->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = sResourceTracker->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? sResourceTracker->getMappedSize(memory) : size;
            if (!hostPtr) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->read(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->read(targetRange, actualSize);
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}

void VkEncoder::vkGetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_95;
        *countPtr += 1 * 8;
        uint64_t cgen_var_96;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkGetDeviceMemoryCommitment = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceMemoryCommitment);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceMemoryCommitment = OP_vkGetDeviceMemoryCommitment;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceMemoryCommitment, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceMemoryCommitment, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_97;
    *&cgen_var_97 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_97, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_98;
    *&cgen_var_98 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_98, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    stream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkBindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_buffer = buffer;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)&local_memoryOffset, 1, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_99;
        *countPtr += 1 * 8;
        uint64_t cgen_var_100;
        *countPtr += 1 * 8;
        uint64_t cgen_var_101;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkBindBufferMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindBufferMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindBufferMemory = OP_vkBindBufferMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindBufferMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindBufferMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_102;
    *&cgen_var_102 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_102, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_103;
    *&cgen_var_103 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_103, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_104;
    *&cgen_var_104 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_104, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindBufferMemory_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_image = image;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)&local_memoryOffset, 1, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_105;
        *countPtr += 1 * 8;
        uint64_t cgen_var_106;
        *countPtr += 1 * 8;
        uint64_t cgen_var_107;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkBindImageMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindImageMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindImageMemory = OP_vkBindImageMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindImageMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindImageMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_108;
    *&cgen_var_108 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_108, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_109;
    *&cgen_var_109 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_109, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_110;
    *&cgen_var_110 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_110, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindImageMemory_VkResult_return;
}

void VkEncoder::vkGetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    local_device = device;
    local_buffer = buffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_111;
        *countPtr += 1 * 8;
        uint64_t cgen_var_112;
        *countPtr += 1 * 8;
        count_VkMemoryRequirements(sFeatureBits, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferMemoryRequirements);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferMemoryRequirements = OP_vkGetBufferMemoryRequirements;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_113;
    *&cgen_var_113 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_113, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_114;
    *&cgen_var_114 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_114, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_115;
        *countPtr += 1 * 8;
        uint64_t cgen_var_116;
        *countPtr += 1 * 8;
        count_VkMemoryRequirements(sFeatureBits, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetImageMemoryRequirements = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageMemoryRequirements);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageMemoryRequirements = OP_vkGetImageMemoryRequirements;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_117;
    *&cgen_var_117 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_117, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_118;
    *&cgen_var_118 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_118, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_119;
        *countPtr += 1 * 8;
        uint64_t cgen_var_120;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirementCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                count_VkSparseImageMemoryRequirements(sFeatureBits, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSparseMemoryRequirements);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSparseMemoryRequirements = OP_vkGetImageSparseMemoryRequirements;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSparseMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSparseMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_121;
    *&cgen_var_121 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_121, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_122;
    *&cgen_var_122 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_122, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_123 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    memcpy((*streamPtrPtr), &cgen_var_123, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirementCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_124 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    memcpy((*streamPtrPtr), &cgen_var_124, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            reservedmarshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements(sResourceTracker, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkSampleCountFlagBits local_samples;
    VkImageUsageFlags local_usage;
    VkImageTiling local_tiling;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_samples = samples;
    local_usage = usage;
    local_tiling = tiling;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_127;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageType);
        *countPtr += sizeof(VkSampleCountFlagBits);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(VkImageTiling);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkSparseImageFormatProperties(sFeatureBits, (VkSparseImageFormatProperties*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSparseImageFormatProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties = OP_vkGetPhysicalDeviceSparseImageFormatProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_128;
    *&cgen_var_128 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_128, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageType*)&local_type, sizeof(VkImageType));
    *streamPtrPtr += sizeof(VkImageType);
    memcpy(*streamPtrPtr, (VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    *streamPtrPtr += sizeof(VkSampleCountFlagBits);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    *streamPtrPtr += sizeof(VkImageTiling);
    // WARNING PTR CHECK
    uint64_t cgen_var_129 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_129, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_130 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_130, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties(sResourceTracker, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkQueueBindSparse(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_bindInfoCount;
    VkBindSparseInfo* local_pBindInfo;
    VkFence local_fence;
    local_queue = queue;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfo = nullptr;
    if (pBindInfo)
    {
        local_pBindInfo = (VkBindSparseInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindSparseInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindSparseInfo(pool, pBindInfo + i, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    local_fence = fence;
    if (local_pBindInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindSparseInfo(sResourceTracker, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_133;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindSparseInfo(sFeatureBits, (VkBindSparseInfo*)(local_pBindInfo + i), countPtr);
        }
        uint64_t cgen_var_134;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueBindSparse = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueBindSparse);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueBindSparse = OP_vkQueueBindSparse;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueBindSparse, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueBindSparse, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_135;
    *&cgen_var_135 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_135, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindSparseInfo(stream, (VkBindSparseInfo*)(local_pBindInfo + i), streamPtrPtr);
    }
    uint64_t cgen_var_136;
    *&cgen_var_136 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_136, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    stream->read(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueBindSparse_VkResult_return;
}

VkResult VkEncoder::vkCreateFence(
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFenceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFenceCreateInfo*)pool->alloc(sizeof(const VkFenceCreateInfo));
        deepcopy_VkFenceCreateInfo(pool, pCreateInfo, (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFenceCreateInfo(sResourceTracker, (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_137;
        *countPtr += 1 * 8;
        count_VkFenceCreateInfo(sFeatureBits, (VkFenceCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_138;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateFence = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateFence);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateFence = OP_vkCreateFence;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_139;
    *&cgen_var_139 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_139, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFenceCreateInfo(stream, (VkFenceCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_140 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_140, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_141;
    *&cgen_var_141 = (uint64_t)((*pFence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_141, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_142;
    stream->read((uint64_t*)&cgen_var_142, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_142, (VkFence*)pFence, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFence_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateFence_VkResult_return;
}

void VkEncoder::vkDestroyFence(
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFence local_fence;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_fence = fence;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_143;
        *countPtr += 1 * 8;
        uint64_t cgen_var_144;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyFence = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyFence);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyFence = OP_vkDestroyFence;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_145;
    *&cgen_var_145 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_145, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_146;
    *&cgen_var_146 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_146, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_147 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_147, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkFence((VkFence*)&fence);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkResetFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    local_device = device;
    local_fenceCount = fenceCount;
    // Avoiding deepcopy for pFences
    local_pFences = (VkFence*)pFences;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_148;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((fenceCount)))
        {
            *countPtr += ((fenceCount)) * 8;
        }
    }
    uint32_t packetSize_vkResetFences = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetFences);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetFences = OP_vkResetFences;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_150;
    *&cgen_var_150 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_150, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_fenceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((fenceCount)))
    {
        uint8_t* cgen_var_151_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((fenceCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkFence(local_pFences[k]);
            memcpy(cgen_var_151_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((fenceCount));
    }
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    stream->read(&vkResetFences_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetFences_VkResult_return;
}

VkResult VkEncoder::vkGetFenceStatus(
    VkDevice device,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFence local_fence;
    local_device = device;
    local_fence = fence;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_152;
        *countPtr += 1 * 8;
        uint64_t cgen_var_153;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkGetFenceStatus = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetFenceStatus);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetFenceStatus = OP_vkGetFenceStatus;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetFenceStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetFenceStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_154;
    *&cgen_var_154 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_154, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_155;
    *&cgen_var_155 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_155, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetFenceStatus_VkResult_return;
}

VkResult VkEncoder::vkWaitForFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    VkBool32 local_waitAll;
    uint64_t local_timeout;
    local_device = device;
    local_fenceCount = fenceCount;
    // Avoiding deepcopy for pFences
    local_pFences = (VkFence*)pFences;
    local_waitAll = waitAll;
    local_timeout = timeout;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_156;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((fenceCount)))
        {
            *countPtr += ((fenceCount)) * 8;
        }
        *countPtr += sizeof(VkBool32);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkWaitForFences = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkWaitForFences);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkWaitForFences = OP_vkWaitForFences;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkWaitForFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkWaitForFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_158;
    *&cgen_var_158 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_158, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_fenceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((fenceCount)))
    {
        uint8_t* cgen_var_159_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((fenceCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkFence(local_pFences[k]);
            memcpy(cgen_var_159_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((fenceCount));
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_waitAll, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    memcpy(*streamPtrPtr, (uint64_t*)&local_timeout, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    stream->read(&vkWaitForFences_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkWaitForFences_VkResult_return;
}

VkResult VkEncoder::vkCreateSemaphore(
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSemaphoreCreateInfo*)pool->alloc(sizeof(const VkSemaphoreCreateInfo));
        deepcopy_VkSemaphoreCreateInfo(pool, pCreateInfo, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSemaphoreCreateInfo(sResourceTracker, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_160;
        *countPtr += 1 * 8;
        count_VkSemaphoreCreateInfo(sFeatureBits, (VkSemaphoreCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_161;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSemaphore = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSemaphore);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSemaphore = OP_vkCreateSemaphore;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_162;
    *&cgen_var_162 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_162, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreCreateInfo(stream, (VkSemaphoreCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_163 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_163, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_164;
    *&cgen_var_164 = (uint64_t)((*pSemaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_164, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_165;
    stream->read((uint64_t*)&cgen_var_165, 8);
    stream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_165, (VkSemaphore*)pSemaphore, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSemaphore_VkResult_return;
}

void VkEncoder::vkDestroySemaphore(
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphore local_semaphore;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_semaphore = semaphore;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_166;
        *countPtr += 1 * 8;
        uint64_t cgen_var_167;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySemaphore = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySemaphore);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySemaphore = OP_vkDestroySemaphore;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_168;
    *&cgen_var_168 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_168, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_169;
    *&cgen_var_169 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_169, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_170 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_170, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSemaphore((VkSemaphore*)&semaphore);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateEvent(
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEventCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkEventCreateInfo*)pool->alloc(sizeof(const VkEventCreateInfo));
        deepcopy_VkEventCreateInfo(pool, pCreateInfo, (VkEventCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkEventCreateInfo(sResourceTracker, (VkEventCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_171;
        *countPtr += 1 * 8;
        count_VkEventCreateInfo(sFeatureBits, (VkEventCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_172;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateEvent = OP_vkCreateEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_173;
    *&cgen_var_173 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_173, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkEventCreateInfo(stream, (VkEventCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_174 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_174, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_175;
    *&cgen_var_175 = (uint64_t)((*pEvent));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_175, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_176;
    stream->read((uint64_t*)&cgen_var_176, 8);
    stream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_176, (VkEvent*)pEvent, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    stream->read(&vkCreateEvent_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateEvent_VkResult_return;
}

void VkEncoder::vkDestroyEvent(
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_event = event;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_177;
        *countPtr += 1 * 8;
        uint64_t cgen_var_178;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyEvent = OP_vkDestroyEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_179;
    *&cgen_var_179 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_179, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_180;
    *&cgen_var_180 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_180, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_181 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_181, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkEvent((VkEvent*)&event);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetEventStatus(
    VkDevice device,
    VkEvent event,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_182;
        *countPtr += 1 * 8;
        uint64_t cgen_var_183;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkGetEventStatus = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetEventStatus);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetEventStatus = OP_vkGetEventStatus;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetEventStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetEventStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_184;
    *&cgen_var_184 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_184, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_185;
    *&cgen_var_185 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_185, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetEventStatus_VkResult_return;
}

VkResult VkEncoder::vkSetEvent(
    VkDevice device,
    VkEvent event,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_186;
        *countPtr += 1 * 8;
        uint64_t cgen_var_187;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkSetEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetEvent = OP_vkSetEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_188;
    *&cgen_var_188 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_188, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_189;
    *&cgen_var_189 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_189, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkSetEvent_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetEvent_VkResult_return;
}

VkResult VkEncoder::vkResetEvent(
    VkDevice device,
    VkEvent event,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_190;
        *countPtr += 1 * 8;
        uint64_t cgen_var_191;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkResetEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetEvent = OP_vkResetEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_192;
    *&cgen_var_192 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_192, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_193;
    *&cgen_var_193 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_193, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkResetEvent_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetEvent_VkResult_return;
}

VkResult VkEncoder::vkCreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkQueryPoolCreateInfo*)pool->alloc(sizeof(const VkQueryPoolCreateInfo));
        deepcopy_VkQueryPoolCreateInfo(pool, pCreateInfo, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkQueryPoolCreateInfo(sResourceTracker, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_194;
        *countPtr += 1 * 8;
        count_VkQueryPoolCreateInfo(sFeatureBits, (VkQueryPoolCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_195;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateQueryPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateQueryPool = OP_vkCreateQueryPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_196;
    *&cgen_var_196 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_196, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkQueryPoolCreateInfo(stream, (VkQueryPoolCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_197 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_197, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_198;
    *&cgen_var_198 = (uint64_t)((*pQueryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_198, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_199;
    stream->read((uint64_t*)&cgen_var_199, 8);
    stream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_199, (VkQueryPool*)pQueryPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateQueryPool_VkResult_return;
}

void VkEncoder::vkDestroyQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPool local_queryPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_queryPool = queryPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_200;
        *countPtr += 1 * 8;
        uint64_t cgen_var_201;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyQueryPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyQueryPool = OP_vkDestroyQueryPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_202;
    *&cgen_var_202 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_202, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_203;
    *&cgen_var_203 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_203, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_204 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_204, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkQueryPool((VkQueryPool*)&queryPool);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetQueryPoolResults(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    size_t local_dataSize;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_device = device;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dataSize = dataSize;
    local_stride = stride;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_205;
        *countPtr += 1 * 8;
        uint64_t cgen_var_206;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkQueryResultFlags);
    }
    uint32_t packetSize_vkGetQueryPoolResults = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetQueryPoolResults);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetQueryPoolResults = OP_vkGetQueryPoolResults;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_207;
    *&cgen_var_207 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_207, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_208;
    *&cgen_var_208 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_208, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_209 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_209, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    *streamPtrPtr += sizeof(VkQueryResultFlags);
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    stream->read(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetQueryPoolResults_VkResult_return;
}

VkResult VkEncoder::vkCreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(sResourceTracker, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_210;
        *countPtr += 1 * 8;
        count_VkBufferCreateInfo(sFeatureBits, (VkBufferCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_211;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateBuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateBuffer = OP_vkCreateBuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_212;
    *&cgen_var_212 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_212, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferCreateInfo(stream, (VkBufferCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_213 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_213, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_214;
    *&cgen_var_214 = (uint64_t)((*pBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_214, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_215;
    stream->read((uint64_t*)&cgen_var_215, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_215, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateBuffer_VkResult_return;
}

void VkEncoder::vkDestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_buffer = buffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_216;
        *countPtr += 1 * 8;
        uint64_t cgen_var_217;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyBuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyBuffer = OP_vkDestroyBuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_218;
    *&cgen_var_218 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_218, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_219;
    *&cgen_var_219 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_219, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_220 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_220, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkBuffer((VkBuffer*)&buffer);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferViewCreateInfo*)pool->alloc(sizeof(const VkBufferViewCreateInfo));
        deepcopy_VkBufferViewCreateInfo(pool, pCreateInfo, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferViewCreateInfo(sResourceTracker, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_221;
        *countPtr += 1 * 8;
        count_VkBufferViewCreateInfo(sFeatureBits, (VkBufferViewCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_222;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateBufferView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateBufferView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateBufferView = OP_vkCreateBufferView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_223;
    *&cgen_var_223 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_223, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferViewCreateInfo(stream, (VkBufferViewCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_224 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_224, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_225;
    *&cgen_var_225 = (uint64_t)((*pView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_225, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_226;
    stream->read((uint64_t*)&cgen_var_226, 8);
    stream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_226, (VkBufferView*)pView, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateBufferView_VkResult_return;
}

void VkEncoder::vkDestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferView local_bufferView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_bufferView = bufferView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_227;
        *countPtr += 1 * 8;
        uint64_t cgen_var_228;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyBufferView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyBufferView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyBufferView = OP_vkDestroyBufferView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_229;
    *&cgen_var_229 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_229, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_230;
    *&cgen_var_230 = get_host_u64_VkBufferView((*&local_bufferView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_230, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_231 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_231, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkBufferView((VkBufferView*)&bufferView);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    sResourceTracker->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(sResourceTracker, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_232;
        *countPtr += 1 * 8;
        count_VkImageCreateInfo(sFeatureBits, (VkImageCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_233;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateImage = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImage = OP_vkCreateImage;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_234;
    *&cgen_var_234 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_234, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageCreateInfo(stream, (VkImageCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_235 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_235, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_236;
    *&cgen_var_236 = (uint64_t)((*pImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_236, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_237;
    stream->read((uint64_t*)&cgen_var_237, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_237, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImage_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImage_VkResult_return;
}

void VkEncoder::vkDestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_image = image;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_238;
        *countPtr += 1 * 8;
        uint64_t cgen_var_239;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyImage = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyImage = OP_vkDestroyImage;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_240;
    *&cgen_var_240 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_240, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_241;
    *&cgen_var_241 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_241, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_242 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_242, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkImage((VkImage*)&image);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    VkImageSubresource* local_pSubresource;
    local_device = device;
    local_image = image;
    local_pSubresource = nullptr;
    if (pSubresource)
    {
        local_pSubresource = (VkImageSubresource*)pool->alloc(sizeof(const VkImageSubresource));
        deepcopy_VkImageSubresource(pool, pSubresource, (VkImageSubresource*)(local_pSubresource));
    }
    if (local_pSubresource)
    {
        transform_tohost_VkImageSubresource(sResourceTracker, (VkImageSubresource*)(local_pSubresource));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_243;
        *countPtr += 1 * 8;
        uint64_t cgen_var_244;
        *countPtr += 1 * 8;
        count_VkImageSubresource(sFeatureBits, (VkImageSubresource*)(local_pSubresource), countPtr);
        count_VkSubresourceLayout(sFeatureBits, (VkSubresourceLayout*)(pLayout), countPtr);
    }
    uint32_t packetSize_vkGetImageSubresourceLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSubresourceLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSubresourceLayout = OP_vkGetImageSubresourceLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSubresourceLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSubresourceLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_245;
    *&cgen_var_245 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_245, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_246;
    *&cgen_var_246 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_246, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageSubresource(stream, (VkImageSubresource*)(local_pSubresource), streamPtrPtr);
    reservedmarshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout), streamPtrPtr);
    unmarshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
    if (pLayout)
    {
        transform_fromhost_VkSubresourceLayout(sResourceTracker, (VkSubresourceLayout*)(pLayout));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageViewCreateInfo*)pool->alloc(sizeof(const VkImageViewCreateInfo));
        deepcopy_VkImageViewCreateInfo(pool, pCreateInfo, (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageViewCreateInfo(sResourceTracker, (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_247;
        *countPtr += 1 * 8;
        count_VkImageViewCreateInfo(sFeatureBits, (VkImageViewCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_248;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateImageView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImageView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImageView = OP_vkCreateImageView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_249;
    *&cgen_var_249 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_249, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageViewCreateInfo(stream, (VkImageViewCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_250 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_250, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_251;
    *&cgen_var_251 = (uint64_t)((*pView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_251, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_252;
    stream->read((uint64_t*)&cgen_var_252, 8);
    stream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_252, (VkImageView*)pView, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageView_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImageView_VkResult_return;
}

void VkEncoder::vkDestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageView local_imageView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_imageView = imageView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_253;
        *countPtr += 1 * 8;
        uint64_t cgen_var_254;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyImageView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyImageView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyImageView = OP_vkDestroyImageView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_255;
    *&cgen_var_255 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_255, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_256;
    *&cgen_var_256 = get_host_u64_VkImageView((*&local_imageView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_256, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_257 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_257, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkImageView((VkImageView*)&imageView);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateShaderModule(
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkShaderModuleCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkShaderModuleCreateInfo*)pool->alloc(sizeof(const VkShaderModuleCreateInfo));
        deepcopy_VkShaderModuleCreateInfo(pool, pCreateInfo, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkShaderModuleCreateInfo(sResourceTracker, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_258;
        *countPtr += 1 * 8;
        count_VkShaderModuleCreateInfo(sFeatureBits, (VkShaderModuleCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_259;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateShaderModule = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateShaderModule);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateShaderModule = OP_vkCreateShaderModule;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_260;
    *&cgen_var_260 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_260, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkShaderModuleCreateInfo(stream, (VkShaderModuleCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_261 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_261, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_262;
    *&cgen_var_262 = (uint64_t)((*pShaderModule));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_262, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_263;
    stream->read((uint64_t*)&cgen_var_263, 8);
    stream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_263, (VkShaderModule*)pShaderModule, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    stream->read(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateShaderModule_VkResult_return;
}

void VkEncoder::vkDestroyShaderModule(
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkShaderModule local_shaderModule;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_shaderModule = shaderModule;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_264;
        *countPtr += 1 * 8;
        uint64_t cgen_var_265;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyShaderModule = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyShaderModule);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyShaderModule = OP_vkDestroyShaderModule;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_266;
    *&cgen_var_266 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_266, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_267;
    *&cgen_var_267 = get_host_u64_VkShaderModule((*&local_shaderModule));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_267, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_268 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_268, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkShaderModule((VkShaderModule*)&shaderModule);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreatePipelineCache(
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCacheCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineCacheCreateInfo*)pool->alloc(sizeof(const VkPipelineCacheCreateInfo));
        deepcopy_VkPipelineCacheCreateInfo(pool, pCreateInfo, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineCacheCreateInfo(sResourceTracker, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_269;
        *countPtr += 1 * 8;
        count_VkPipelineCacheCreateInfo(sFeatureBits, (VkPipelineCacheCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_270;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreatePipelineCache = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreatePipelineCache);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreatePipelineCache = OP_vkCreatePipelineCache;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreatePipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreatePipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_271;
    *&cgen_var_271 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_271, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineCacheCreateInfo(stream, (VkPipelineCacheCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_272 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_272, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_273;
    *&cgen_var_273 = (uint64_t)((*pPipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_273, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_274;
    stream->read((uint64_t*)&cgen_var_274, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_274, (VkPipelineCache*)pPipelineCache, 1);
    stream->unsetHandleMapping();
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreatePipelineCache_VkResult_return;
}

void VkEncoder::vkDestroyPipelineCache(
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_275;
        *countPtr += 1 * 8;
        uint64_t cgen_var_276;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPipelineCache = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPipelineCache);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPipelineCache = OP_vkDestroyPipelineCache;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_277;
    *&cgen_var_277 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_277, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_278;
    *&cgen_var_278 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_278, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_279 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_279, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)&pipelineCache);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPipelineCacheData(
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    local_device = device;
    local_pipelineCache = pipelineCache;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_280;
        *countPtr += 1 * 8;
        uint64_t cgen_var_281;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDataSize)
        {
            *countPtr += 8;
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pData)
        {
            *countPtr += (*(pDataSize)) * sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkGetPipelineCacheData = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPipelineCacheData);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPipelineCacheData = OP_vkGetPipelineCacheData;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPipelineCacheData, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPipelineCacheData, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_282;
    *&cgen_var_282 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_282, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_283;
    *&cgen_var_283 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_283, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_284 = (uint64_t)(uintptr_t)pDataSize;
    memcpy((*streamPtrPtr), &cgen_var_284, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDataSize)
    {
        uint64_t cgen_var_285 = (uint64_t)(*pDataSize);
        memcpy((*streamPtrPtr), &cgen_var_285, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_286 = (uint64_t)(uintptr_t)pData;
    memcpy((*streamPtrPtr), &cgen_var_286, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pData)
    {
        memcpy(*streamPtrPtr, (void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        *streamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
    }
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPipelineCacheData_VkResult_return;
}

VkResult VkEncoder::vkMergePipelineCaches(
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_dstCache;
    uint32_t local_srcCacheCount;
    VkPipelineCache* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    // Avoiding deepcopy for pSrcCaches
    local_pSrcCaches = (VkPipelineCache*)pSrcCaches;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_290;
        *countPtr += 1 * 8;
        uint64_t cgen_var_291;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((srcCacheCount)))
        {
            *countPtr += ((srcCacheCount)) * 8;
        }
    }
    uint32_t packetSize_vkMergePipelineCaches = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkMergePipelineCaches);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkMergePipelineCaches = OP_vkMergePipelineCaches;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkMergePipelineCaches, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkMergePipelineCaches, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_293;
    *&cgen_var_293 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_293, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_294;
    *&cgen_var_294 = get_host_u64_VkPipelineCache((*&local_dstCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_294, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((srcCacheCount)))
    {
        uint8_t* cgen_var_295_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkPipelineCache(local_pSrcCaches[k]);
            memcpy(cgen_var_295_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((srcCacheCount));
    }
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    stream->read(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkMergePipelineCaches_VkResult_return;
}

VkResult VkEncoder::vkCreateGraphicsPipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkGraphicsPipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkGraphicsPipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkGraphicsPipelineCreateInfo(pool, pCreateInfos + i, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkGraphicsPipelineCreateInfo(sResourceTracker, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_296;
        *countPtr += 1 * 8;
        uint64_t cgen_var_297;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            count_VkGraphicsPipelineCreateInfo(sFeatureBits, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((createInfoCount)))
        {
            *countPtr += ((createInfoCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateGraphicsPipelines = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateGraphicsPipelines);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateGraphicsPipelines = OP_vkCreateGraphicsPipelines;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateGraphicsPipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateGraphicsPipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_299;
    *&cgen_var_299 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_299, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_300;
    *&cgen_var_300 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_300, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        reservedmarshal_VkGraphicsPipelineCreateInfo(stream, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_301 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_301, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint8_t* cgen_var_302_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((createInfoCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pPipelines[k]);
            memcpy(cgen_var_302_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((createInfoCount));
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_303;
        stream->alloc((void**)&cgen_var_303, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_303, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_303, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateGraphicsPipelines_VkResult_return;
}

VkResult VkEncoder::vkCreateComputePipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkComputePipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkComputePipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkComputePipelineCreateInfo(pool, pCreateInfos + i, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkComputePipelineCreateInfo(sResourceTracker, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_304;
        *countPtr += 1 * 8;
        uint64_t cgen_var_305;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            count_VkComputePipelineCreateInfo(sFeatureBits, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((createInfoCount)))
        {
            *countPtr += ((createInfoCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateComputePipelines = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateComputePipelines);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateComputePipelines = OP_vkCreateComputePipelines;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateComputePipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateComputePipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_307;
    *&cgen_var_307 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_307, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_308;
    *&cgen_var_308 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_308, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        reservedmarshal_VkComputePipelineCreateInfo(stream, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_309 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_309, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint8_t* cgen_var_310_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((createInfoCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pPipelines[k]);
            memcpy(cgen_var_310_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((createInfoCount));
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_311;
        stream->alloc((void**)&cgen_var_311, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_311, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_311, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateComputePipelines_VkResult_return;
}

void VkEncoder::vkDestroyPipeline(
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipeline = pipeline;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_312;
        *countPtr += 1 * 8;
        uint64_t cgen_var_313;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPipeline = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPipeline);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPipeline = OP_vkDestroyPipeline;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_314;
    *&cgen_var_314 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_314, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_315;
    *&cgen_var_315 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_315, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_316 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_316, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkPipeline((VkPipeline*)&pipeline);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreatePipelineLayout(
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineLayoutCreateInfo*)pool->alloc(sizeof(const VkPipelineLayoutCreateInfo));
        deepcopy_VkPipelineLayoutCreateInfo(pool, pCreateInfo, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineLayoutCreateInfo(sResourceTracker, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_317;
        *countPtr += 1 * 8;
        count_VkPipelineLayoutCreateInfo(sFeatureBits, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_318;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreatePipelineLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreatePipelineLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreatePipelineLayout = OP_vkCreatePipelineLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreatePipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreatePipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_319;
    *&cgen_var_319 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_319, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineLayoutCreateInfo(stream, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_320 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_320, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_321;
    *&cgen_var_321 = (uint64_t)((*pPipelineLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_321, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_322;
    stream->read((uint64_t*)&cgen_var_322, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_322, (VkPipelineLayout*)pPipelineLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreatePipelineLayout_VkResult_return;
}

void VkEncoder::vkDestroyPipelineLayout(
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineLayout local_pipelineLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineLayout = pipelineLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_323;
        *countPtr += 1 * 8;
        uint64_t cgen_var_324;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPipelineLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPipelineLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPipelineLayout = OP_vkDestroyPipelineLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_325;
    *&cgen_var_325 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_325, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_326;
    *&cgen_var_326 = get_host_u64_VkPipelineLayout((*&local_pipelineLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_326, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_327 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_327, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)&pipelineLayout);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerCreateInfo*)pool->alloc(sizeof(const VkSamplerCreateInfo));
        deepcopy_VkSamplerCreateInfo(pool, pCreateInfo, (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerCreateInfo(sResourceTracker, (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_328;
        *countPtr += 1 * 8;
        count_VkSamplerCreateInfo(sFeatureBits, (VkSamplerCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_329;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSampler = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSampler);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSampler = OP_vkCreateSampler;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_330;
    *&cgen_var_330 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_330, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSamplerCreateInfo(stream, (VkSamplerCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_331 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_331, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_332;
    *&cgen_var_332 = (uint64_t)((*pSampler));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_332, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_333;
    stream->read((uint64_t*)&cgen_var_333, 8);
    stream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_333, (VkSampler*)pSampler, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSampler_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSampler_VkResult_return;
}

void VkEncoder::vkDestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSampler local_sampler;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_sampler = sampler;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_334;
        *countPtr += 1 * 8;
        uint64_t cgen_var_335;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySampler = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySampler);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySampler = OP_vkDestroySampler;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_336;
    *&cgen_var_336 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_336, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_337;
    *&cgen_var_337 = get_host_u64_VkSampler((*&local_sampler));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_337, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_338 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_338, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSampler((VkSampler*)&sampler);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDescriptorSetLayout(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(sResourceTracker, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_339;
        *countPtr += 1 * 8;
        count_VkDescriptorSetLayoutCreateInfo(sFeatureBits, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_340;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorSetLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorSetLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorSetLayout = OP_vkCreateDescriptorSetLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_341;
    *&cgen_var_341 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_341, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_342 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_342, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_343;
    *&cgen_var_343 = (uint64_t)((*pSetLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_343, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_344;
    stream->read((uint64_t*)&cgen_var_344, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_344, (VkDescriptorSetLayout*)pSetLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorSetLayout_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorSetLayout(
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayout local_descriptorSetLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorSetLayout = descriptorSetLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_345;
        *countPtr += 1 * 8;
        uint64_t cgen_var_346;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorSetLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorSetLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorSetLayout = OP_vkDestroyDescriptorSetLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_347;
    *&cgen_var_347 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_347, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_348;
    *&cgen_var_348 = get_host_u64_VkDescriptorSetLayout((*&local_descriptorSetLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_348, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_349 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_349, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)&descriptorSetLayout);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDescriptorPool(
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorPoolCreateInfo*)pool->alloc(sizeof(const VkDescriptorPoolCreateInfo));
        deepcopy_VkDescriptorPoolCreateInfo(pool, pCreateInfo, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorPoolCreateInfo(sResourceTracker, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_350;
        *countPtr += 1 * 8;
        count_VkDescriptorPoolCreateInfo(sFeatureBits, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_351;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorPool = OP_vkCreateDescriptorPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_352;
    *&cgen_var_352 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_352, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorPoolCreateInfo(stream, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_353 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_353, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_354;
    *&cgen_var_354 = (uint64_t)((*pDescriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_354, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_355;
    stream->read((uint64_t*)&cgen_var_355, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_355, (VkDescriptorPool*)pDescriptorPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorPool_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_356;
        *countPtr += 1 * 8;
        uint64_t cgen_var_357;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorPool = OP_vkDestroyDescriptorPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_358;
    *&cgen_var_358 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_358, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_359;
    *&cgen_var_359 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_359, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_360 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_360, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)&descriptorPool);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkResetDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkDescriptorPoolResetFlags local_flags;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_361;
        *countPtr += 1 * 8;
        uint64_t cgen_var_362;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDescriptorPoolResetFlags);
    }
    uint32_t packetSize_vkResetDescriptorPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetDescriptorPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetDescriptorPool = OP_vkResetDescriptorPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_363;
    *&cgen_var_363 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_363, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_364;
    *&cgen_var_364 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_364, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDescriptorPoolResetFlags*)&local_flags, sizeof(VkDescriptorPoolResetFlags));
    *streamPtrPtr += sizeof(VkDescriptorPoolResetFlags);
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetDescriptorPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateDescriptorSets(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkDescriptorSetAllocateInfo*)pool->alloc(sizeof(const VkDescriptorSetAllocateInfo));
        deepcopy_VkDescriptorSetAllocateInfo(pool, pAllocateInfo, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkDescriptorSetAllocateInfo(sResourceTracker, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_365;
        *countPtr += 1 * 8;
        count_VkDescriptorSetAllocateInfo(sFeatureBits, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo), countPtr);
        if (pAllocateInfo->descriptorSetCount)
        {
            *countPtr += pAllocateInfo->descriptorSetCount * 8;
        }
    }
    uint32_t packetSize_vkAllocateDescriptorSets = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAllocateDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAllocateDescriptorSets = OP_vkAllocateDescriptorSets;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAllocateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAllocateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_367;
    *&cgen_var_367 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_367, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetAllocateInfo(stream, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo), streamPtrPtr);
    /* is handle, possibly out */;
    if (pAllocateInfo->descriptorSetCount)
    {
        uint8_t* cgen_var_368_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < pAllocateInfo->descriptorSetCount; ++k)
        {
            uint64_t tmpval = (uint64_t)(pDescriptorSets[k]);
            memcpy(cgen_var_368_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * pAllocateInfo->descriptorSetCount;
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (pAllocateInfo->descriptorSetCount)
    {
        uint64_t* cgen_var_369;
        stream->alloc((void**)&cgen_var_369, pAllocateInfo->descriptorSetCount * 8);
        stream->read((uint64_t*)cgen_var_369, pAllocateInfo->descriptorSetCount * 8);
        stream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_369, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
    }
    stream->unsetHandleMapping();
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAllocateDescriptorSets_VkResult_return;
}

VkResult VkEncoder::vkFreeDescriptorSets(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_descriptorSetCount = descriptorSetCount;
    // Avoiding deepcopy for pDescriptorSets
    local_pDescriptorSets = (VkDescriptorSet*)pDescriptorSets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_370;
        *countPtr += 1 * 8;
        uint64_t cgen_var_371;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pDescriptorSets)
        {
            if (((descriptorSetCount)))
            {
                *countPtr += ((descriptorSetCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkFreeDescriptorSets = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeDescriptorSets = OP_vkFreeDescriptorSets;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_373;
    *&cgen_var_373 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_373, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_374;
    *&cgen_var_374 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_374, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_375 = (uint64_t)(uintptr_t)local_pDescriptorSets;
    memcpy((*streamPtrPtr), &cgen_var_375, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pDescriptorSets)
    {
        if (((descriptorSetCount)))
        {
            uint8_t* cgen_var_376_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkDescriptorSet(local_pDescriptorSets[k]);
                memcpy(cgen_var_376_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((descriptorSetCount));
        }
    }
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    if (pDescriptorSets)
    {
        sResourceTracker->destroyMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkFreeDescriptorSets_VkResult_return;
}

void VkEncoder::vkUpdateDescriptorSets(
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    uint32_t local_descriptorCopyCount;
    VkCopyDescriptorSet* local_pDescriptorCopies;
    local_device = device;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    local_descriptorCopyCount = descriptorCopyCount;
    local_pDescriptorCopies = nullptr;
    if (pDescriptorCopies)
    {
        local_pDescriptorCopies = (VkCopyDescriptorSet*)pool->alloc(((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            deepcopy_VkCopyDescriptorSet(pool, pDescriptorCopies + i, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(sResourceTracker, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorCopies)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            transform_tohost_VkCopyDescriptorSet(sResourceTracker, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_377;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            count_VkWriteDescriptorSet(sFeatureBits, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            count_VkCopyDescriptorSet(sFeatureBits, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i), countPtr);
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSets = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSets = OP_vkUpdateDescriptorSets;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_378;
    *&cgen_var_378 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_378, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        reservedmarshal_VkWriteDescriptorSet(stream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorCopyCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        reservedmarshal_VkCopyDescriptorSet(stream, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateFramebuffer(
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFramebufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFramebufferCreateInfo*)pool->alloc(sizeof(const VkFramebufferCreateInfo));
        deepcopy_VkFramebufferCreateInfo(pool, pCreateInfo, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFramebufferCreateInfo(sResourceTracker, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_379;
        *countPtr += 1 * 8;
        count_VkFramebufferCreateInfo(sFeatureBits, (VkFramebufferCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_380;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateFramebuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateFramebuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateFramebuffer = OP_vkCreateFramebuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_381;
    *&cgen_var_381 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_381, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFramebufferCreateInfo(stream, (VkFramebufferCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_382 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_382, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_383;
    *&cgen_var_383 = (uint64_t)((*pFramebuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_383, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_384;
    stream->read((uint64_t*)&cgen_var_384, 8);
    stream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_384, (VkFramebuffer*)pFramebuffer, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateFramebuffer_VkResult_return;
}

void VkEncoder::vkDestroyFramebuffer(
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFramebuffer local_framebuffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_framebuffer = framebuffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_385;
        *countPtr += 1 * 8;
        uint64_t cgen_var_386;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyFramebuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyFramebuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyFramebuffer = OP_vkDestroyFramebuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_387;
    *&cgen_var_387 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_387, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_388;
    *&cgen_var_388 = get_host_u64_VkFramebuffer((*&local_framebuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_388, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_389 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_389, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)&framebuffer);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateRenderPass(
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPassCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo*)pool->alloc(sizeof(const VkRenderPassCreateInfo));
        deepcopy_VkRenderPassCreateInfo(pool, pCreateInfo, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo(sResourceTracker, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_390;
        *countPtr += 1 * 8;
        count_VkRenderPassCreateInfo(sFeatureBits, (VkRenderPassCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_391;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateRenderPass = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRenderPass = OP_vkCreateRenderPass;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_392;
    *&cgen_var_392 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_392, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRenderPassCreateInfo(stream, (VkRenderPassCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_393 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_393, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_394;
    *&cgen_var_394 = (uint64_t)((*pRenderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_394, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_395;
    stream->read((uint64_t*)&cgen_var_395, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_395, (VkRenderPass*)pRenderPass, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRenderPass_VkResult_return;
}

void VkEncoder::vkDestroyRenderPass(
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPass local_renderPass;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_renderPass = renderPass;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_396;
        *countPtr += 1 * 8;
        uint64_t cgen_var_397;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyRenderPass = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyRenderPass = OP_vkDestroyRenderPass;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_398;
    *&cgen_var_398 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_398, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_399;
    *&cgen_var_399 = get_host_u64_VkRenderPass((*&local_renderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_399, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_400 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_400, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkRenderPass((VkRenderPass*)&renderPass);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetRenderAreaGranularity(
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPass local_renderPass;
    local_device = device;
    local_renderPass = renderPass;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_401;
        *countPtr += 1 * 8;
        uint64_t cgen_var_402;
        *countPtr += 1 * 8;
        count_VkExtent2D(sFeatureBits, (VkExtent2D*)(pGranularity), countPtr);
    }
    uint32_t packetSize_vkGetRenderAreaGranularity = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRenderAreaGranularity);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRenderAreaGranularity = OP_vkGetRenderAreaGranularity;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRenderAreaGranularity, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRenderAreaGranularity, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_403;
    *&cgen_var_403 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_403, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_404;
    *&cgen_var_404 = get_host_u64_VkRenderPass((*&local_renderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_404, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity), streamPtrPtr);
    unmarshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
    if (pGranularity)
    {
        transform_fromhost_VkExtent2D(sResourceTracker, (VkExtent2D*)(pGranularity));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateCommandPool(
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkCommandPoolCreateInfo*)pool->alloc(sizeof(const VkCommandPoolCreateInfo));
        deepcopy_VkCommandPoolCreateInfo(pool, pCreateInfo, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkCommandPoolCreateInfo(sResourceTracker, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_405;
        *countPtr += 1 * 8;
        count_VkCommandPoolCreateInfo(sFeatureBits, (VkCommandPoolCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_406;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateCommandPool = OP_vkCreateCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_407;
    *&cgen_var_407 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_407, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkCommandPoolCreateInfo(stream, (VkCommandPoolCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_408 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_408, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_409;
    *&cgen_var_409 = (uint64_t)((*pCommandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_409, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_410;
    stream->read((uint64_t*)&cgen_var_410, 8);
    stream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_410, (VkCommandPool*)pCommandPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateCommandPool_VkResult_return;
}

void VkEncoder::vkDestroyCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_commandPool = commandPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_411;
        *countPtr += 1 * 8;
        uint64_t cgen_var_412;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyCommandPool = OP_vkDestroyCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_413;
    *&cgen_var_413 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_413, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_414;
    *&cgen_var_414 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_414, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_415 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_415, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkCommandPool((VkCommandPool*)&commandPool);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkResetCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolResetFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_416;
        *countPtr += 1 * 8;
        uint64_t cgen_var_417;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandPoolResetFlags);
    }
    uint32_t packetSize_vkResetCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetCommandPool = OP_vkResetCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_418;
    *&cgen_var_418 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_418, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_419;
    *&cgen_var_419 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_419, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCommandPoolResetFlags*)&local_flags, sizeof(VkCommandPoolResetFlags));
    *streamPtrPtr += sizeof(VkCommandPoolResetFlags);
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetCommandPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateCommandBuffers(
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandBufferAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkCommandBufferAllocateInfo*)pool->alloc(sizeof(const VkCommandBufferAllocateInfo));
        deepcopy_VkCommandBufferAllocateInfo(pool, pAllocateInfo, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkCommandBufferAllocateInfo(sResourceTracker, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_420;
        *countPtr += 1 * 8;
        count_VkCommandBufferAllocateInfo(sFeatureBits, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo), countPtr);
        if (pAllocateInfo->commandBufferCount)
        {
            *countPtr += pAllocateInfo->commandBufferCount * 8;
        }
    }
    uint32_t packetSize_vkAllocateCommandBuffers = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAllocateCommandBuffers);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAllocateCommandBuffers = OP_vkAllocateCommandBuffers;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAllocateCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAllocateCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_422;
    *&cgen_var_422 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_422, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkCommandBufferAllocateInfo(stream, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo), streamPtrPtr);
    /* is handle, possibly out */;
    if (pAllocateInfo->commandBufferCount)
    {
        uint8_t* cgen_var_423_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < pAllocateInfo->commandBufferCount; ++k)
        {
            uint64_t tmpval = (uint64_t)(pCommandBuffers[k]);
            memcpy(cgen_var_423_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * pAllocateInfo->commandBufferCount;
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (pAllocateInfo->commandBufferCount)
    {
        uint64_t* cgen_var_424;
        stream->alloc((void**)&cgen_var_424, pAllocateInfo->commandBufferCount * 8);
        stream->read((uint64_t*)cgen_var_424, pAllocateInfo->commandBufferCount * 8);
        stream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_424, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
    }
    stream->unsetHandleMapping();
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAllocateCommandBuffers_VkResult_return;
}

void VkEncoder::vkFreeCommandBuffers(
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_device = device;
    local_commandPool = commandPool;
    local_commandBufferCount = commandBufferCount;
    // Avoiding deepcopy for pCommandBuffers
    local_pCommandBuffers = (VkCommandBuffer*)pCommandBuffers;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_425;
        *countPtr += 1 * 8;
        uint64_t cgen_var_426;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCommandBuffers)
        {
            if (((commandBufferCount)))
            {
                *countPtr += ((commandBufferCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkFreeCommandBuffers = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeCommandBuffers);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeCommandBuffers = OP_vkFreeCommandBuffers;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_428;
    *&cgen_var_428 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_428, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_429;
    *&cgen_var_429 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_429, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_430 = (uint64_t)(uintptr_t)local_pCommandBuffers;
    memcpy((*streamPtrPtr), &cgen_var_430, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCommandBuffers)
    {
        if (((commandBufferCount)))
        {
            uint8_t* cgen_var_431_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkCommandBuffer(local_pCommandBuffers[k]);
                memcpy(cgen_var_431_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((commandBufferCount));
        }
    }
    if (pCommandBuffers)
    {
        sResourceTracker->destroyMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(sResourceTracker, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_432;
        *countPtr += 1 * 8;
        count_VkCommandBufferBeginInfo(sFeatureBits, (VkCommandBufferBeginInfo*)(local_pBeginInfo), countPtr);
    }
    uint32_t packetSize_vkBeginCommandBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkBeginCommandBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBeginCommandBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBeginCommandBuffer = OP_vkBeginCommandBuffer;
    memcpy(streamPtr, &opcode_vkBeginCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBeginCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_433;
        *&cgen_var_433 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_433, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCommandBufferBeginInfo(stream, (VkCommandBufferBeginInfo*)(local_pBeginInfo), streamPtrPtr);
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBeginCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkEndCommandBuffer(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_434;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkEndCommandBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkEndCommandBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEndCommandBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEndCommandBuffer = OP_vkEndCommandBuffer;
    memcpy(streamPtr, &opcode_vkEndCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEndCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_435;
        *&cgen_var_435 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_435, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEndCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_436;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandBufferResetFlags);
    }
    uint32_t packetSize_vkResetCommandBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkResetCommandBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetCommandBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetCommandBuffer = OP_vkResetCommandBuffer;
    memcpy(streamPtr, &opcode_vkResetCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_437;
        *&cgen_var_437 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_437, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    *streamPtrPtr += sizeof(VkCommandBufferResetFlags);
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetCommandBuffer_VkResult_return;
}

void VkEncoder::vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipeline local_pipeline;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_pipeline = pipeline;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_438;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_439;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdBindPipeline = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindPipeline -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindPipeline);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindPipeline = OP_vkCmdBindPipeline;
    memcpy(streamPtr, &opcode_vkCmdBindPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_440;
        *&cgen_var_440 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_440, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_441;
    *&cgen_var_441 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_441, 1 * 8);
    *streamPtrPtr += 1 * 8;
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewport* local_pViewports;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewports = nullptr;
    if (pViewports)
    {
        local_pViewports = (VkViewport*)pool->alloc(((viewportCount)) * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewport(pool, pViewports + i, (VkViewport*)(local_pViewports + i));
        }
    }
    if (local_pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewport(sResourceTracker, (VkViewport*)(local_pViewports + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_442;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            count_VkViewport(sFeatureBits, (VkViewport*)(local_pViewports + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetViewport = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetViewport -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetViewport);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetViewport = OP_vkCmdSetViewport;
    memcpy(streamPtr, &opcode_vkCmdSetViewport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetViewport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_443;
        *&cgen_var_443 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_443, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstViewport, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_viewportCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        reservedmarshal_VkViewport(stream, (VkViewport*)(local_pViewports + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstScissor;
    uint32_t local_scissorCount;
    VkRect2D* local_pScissors;
    local_commandBuffer = commandBuffer;
    local_firstScissor = firstScissor;
    local_scissorCount = scissorCount;
    local_pScissors = nullptr;
    if (pScissors)
    {
        local_pScissors = (VkRect2D*)pool->alloc(((scissorCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            deepcopy_VkRect2D(pool, pScissors + i, (VkRect2D*)(local_pScissors + i));
        }
    }
    if (local_pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            transform_tohost_VkRect2D(sResourceTracker, (VkRect2D*)(local_pScissors + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_444;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            count_VkRect2D(sFeatureBits, (VkRect2D*)(local_pScissors + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetScissor = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetScissor -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetScissor);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetScissor = OP_vkCmdSetScissor;
    memcpy(streamPtr, &opcode_vkCmdSetScissor, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetScissor, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_445;
        *&cgen_var_445 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_445, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstScissor, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_scissorCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        reservedmarshal_VkRect2D(stream, (VkRect2D*)(local_pScissors + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    float lineWidth,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_lineWidth;
    local_commandBuffer = commandBuffer;
    local_lineWidth = lineWidth;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_446;
        *countPtr += 1 * 8;
        *countPtr += sizeof(float);
    }
    uint32_t packetSize_vkCmdSetLineWidth = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetLineWidth -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetLineWidth);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetLineWidth = OP_vkCmdSetLineWidth;
    memcpy(streamPtr, &opcode_vkCmdSetLineWidth, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetLineWidth, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_447;
        *&cgen_var_447 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_447, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)&local_lineWidth, sizeof(float));
    *streamPtrPtr += sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_depthBiasConstantFactor;
    float local_depthBiasClamp;
    float local_depthBiasSlopeFactor;
    local_commandBuffer = commandBuffer;
    local_depthBiasConstantFactor = depthBiasConstantFactor;
    local_depthBiasClamp = depthBiasClamp;
    local_depthBiasSlopeFactor = depthBiasSlopeFactor;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_448;
        *countPtr += 1 * 8;
        *countPtr += sizeof(float);
        *countPtr += sizeof(float);
        *countPtr += sizeof(float);
    }
    uint32_t packetSize_vkCmdSetDepthBias = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthBias -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthBias);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthBias = OP_vkCmdSetDepthBias;
    memcpy(streamPtr, &opcode_vkCmdSetDepthBias, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthBias, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_449;
        *&cgen_var_449 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_449, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)&local_depthBiasConstantFactor, sizeof(float));
    *streamPtrPtr += sizeof(float);
    memcpy(*streamPtrPtr, (float*)&local_depthBiasClamp, sizeof(float));
    *streamPtrPtr += sizeof(float);
    memcpy(*streamPtrPtr, (float*)&local_depthBiasSlopeFactor, sizeof(float));
    *streamPtrPtr += sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    const float blendConstants[4],
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_blendConstants[4];
    local_commandBuffer = commandBuffer;
    memcpy(local_blendConstants, blendConstants, 4 * sizeof(const float));
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_450;
        *countPtr += 1 * 8;
        *countPtr += 4 * sizeof(float);
    }
    uint32_t packetSize_vkCmdSetBlendConstants = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetBlendConstants -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetBlendConstants);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetBlendConstants = OP_vkCmdSetBlendConstants;
    memcpy(streamPtr, &opcode_vkCmdSetBlendConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetBlendConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_451;
        *&cgen_var_451 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_451, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)local_blendConstants, 4 * sizeof(float));
    *streamPtrPtr += 4 * sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_minDepthBounds;
    float local_maxDepthBounds;
    local_commandBuffer = commandBuffer;
    local_minDepthBounds = minDepthBounds;
    local_maxDepthBounds = maxDepthBounds;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_452;
        *countPtr += 1 * 8;
        *countPtr += sizeof(float);
        *countPtr += sizeof(float);
    }
    uint32_t packetSize_vkCmdSetDepthBounds = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthBounds -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthBounds);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthBounds = OP_vkCmdSetDepthBounds;
    memcpy(streamPtr, &opcode_vkCmdSetDepthBounds, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthBounds, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_453;
        *&cgen_var_453 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_453, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)&local_minDepthBounds, sizeof(float));
    *streamPtrPtr += sizeof(float);
    memcpy(*streamPtrPtr, (float*)&local_maxDepthBounds, sizeof(float));
    *streamPtrPtr += sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_compareMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_compareMask = compareMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_454;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetStencilCompareMask = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilCompareMask -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilCompareMask);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilCompareMask = OP_vkCmdSetStencilCompareMask;
    memcpy(streamPtr, &opcode_vkCmdSetStencilCompareMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilCompareMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_455;
        *&cgen_var_455 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_455, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_compareMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_writeMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_writeMask = writeMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_456;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetStencilWriteMask = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilWriteMask -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilWriteMask);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilWriteMask = OP_vkCmdSetStencilWriteMask;
    memcpy(streamPtr, &opcode_vkCmdSetStencilWriteMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilWriteMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_457;
        *&cgen_var_457 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_457, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_writeMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_reference;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_reference = reference;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_458;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetStencilReference = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilReference -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilReference);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilReference = OP_vkCmdSetStencilReference;
    memcpy(streamPtr, &opcode_vkCmdSetStencilReference, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilReference, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_459;
        *&cgen_var_459 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_459, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_reference, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_firstSet;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    uint32_t local_dynamicOffsetCount;
    uint32_t* local_pDynamicOffsets;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_firstSet = firstSet;
    local_descriptorSetCount = descriptorSetCount;
    // Avoiding deepcopy for pDescriptorSets
    local_pDescriptorSets = (VkDescriptorSet*)pDescriptorSets;
    local_dynamicOffsetCount = dynamicOffsetCount;
    // Avoiding deepcopy for pDynamicOffsets
    local_pDynamicOffsets = (uint32_t*)pDynamicOffsets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_460;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_461;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        if (((descriptorSetCount)))
        {
            *countPtr += ((descriptorSetCount)) * 8;
        }
        *countPtr += sizeof(uint32_t);
        *countPtr += ((dynamicOffsetCount)) * sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdBindDescriptorSets = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindDescriptorSets -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindDescriptorSets = OP_vkCmdBindDescriptorSets;
    memcpy(streamPtr, &opcode_vkCmdBindDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_463;
        *&cgen_var_463 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_463, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_464;
    *&cgen_var_464 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_464, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstSet, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((descriptorSetCount)))
    {
        uint8_t* cgen_var_465_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkDescriptorSet(local_pDescriptorSets[k]);
            memcpy(cgen_var_465_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((descriptorSetCount));
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_dynamicOffsetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)local_pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((dynamicOffsetCount)) * sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkIndexType local_indexType;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_indexType = indexType;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_466;
        *countPtr += 1 * 8;
        uint64_t cgen_var_467;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkIndexType);
    }
    uint32_t packetSize_vkCmdBindIndexBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindIndexBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindIndexBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindIndexBuffer = OP_vkCmdBindIndexBuffer;
    memcpy(streamPtr, &opcode_vkCmdBindIndexBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindIndexBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_468;
        *&cgen_var_468 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_468, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_469;
    *&cgen_var_469 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_469, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkIndexType*)&local_indexType, sizeof(VkIndexType));
    *streamPtrPtr += sizeof(VkIndexType);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstBinding;
    uint32_t local_bindingCount;
    VkBuffer* local_pBuffers;
    VkDeviceSize* local_pOffsets;
    local_commandBuffer = commandBuffer;
    local_firstBinding = firstBinding;
    local_bindingCount = bindingCount;
    // Avoiding deepcopy for pBuffers
    local_pBuffers = (VkBuffer*)pBuffers;
    // Avoiding deepcopy for pOffsets
    local_pOffsets = (VkDeviceSize*)pOffsets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_470;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        if (((bindingCount)))
        {
            *countPtr += ((bindingCount)) * 8;
        }
        *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkCmdBindVertexBuffers = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindVertexBuffers -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindVertexBuffers);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindVertexBuffers = OP_vkCmdBindVertexBuffers;
    memcpy(streamPtr, &opcode_vkCmdBindVertexBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindVertexBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_472;
        *&cgen_var_472 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_472, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstBinding, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindingCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((bindingCount)))
    {
        uint8_t* cgen_var_473_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((bindingCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkBuffer(local_pBuffers[k]);
            memcpy(cgen_var_473_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((bindingCount));
    }
    memcpy(*streamPtrPtr, (VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDraw(
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_vertexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstVertex;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_vertexCount = vertexCount;
    local_instanceCount = instanceCount;
    local_firstVertex = firstVertex;
    local_firstInstance = firstInstance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_474;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDraw = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDraw -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDraw);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDraw = OP_vkCmdDraw;
    memcpy(streamPtr, &opcode_vkCmdDraw, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDraw, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_475;
        *&cgen_var_475 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_475, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_vertexCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_instanceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstVertex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstInstance, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_indexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstIndex;
    int32_t local_vertexOffset;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_indexCount = indexCount;
    local_instanceCount = instanceCount;
    local_firstIndex = firstIndex;
    local_vertexOffset = vertexOffset;
    local_firstInstance = firstInstance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_476;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(int32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexed = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexed -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexed);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexed = OP_vkCmdDrawIndexed;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexed, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexed, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_477;
        *&cgen_var_477 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_477, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_indexCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_instanceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (int32_t*)&local_vertexOffset, sizeof(int32_t));
    *streamPtrPtr += sizeof(int32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstInstance, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_478;
        *countPtr += 1 * 8;
        uint64_t cgen_var_479;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirect = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirect -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirect);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirect = OP_vkCmdDrawIndirect;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_480;
        *&cgen_var_480 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_480, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_481;
    *&cgen_var_481 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_481, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_drawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_482;
        *countPtr += 1 * 8;
        uint64_t cgen_var_483;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirect = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirect -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirect);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirect = OP_vkCmdDrawIndexedIndirect;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_484;
        *&cgen_var_484 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_484, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_485;
    *&cgen_var_485 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_485, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_drawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_486;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDispatch = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatch -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatch);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatch = OP_vkCmdDispatch;
    memcpy(streamPtr, &opcode_vkCmdDispatch, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatch, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_487;
        *&cgen_var_487 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_487, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_488;
        *countPtr += 1 * 8;
        uint64_t cgen_var_489;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkCmdDispatchIndirect = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatchIndirect -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatchIndirect);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatchIndirect = OP_vkCmdDispatchIndirect;
    memcpy(streamPtr, &opcode_vkCmdDispatchIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatchIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_490;
        *&cgen_var_490 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_490, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_491;
    *&cgen_var_491 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_491, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferCopy(pool, pRegions + i, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferCopy(sResourceTracker, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_492;
        *countPtr += 1 * 8;
        uint64_t cgen_var_493;
        *countPtr += 1 * 8;
        uint64_t cgen_var_494;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkBufferCopy(sFeatureBits, (VkBufferCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyBuffer = OP_vkCmdCopyBuffer;
    memcpy(streamPtr, &opcode_vkCmdCopyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_495;
        *&cgen_var_495 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_495, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_496;
    *&cgen_var_496 = get_host_u64_VkBuffer((*&local_srcBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_496, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_497;
    *&cgen_var_497 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_497, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkBufferCopy(stream, (VkBufferCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageCopy(pool, pRegions + i, (VkImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageCopy(sResourceTracker, (VkImageCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_498;
        *countPtr += 1 * 8;
        uint64_t cgen_var_499;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_500;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkImageCopy(sFeatureBits, (VkImageCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyImage = OP_vkCmdCopyImage;
    memcpy(streamPtr, &opcode_vkCmdCopyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_501;
        *&cgen_var_501 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_501, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_502;
    *&cgen_var_502 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_502, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_503;
    *&cgen_var_503 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_503, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkImageCopy(stream, (VkImageCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageBlit* local_pRegions;
    VkFilter local_filter;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageBlit*)pool->alloc(((regionCount)) * sizeof(const VkImageBlit));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageBlit(pool, pRegions + i, (VkImageBlit*)(local_pRegions + i));
        }
    }
    local_filter = filter;
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageBlit(sResourceTracker, (VkImageBlit*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_504;
        *countPtr += 1 * 8;
        uint64_t cgen_var_505;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_506;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkImageBlit(sFeatureBits, (VkImageBlit*)(local_pRegions + i), countPtr);
        }
        *countPtr += sizeof(VkFilter);
    }
    uint32_t packetSize_vkCmdBlitImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBlitImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBlitImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBlitImage = OP_vkCmdBlitImage;
    memcpy(streamPtr, &opcode_vkCmdBlitImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBlitImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_507;
        *&cgen_var_507 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_507, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_508;
    *&cgen_var_508 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_508, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_509;
    *&cgen_var_509 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_509, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkImageBlit(stream, (VkImageBlit*)(local_pRegions + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (VkFilter*)&local_filter, sizeof(VkFilter));
    *streamPtrPtr += sizeof(VkFilter);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(sResourceTracker, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_510;
        *countPtr += 1 * 8;
        uint64_t cgen_var_511;
        *countPtr += 1 * 8;
        uint64_t cgen_var_512;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkBufferImageCopy(sFeatureBits, (VkBufferImageCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyBufferToImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyBufferToImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyBufferToImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyBufferToImage = OP_vkCmdCopyBufferToImage;
    memcpy(streamPtr, &opcode_vkCmdCopyBufferToImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyBufferToImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_513;
        *&cgen_var_513 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_513, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_514;
    *&cgen_var_514 = get_host_u64_VkBuffer((*&local_srcBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_514, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_515;
    *&cgen_var_515 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_515, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkBufferImageCopy(stream, (VkBufferImageCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(sResourceTracker, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_516;
        *countPtr += 1 * 8;
        uint64_t cgen_var_517;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_518;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkBufferImageCopy(sFeatureBits, (VkBufferImageCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyImageToBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyImageToBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyImageToBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyImageToBuffer = OP_vkCmdCopyImageToBuffer;
    memcpy(streamPtr, &opcode_vkCmdCopyImageToBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyImageToBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_519;
        *&cgen_var_519 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_519, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_520;
    *&cgen_var_520 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_520, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_521;
    *&cgen_var_521 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_521, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkBufferImageCopy(stream, (VkBufferImageCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_dataSize;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_dataSize = dataSize;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_522;
        *countPtr += 1 * 8;
        uint64_t cgen_var_523;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += ((dataSize)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkCmdUpdateBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdUpdateBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdUpdateBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdUpdateBuffer = OP_vkCmdUpdateBuffer;
    memcpy(streamPtr, &opcode_vkCmdUpdateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdUpdateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_524;
        *&cgen_var_524 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_524, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_525;
    *&cgen_var_525 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_525, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dataSize, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (void*)local_pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_size;
    uint32_t local_data;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_size = size;
    local_data = data;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_526;
        *countPtr += 1 * 8;
        uint64_t cgen_var_527;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdFillBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdFillBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdFillBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdFillBuffer = OP_vkCmdFillBuffer;
    memcpy(streamPtr, &opcode_vkCmdFillBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdFillBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_528;
        *&cgen_var_528 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_528, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_529;
    *&cgen_var_529 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_529, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_size, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_data, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearColorValue* local_pColor;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pColor = nullptr;
    if (pColor)
    {
        local_pColor = (VkClearColorValue*)pool->alloc(sizeof(const VkClearColorValue));
        deepcopy_VkClearColorValue(pool, pColor, (VkClearColorValue*)(local_pColor));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pColor)
    {
        transform_tohost_VkClearColorValue(sResourceTracker, (VkClearColorValue*)(local_pColor));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(sResourceTracker, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_530;
        *countPtr += 1 * 8;
        uint64_t cgen_var_531;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        count_VkClearColorValue(sFeatureBits, (VkClearColorValue*)(local_pColor), countPtr);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            count_VkImageSubresourceRange(sFeatureBits, (VkImageSubresourceRange*)(local_pRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdClearColorImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdClearColorImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdClearColorImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdClearColorImage = OP_vkCmdClearColorImage;
    memcpy(streamPtr, &opcode_vkCmdClearColorImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdClearColorImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_532;
        *&cgen_var_532 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_532, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_533;
    *&cgen_var_533 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_533, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    reservedmarshal_VkClearColorValue(stream, (VkClearColorValue*)(local_pColor), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)&local_rangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        reservedmarshal_VkImageSubresourceRange(stream, (VkImageSubresourceRange*)(local_pRanges + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearDepthStencilValue* local_pDepthStencil;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pDepthStencil = nullptr;
    if (pDepthStencil)
    {
        local_pDepthStencil = (VkClearDepthStencilValue*)pool->alloc(sizeof(const VkClearDepthStencilValue));
        deepcopy_VkClearDepthStencilValue(pool, pDepthStencil, (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pDepthStencil)
    {
        transform_tohost_VkClearDepthStencilValue(sResourceTracker, (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(sResourceTracker, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_534;
        *countPtr += 1 * 8;
        uint64_t cgen_var_535;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        count_VkClearDepthStencilValue(sFeatureBits, (VkClearDepthStencilValue*)(local_pDepthStencil), countPtr);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            count_VkImageSubresourceRange(sFeatureBits, (VkImageSubresourceRange*)(local_pRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdClearDepthStencilImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdClearDepthStencilImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdClearDepthStencilImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdClearDepthStencilImage = OP_vkCmdClearDepthStencilImage;
    memcpy(streamPtr, &opcode_vkCmdClearDepthStencilImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdClearDepthStencilImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_536;
        *&cgen_var_536 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_536, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_537;
    *&cgen_var_537 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_537, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    reservedmarshal_VkClearDepthStencilValue(stream, (VkClearDepthStencilValue*)(local_pDepthStencil), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)&local_rangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        reservedmarshal_VkImageSubresourceRange(stream, (VkImageSubresourceRange*)(local_pRanges + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_attachmentCount;
    VkClearAttachment* local_pAttachments;
    uint32_t local_rectCount;
    VkClearRect* local_pRects;
    local_commandBuffer = commandBuffer;
    local_attachmentCount = attachmentCount;
    local_pAttachments = nullptr;
    if (pAttachments)
    {
        local_pAttachments = (VkClearAttachment*)pool->alloc(((attachmentCount)) * sizeof(const VkClearAttachment));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            deepcopy_VkClearAttachment(pool, pAttachments + i, (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    local_rectCount = rectCount;
    local_pRects = nullptr;
    if (pRects)
    {
        local_pRects = (VkClearRect*)pool->alloc(((rectCount)) * sizeof(const VkClearRect));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            deepcopy_VkClearRect(pool, pRects + i, (VkClearRect*)(local_pRects + i));
        }
    }
    if (local_pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            transform_tohost_VkClearAttachment(sResourceTracker, (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    if (local_pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            transform_tohost_VkClearRect(sResourceTracker, (VkClearRect*)(local_pRects + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_538;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            count_VkClearAttachment(sFeatureBits, (VkClearAttachment*)(local_pAttachments + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            count_VkClearRect(sFeatureBits, (VkClearRect*)(local_pRects + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdClearAttachments = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdClearAttachments -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdClearAttachments);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdClearAttachments = OP_vkCmdClearAttachments;
    memcpy(streamPtr, &opcode_vkCmdClearAttachments, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdClearAttachments, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_539;
        *&cgen_var_539 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_539, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_attachmentCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        reservedmarshal_VkClearAttachment(stream, (VkClearAttachment*)(local_pAttachments + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_rectCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        reservedmarshal_VkClearRect(stream, (VkClearRect*)(local_pRects + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageResolve* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageResolve*)pool->alloc(((regionCount)) * sizeof(const VkImageResolve));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageResolve(pool, pRegions + i, (VkImageResolve*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageResolve(sResourceTracker, (VkImageResolve*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_540;
        *countPtr += 1 * 8;
        uint64_t cgen_var_541;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_542;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkImageResolve(sFeatureBits, (VkImageResolve*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdResolveImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResolveImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResolveImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResolveImage = OP_vkCmdResolveImage;
    memcpy(streamPtr, &opcode_vkCmdResolveImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResolveImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_543;
        *&cgen_var_543 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_543, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_544;
    *&cgen_var_544 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_544, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_545;
    *&cgen_var_545 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_545, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkImageResolve(stream, (VkImageResolve*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_546;
        *countPtr += 1 * 8;
        uint64_t cgen_var_547;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlags);
    }
    uint32_t packetSize_vkCmdSetEvent = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetEvent -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetEvent = OP_vkCmdSetEvent;
    memcpy(streamPtr, &opcode_vkCmdSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_548;
        *&cgen_var_548 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_548, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_549;
    *&cgen_var_549 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_549, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_550;
        *countPtr += 1 * 8;
        uint64_t cgen_var_551;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlags);
    }
    uint32_t packetSize_vkCmdResetEvent = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResetEvent -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResetEvent = OP_vkCmdResetEvent;
    memcpy(streamPtr, &opcode_vkCmdResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_552;
        *&cgen_var_552 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_552, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_553;
    *&cgen_var_553 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_553, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_eventCount;
    VkEvent* local_pEvents;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_eventCount = eventCount;
    // Avoiding deepcopy for pEvents
    local_pEvents = (VkEvent*)pEvents;
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(sResourceTracker, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(sResourceTracker, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(sResourceTracker, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_554;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((eventCount)))
        {
            *countPtr += ((eventCount)) * 8;
        }
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            count_VkMemoryBarrier(sFeatureBits, (VkMemoryBarrier*)(local_pMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            count_VkBufferMemoryBarrier(sFeatureBits, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            count_VkImageMemoryBarrier(sFeatureBits, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdWaitEvents = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWaitEvents -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWaitEvents);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWaitEvents = OP_vkCmdWaitEvents;
    memcpy(streamPtr, &opcode_vkCmdWaitEvents, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWaitEvents, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_556;
        *&cgen_var_556 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_556, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_eventCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((eventCount)))
    {
        uint8_t* cgen_var_557_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((eventCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkEvent(local_pEvents[k]);
            memcpy(cgen_var_557_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((eventCount));
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        reservedmarshal_VkMemoryBarrier(stream, (VkMemoryBarrier*)(local_pMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkBufferMemoryBarrier(stream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkImageMemoryBarrier(stream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    VkDependencyFlags local_dependencyFlags;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_dependencyFlags = dependencyFlags;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(sResourceTracker, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(sResourceTracker, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(sResourceTracker, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_558;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(VkDependencyFlags);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            count_VkMemoryBarrier(sFeatureBits, (VkMemoryBarrier*)(local_pMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            count_VkBufferMemoryBarrier(sFeatureBits, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            count_VkImageMemoryBarrier(sFeatureBits, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdPipelineBarrier = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPipelineBarrier -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPipelineBarrier);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPipelineBarrier = OP_vkCmdPipelineBarrier;
    memcpy(streamPtr, &opcode_vkCmdPipelineBarrier, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPipelineBarrier, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_559;
        *&cgen_var_559 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_559, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (VkDependencyFlags*)&local_dependencyFlags, sizeof(VkDependencyFlags));
    *streamPtrPtr += sizeof(VkDependencyFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        reservedmarshal_VkMemoryBarrier(stream, (VkMemoryBarrier*)(local_pMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkBufferMemoryBarrier(stream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkImageMemoryBarrier(stream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    VkQueryControlFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_560;
        *countPtr += 1 * 8;
        uint64_t cgen_var_561;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkQueryControlFlags);
    }
    uint32_t packetSize_vkCmdBeginQuery = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginQuery -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginQuery);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginQuery = OP_vkCmdBeginQuery;
    memcpy(streamPtr, &opcode_vkCmdBeginQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_562;
        *&cgen_var_562 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_562, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_563;
    *&cgen_var_563 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_563, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
    *streamPtrPtr += sizeof(VkQueryControlFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_564;
        *countPtr += 1 * 8;
        uint64_t cgen_var_565;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdEndQuery = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndQuery -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndQuery);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndQuery = OP_vkCmdEndQuery;
    memcpy(streamPtr, &opcode_vkCmdEndQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_566;
        *&cgen_var_566 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_566, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_567;
    *&cgen_var_567 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_567, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_568;
        *countPtr += 1 * 8;
        uint64_t cgen_var_569;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdResetQueryPool = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResetQueryPool -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResetQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResetQueryPool = OP_vkCmdResetQueryPool;
    memcpy(streamPtr, &opcode_vkCmdResetQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResetQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_570;
        *&cgen_var_570 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_570, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_571;
    *&cgen_var_571 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_571, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_queryPool = queryPool;
    local_query = query;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_572;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlagBits);
        uint64_t cgen_var_573;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdWriteTimestamp = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWriteTimestamp -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWriteTimestamp);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWriteTimestamp = OP_vkCmdWriteTimestamp;
    memcpy(streamPtr, &opcode_vkCmdWriteTimestamp, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWriteTimestamp, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_574;
        *&cgen_var_574 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_574, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    *streamPtrPtr += sizeof(VkPipelineStageFlagBits);
    uint64_t cgen_var_575;
    *&cgen_var_575 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_575, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_stride = stride;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_576;
        *countPtr += 1 * 8;
        uint64_t cgen_var_577;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_578;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkQueryResultFlags);
    }
    uint32_t packetSize_vkCmdCopyQueryPoolResults = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyQueryPoolResults -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyQueryPoolResults);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyQueryPoolResults = OP_vkCmdCopyQueryPoolResults;
    memcpy(streamPtr, &opcode_vkCmdCopyQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_579;
        *&cgen_var_579 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_579, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_580;
    *&cgen_var_580 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_580, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_581;
    *&cgen_var_581 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_581, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    *streamPtrPtr += sizeof(VkQueryResultFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineLayout local_layout;
    VkShaderStageFlags local_stageFlags;
    uint32_t local_offset;
    uint32_t local_size;
    void* local_pValues;
    local_commandBuffer = commandBuffer;
    local_layout = layout;
    local_stageFlags = stageFlags;
    local_offset = offset;
    local_size = size;
    // Avoiding deepcopy for pValues
    local_pValues = (void*)pValues;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_582;
        *countPtr += 1 * 8;
        uint64_t cgen_var_583;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkShaderStageFlags);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += ((size)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkCmdPushConstants = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPushConstants -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPushConstants);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPushConstants = OP_vkCmdPushConstants;
    memcpy(streamPtr, &opcode_vkCmdPushConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPushConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_584;
        *&cgen_var_584 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_584, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_585;
    *&cgen_var_585 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_585, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkShaderStageFlags*)&local_stageFlags, sizeof(VkShaderStageFlags));
    *streamPtrPtr += sizeof(VkShaderStageFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_offset, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_size, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (void*)local_pValues, ((size)) * sizeof(uint8_t));
    *streamPtrPtr += ((size)) * sizeof(uint8_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_contents = contents;
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(sResourceTracker, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_586;
        *countPtr += 1 * 8;
        count_VkRenderPassBeginInfo(sFeatureBits, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), countPtr);
        *countPtr += sizeof(VkSubpassContents);
    }
    uint32_t packetSize_vkCmdBeginRenderPass = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginRenderPass -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginRenderPass = OP_vkCmdBeginRenderPass;
    memcpy(streamPtr, &opcode_vkCmdBeginRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_587;
        *&cgen_var_587 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_587, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkRenderPassBeginInfo(stream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), streamPtrPtr);
    memcpy(*streamPtrPtr, (VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    *streamPtrPtr += sizeof(VkSubpassContents);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_contents = contents;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_588;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkSubpassContents);
    }
    uint32_t packetSize_vkCmdNextSubpass = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdNextSubpass -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdNextSubpass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdNextSubpass = OP_vkCmdNextSubpass;
    memcpy(streamPtr, &opcode_vkCmdNextSubpass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdNextSubpass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_589;
        *&cgen_var_589 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_589, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    *streamPtrPtr += sizeof(VkSubpassContents);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_590;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdEndRenderPass = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndRenderPass -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndRenderPass = OP_vkCmdEndRenderPass;
    memcpy(streamPtr, &opcode_vkCmdEndRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_591;
        *&cgen_var_591 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_591, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_commandBuffer = commandBuffer;
    local_commandBufferCount = commandBufferCount;
    // Avoiding deepcopy for pCommandBuffers
    local_pCommandBuffers = (VkCommandBuffer*)pCommandBuffers;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_592;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((commandBufferCount)))
        {
            *countPtr += ((commandBufferCount)) * 8;
        }
    }
    uint32_t packetSize_vkCmdExecuteCommands = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdExecuteCommands -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdExecuteCommands);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdExecuteCommands = OP_vkCmdExecuteCommands;
    memcpy(streamPtr, &opcode_vkCmdExecuteCommands, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdExecuteCommands, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_594;
        *&cgen_var_594 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_594, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((commandBufferCount)))
    {
        uint8_t* cgen_var_595_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkCommandBuffer(local_pCommandBuffers[k]);
            memcpy(cgen_var_595_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((commandBufferCount));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_VERSION_1_1
VkResult VkEncoder::vkEnumerateInstanceVersion(
    uint32_t* pApiVersion,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    size_t count = 0;
    size_t* countPtr = &count;
    {
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkEnumerateInstanceVersion = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateInstanceVersion);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateInstanceVersion = OP_vkEnumerateInstanceVersion;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateInstanceVersion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateInstanceVersion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    memcpy(*streamPtrPtr, (uint32_t*)pApiVersion, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateInstanceVersion_VkResult_return;
}

VkResult VkEncoder::vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(sResourceTracker, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_596;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindBufferMemoryInfo(sFeatureBits, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindBufferMemory2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindBufferMemory2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindBufferMemory2 = OP_vkBindBufferMemory2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindBufferMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindBufferMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_597;
    *&cgen_var_597 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_597, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindBufferMemoryInfo(stream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindBufferMemory2_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(sResourceTracker, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_598;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindImageMemoryInfo(sFeatureBits, (VkBindImageMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindImageMemory2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindImageMemory2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindImageMemory2 = OP_vkBindImageMemory2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindImageMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindImageMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_599;
    *&cgen_var_599 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_599, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindImageMemoryInfo(stream, (VkBindImageMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindImageMemory2_VkResult_return;
}

void VkEncoder::vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_600;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkPeerMemoryFeatureFlags);
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeatures = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupPeerMemoryFeatures);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeatures = OP_vkGetDeviceGroupPeerMemoryFeatures;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_601;
    *&cgen_var_601 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_601, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_heapIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    *streamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_602;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetDeviceMask = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDeviceMask -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDeviceMask);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDeviceMask = OP_vkCmdSetDeviceMask;
    memcpy(streamPtr, &opcode_vkCmdSetDeviceMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDeviceMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_603;
        *&cgen_var_603 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_603, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_deviceMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_604;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDispatchBase = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatchBase -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatchBase);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatchBase = OP_vkCmdDispatchBase;
    memcpy(streamPtr, &opcode_vkCmdDispatchBase, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatchBase, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_605;
        *&cgen_var_605 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_605, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    local_instance = instance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_606;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                count_VkPhysicalDeviceGroupProperties(sFeatureBits, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroups = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDeviceGroups);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDeviceGroups = OP_vkEnumeratePhysicalDeviceGroups;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_607;
    *&cgen_var_607 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_607, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_608 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    memcpy((*streamPtrPtr), &cgen_var_608, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_609 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    memcpy((*streamPtrPtr), &cgen_var_609, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            reservedmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            transform_fromhost_VkPhysicalDeviceGroupProperties(sResourceTracker, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

void VkEncoder::vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(sResourceTracker, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_612;
        *countPtr += 1 * 8;
        count_VkImageMemoryRequirementsInfo2(sFeatureBits, (VkImageMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageMemoryRequirements2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageMemoryRequirements2 = OP_vkGetImageMemoryRequirements2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_613;
    *&cgen_var_613 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_613, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageMemoryRequirementsInfo2(stream, (VkImageMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(sResourceTracker, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_614;
        *countPtr += 1 * 8;
        count_VkBufferMemoryRequirementsInfo2(sFeatureBits, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferMemoryRequirements2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferMemoryRequirements2 = OP_vkGetBufferMemoryRequirements2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_615;
    *&cgen_var_615 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_615, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferMemoryRequirementsInfo2(stream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(sResourceTracker, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_616;
        *countPtr += 1 * 8;
        count_VkImageSparseMemoryRequirementsInfo2(sFeatureBits, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirementCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                count_VkSparseImageMemoryRequirements2(sFeatureBits, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSparseMemoryRequirements2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSparseMemoryRequirements2 = OP_vkGetImageSparseMemoryRequirements2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_617;
    *&cgen_var_617 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_617, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageSparseMemoryRequirementsInfo2(stream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_618 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    memcpy((*streamPtrPtr), &cgen_var_618, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirementCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_619 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    memcpy((*streamPtrPtr), &cgen_var_619, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            reservedmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements2(sResourceTracker, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_622;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceFeatures2(sFeatureBits, (VkPhysicalDeviceFeatures2*)(pFeatures), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFeatures2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFeatures2 = OP_vkGetPhysicalDeviceFeatures2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_623;
    *&cgen_var_623 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_623, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures), streamPtrPtr);
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(sResourceTracker, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_624;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceProperties2(sFeatureBits, (VkPhysicalDeviceProperties2*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceProperties2 = OP_vkGetPhysicalDeviceProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_625;
    *&cgen_var_625 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_625, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(sResourceTracker, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceProperties2(this, physicalDevice, pProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_626;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        count_VkFormatProperties2(sFeatureBits, (VkFormatProperties2*)(pFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFormatProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2 = OP_vkGetPhysicalDeviceFormatProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_627;
    *&cgen_var_627 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_627, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    reservedmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties), streamPtrPtr);
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(sResourceTracker, (VkFormatProperties2*)(pFormatProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_628;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceImageFormatInfo2(sFeatureBits, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), countPtr);
        count_VkImageFormatProperties2(sFeatureBits, (VkImageFormatProperties2*)(pImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceImageFormatProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2 = OP_vkGetPhysicalDeviceImageFormatProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_629;
    *&cgen_var_629 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_629, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceImageFormatInfo2(stream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), streamPtrPtr);
    reservedmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties), streamPtrPtr);
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(sResourceTracker, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_630;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                count_VkQueueFamilyProperties2(sFeatureBits, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2 = OP_vkGetPhysicalDeviceQueueFamilyProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_631;
    *&cgen_var_631 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_631, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_632 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_632, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_633 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    memcpy((*streamPtrPtr), &cgen_var_633, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            reservedmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties2(sResourceTracker, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_636;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceMemoryProperties2(sFeatureBits, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMemoryProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2 = OP_vkGetPhysicalDeviceMemoryProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_637;
    *&cgen_var_637 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_637, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(sResourceTracker, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceMemoryProperties2(this, physicalDevice, pMemoryProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_638;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSparseImageFormatInfo2(sFeatureBits, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkSparseImageFormatProperties2(sFeatureBits, (VkSparseImageFormatProperties2*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2 = OP_vkGetPhysicalDeviceSparseImageFormatProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_639;
    *&cgen_var_639 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_639, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_640 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_640, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_641 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_641, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties2(sResourceTracker, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_644;
        *countPtr += 1 * 8;
        uint64_t cgen_var_645;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandPoolTrimFlags);
    }
    uint32_t packetSize_vkTrimCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkTrimCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkTrimCommandPool = OP_vkTrimCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkTrimCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkTrimCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_646;
    *&cgen_var_646 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_646, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_647;
    *&cgen_var_647 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_647, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    *streamPtrPtr += sizeof(VkCommandPoolTrimFlags);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceQueueInfo2* local_pQueueInfo;
    local_device = device;
    local_pQueueInfo = nullptr;
    if (pQueueInfo)
    {
        local_pQueueInfo = (VkDeviceQueueInfo2*)pool->alloc(sizeof(const VkDeviceQueueInfo2));
        deepcopy_VkDeviceQueueInfo2(pool, pQueueInfo, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    if (local_pQueueInfo)
    {
        transform_tohost_VkDeviceQueueInfo2(sResourceTracker, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_648;
        *countPtr += 1 * 8;
        count_VkDeviceQueueInfo2(sFeatureBits, (VkDeviceQueueInfo2*)(local_pQueueInfo), countPtr);
        uint64_t cgen_var_649;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetDeviceQueue2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceQueue2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceQueue2 = OP_vkGetDeviceQueue2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceQueue2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceQueue2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_650;
    *&cgen_var_650 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_650, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceQueueInfo2(stream, (VkDeviceQueueInfo2*)(local_pQueueInfo), streamPtrPtr);
    /* is handle, possibly out */;
    uint64_t cgen_var_651;
    *&cgen_var_651 = (uint64_t)((*pQueue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_651, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_652;
    stream->read((uint64_t*)&cgen_var_652, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_652, (VkQueue*)pQueue, 1);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(sResourceTracker, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_653;
        *countPtr += 1 * 8;
        count_VkSamplerYcbcrConversionCreateInfo(sFeatureBits, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_654;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversion = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSamplerYcbcrConversion);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSamplerYcbcrConversion = OP_vkCreateSamplerYcbcrConversion;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_655;
    *&cgen_var_655 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_655, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSamplerYcbcrConversionCreateInfo(stream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_656 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_656, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_657;
    *&cgen_var_657 = (uint64_t)((*pYcbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_657, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_658;
    stream->read((uint64_t*)&cgen_var_658, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_658, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_659;
        *countPtr += 1 * 8;
        uint64_t cgen_var_660;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversion = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySamplerYcbcrConversion);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySamplerYcbcrConversion = OP_vkDestroySamplerYcbcrConversion;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_661;
    *&cgen_var_661 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_661, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_662;
    *&cgen_var_662 = get_host_u64_VkSamplerYcbcrConversion((*&local_ycbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_662, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_663 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_663, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(sResourceTracker, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_664;
        *countPtr += 1 * 8;
        count_VkDescriptorUpdateTemplateCreateInfo(sFeatureBits, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_665;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplate = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorUpdateTemplate);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorUpdateTemplate = OP_vkCreateDescriptorUpdateTemplate;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_666;
    *&cgen_var_666 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_666, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorUpdateTemplateCreateInfo(stream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_667 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_667, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_668;
    *&cgen_var_668 = (uint64_t)((*pDescriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_668, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_669;
    stream->read((uint64_t*)&cgen_var_669, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_669, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateDescriptorUpdateTemplate(this, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_670;
        *countPtr += 1 * 8;
        uint64_t cgen_var_671;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplate = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorUpdateTemplate);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorUpdateTemplate = OP_vkDestroyDescriptorUpdateTemplate;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_672;
    *&cgen_var_672 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_672, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_673;
    *&cgen_var_673 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_673, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_674 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_674, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_675;
        *countPtr += 1 * 8;
        uint64_t cgen_var_676;
        *countPtr += 1 * 8;
        uint64_t cgen_var_677;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pData)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplate = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSetWithTemplate);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSetWithTemplate = OP_vkUpdateDescriptorSetWithTemplate;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_678;
    *&cgen_var_678 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_678, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_679;
    *&cgen_var_679 = get_host_u64_VkDescriptorSet((*&local_descriptorSet));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_679, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_680;
    *&cgen_var_680 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_680, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_681 = (uint64_t)(uintptr_t)local_pData;
    memcpy((*streamPtrPtr), &cgen_var_681, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pData)
    {
        memcpy(*streamPtrPtr, (void*)local_pData, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        sResourceTracker->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(local_pExternalBufferInfo, 1);
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(sResourceTracker, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_682;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalBufferInfo(sFeatureBits, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), countPtr);
        count_VkExternalBufferProperties(sFeatureBits, (VkExternalBufferProperties*)(pExternalBufferProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalBufferProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferProperties = OP_vkGetPhysicalDeviceExternalBufferProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_683;
    *&cgen_var_683 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_683, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalBufferInfo(stream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), streamPtrPtr);
    reservedmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties), streamPtrPtr);
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        sResourceTracker->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
        transform_fromhost_VkExternalBufferProperties(sResourceTracker, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(sResourceTracker, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_684;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalFenceInfo(sFeatureBits, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), countPtr);
        count_VkExternalFenceProperties(sFeatureBits, (VkExternalFenceProperties*)(pExternalFenceProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFenceProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalFenceProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalFenceProperties = OP_vkGetPhysicalDeviceExternalFenceProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_685;
    *&cgen_var_685 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_685, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalFenceInfo(stream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), streamPtrPtr);
    reservedmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties), streamPtrPtr);
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(sResourceTracker, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(sResourceTracker, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_686;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalSemaphoreInfo(sFeatureBits, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), countPtr);
        count_VkExternalSemaphoreProperties(sFeatureBits, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphoreProperties = OP_vkGetPhysicalDeviceExternalSemaphoreProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_687;
    *&cgen_var_687 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_687, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), streamPtrPtr);
    reservedmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), streamPtrPtr);
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(sResourceTracker, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(sResourceTracker, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_688;
        *countPtr += 1 * 8;
        count_VkDescriptorSetLayoutCreateInfo(sFeatureBits, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        count_VkDescriptorSetLayoutSupport(sFeatureBits, (VkDescriptorSetLayoutSupport*)(pSupport), countPtr);
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupport = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDescriptorSetLayoutSupport);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDescriptorSetLayoutSupport = OP_vkGetDescriptorSetLayoutSupport;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_689;
    *&cgen_var_689 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_689, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    reservedmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport), streamPtrPtr);
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(sResourceTracker, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_surface
void VkEncoder::vkDestroySurfaceKHR(
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkSurfaceKHR local_surface;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_surface = surface;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_690;
        *countPtr += 1 * 8;
        uint64_t cgen_var_691;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySurfaceKHR = OP_vkDestroySurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_692;
    *&cgen_var_692 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_692, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_693;
    *&cgen_var_693 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_693, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_694 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_694, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&surface);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_695;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_696;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceSupportKHR = OP_vkGetPhysicalDeviceSurfaceSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_697;
    *&cgen_var_697 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_697, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_698;
    *&cgen_var_698 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_698, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkBool32*)pSupported, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    stream->read((VkBool32*)pSupported, sizeof(VkBool32));
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_699;
        *countPtr += 1 * 8;
        uint64_t cgen_var_700;
        *countPtr += 1 * 8;
        count_VkSurfaceCapabilitiesKHR(sFeatureBits, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_701;
    *&cgen_var_701 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_701, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_702;
    *&cgen_var_702 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_702, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities), streamPtrPtr);
    unmarshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilitiesKHR(sResourceTracker, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_703;
        *countPtr += 1 * 8;
        uint64_t cgen_var_704;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormatCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                count_VkSurfaceFormatKHR(sFeatureBits, (VkSurfaceFormatKHR*)(pSurfaceFormats + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormatsKHR = OP_vkGetPhysicalDeviceSurfaceFormatsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_705;
    *&cgen_var_705 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_705, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_706;
    *&cgen_var_706 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_706, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_707 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    memcpy((*streamPtrPtr), &cgen_var_707, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormatCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_708 = (uint64_t)(uintptr_t)pSurfaceFormats;
    memcpy((*streamPtrPtr), &cgen_var_708, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            reservedmarshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormatKHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            transform_fromhost_VkSurfaceFormatKHR(sResourceTracker, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_711;
        *countPtr += 1 * 8;
        uint64_t cgen_var_712;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentModeCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentModes)
        {
            *countPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfacePresentModesKHR = OP_vkGetPhysicalDeviceSurfacePresentModesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_713;
    *&cgen_var_713 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_713, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_714;
    *&cgen_var_714 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_714, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_715 = (uint64_t)(uintptr_t)pPresentModeCount;
    memcpy((*streamPtrPtr), &cgen_var_715, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentModeCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPresentModeCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_716 = (uint64_t)(uintptr_t)pPresentModes;
    memcpy((*streamPtrPtr), &cgen_var_716, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentModes)
    {
        memcpy(*streamPtrPtr, (VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
        *streamPtrPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentModeCount;
    check_pPresentModeCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentModeCount)
    {
        if (!(check_pPresentModeCount))
        {
            fprintf(stderr, "fatal: pPresentModeCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPresentModeKHR* check_pPresentModes;
    check_pPresentModes = (VkPresentModeKHR*)(uintptr_t)stream->getBe64();
    if (pPresentModes)
    {
        if (!(check_pPresentModes))
        {
            fprintf(stderr, "fatal: pPresentModes inconsistent between guest and host\n");
        }
        stream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_swapchain
VkResult VkEncoder::vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSwapchainCreateInfoKHR*)pool->alloc(sizeof(const VkSwapchainCreateInfoKHR));
        deepcopy_VkSwapchainCreateInfoKHR(pool, pCreateInfo, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSwapchainCreateInfoKHR(sResourceTracker, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_719;
        *countPtr += 1 * 8;
        count_VkSwapchainCreateInfoKHR(sFeatureBits, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_720;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSwapchainKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSwapchainKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSwapchainKHR = OP_vkCreateSwapchainKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_721;
    *&cgen_var_721 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_721, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSwapchainCreateInfoKHR(stream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_722 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_722, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_723;
    *&cgen_var_723 = (uint64_t)((*pSwapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_723, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_724;
    stream->read((uint64_t*)&cgen_var_724, 8);
    stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_724, (VkSwapchainKHR*)pSwapchain, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSwapchainKHR_VkResult_return;
}

void VkEncoder::vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchain = swapchain;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_725;
        *countPtr += 1 * 8;
        uint64_t cgen_var_726;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySwapchainKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySwapchainKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySwapchainKHR = OP_vkDestroySwapchainKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_727;
    *&cgen_var_727 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_727, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_728;
    *&cgen_var_728 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_728, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_729 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_729, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&swapchain);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_730;
        *countPtr += 1 * 8;
        uint64_t cgen_var_731;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSwapchainImageCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSwapchainImages)
        {
            if ((*(pSwapchainImageCount)))
            {
                *countPtr += (*(pSwapchainImageCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkGetSwapchainImagesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainImagesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainImagesKHR = OP_vkGetSwapchainImagesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainImagesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainImagesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_733;
    *&cgen_var_733 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_733, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_734;
    *&cgen_var_734 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_734, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_735 = (uint64_t)(uintptr_t)pSwapchainImageCount;
    memcpy((*streamPtrPtr), &cgen_var_735, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSwapchainImageCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_736 = (uint64_t)(uintptr_t)pSwapchainImages;
    memcpy((*streamPtrPtr), &cgen_var_736, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSwapchainImages)
    {
        if ((*(pSwapchainImageCount)))
        {
            uint8_t* cgen_var_737_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < (*(pSwapchainImageCount)); ++k)
            {
                uint64_t tmpval = (uint64_t)(pSwapchainImages[k]);
                memcpy(cgen_var_737_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * (*(pSwapchainImageCount));
        }
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint32_t* check_pSwapchainImageCount;
    check_pSwapchainImageCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSwapchainImageCount)
    {
        if (!(check_pSwapchainImageCount))
        {
            fprintf(stderr, "fatal: pSwapchainImageCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkImage* check_pSwapchainImages;
    check_pSwapchainImages = (VkImage*)(uintptr_t)stream->getBe64();
    if (pSwapchainImages)
    {
        if (!(check_pSwapchainImages))
        {
            fprintf(stderr, "fatal: pSwapchainImages inconsistent between guest and host\n");
        }
        if ((*(pSwapchainImageCount)))
        {
            uint64_t* cgen_var_740;
            stream->alloc((void**)&cgen_var_740, (*(pSwapchainImageCount)) * 8);
            stream->read((uint64_t*)cgen_var_740, (*(pSwapchainImageCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkImage(cgen_var_740, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
        }
    }
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    uint64_t local_timeout;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_swapchain = swapchain;
    local_timeout = timeout;
    local_semaphore = semaphore;
    local_fence = fence;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_741;
        *countPtr += 1 * 8;
        uint64_t cgen_var_742;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint64_t);
        uint64_t cgen_var_743;
        *countPtr += 1 * 8;
        uint64_t cgen_var_744;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkAcquireNextImageKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireNextImageKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireNextImageKHR = OP_vkAcquireNextImageKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireNextImageKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireNextImageKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_745;
    *&cgen_var_745 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_745, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_746;
    *&cgen_var_746 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_746, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint64_t*)&local_timeout, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    uint64_t cgen_var_747;
    *&cgen_var_747 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_747, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_748;
    *&cgen_var_748 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_748, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)pImageIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireNextImageKHR_VkResult_return;
}

VkResult VkEncoder::vkQueuePresentKHR(
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkPresentInfoKHR* local_pPresentInfo;
    local_queue = queue;
    local_pPresentInfo = nullptr;
    if (pPresentInfo)
    {
        local_pPresentInfo = (VkPresentInfoKHR*)pool->alloc(sizeof(const VkPresentInfoKHR));
        deepcopy_VkPresentInfoKHR(pool, pPresentInfo, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    if (local_pPresentInfo)
    {
        transform_tohost_VkPresentInfoKHR(sResourceTracker, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_749;
        *countPtr += 1 * 8;
        count_VkPresentInfoKHR(sFeatureBits, (VkPresentInfoKHR*)(local_pPresentInfo), countPtr);
    }
    uint32_t packetSize_vkQueuePresentKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueuePresentKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueuePresentKHR = OP_vkQueuePresentKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueuePresentKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueuePresentKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_750;
    *&cgen_var_750 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_750, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPresentInfoKHR(stream, (VkPresentInfoKHR*)(local_pPresentInfo), streamPtrPtr);
    VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
    stream->read(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueuePresentKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    local_device = device;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_751;
        *countPtr += 1 * 8;
        count_VkDeviceGroupPresentCapabilitiesKHR(sFeatureBits, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetDeviceGroupPresentCapabilitiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupPresentCapabilitiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupPresentCapabilitiesKHR = OP_vkGetDeviceGroupPresentCapabilitiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_752;
    *&cgen_var_752 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_752, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities), streamPtrPtr);
    unmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    if (pDeviceGroupPresentCapabilities)
    {
        transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(sResourceTracker, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSurfaceKHR local_surface;
    local_device = device;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_753;
        *countPtr += 1 * 8;
        uint64_t cgen_var_754;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pModes)
        {
            *countPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
        }
    }
    uint32_t packetSize_vkGetDeviceGroupSurfacePresentModesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupSurfacePresentModesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupSurfacePresentModesKHR = OP_vkGetDeviceGroupSurfacePresentModesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_755;
    *&cgen_var_755 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_755, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_756;
    *&cgen_var_756 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_756, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_757 = (uint64_t)(uintptr_t)pModes;
    memcpy((*streamPtrPtr), &cgen_var_757, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pModes)
    {
        memcpy(*streamPtrPtr, (VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
        *streamPtrPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
    }
    // WARNING PTR CHECK
    VkDeviceGroupPresentModeFlagsKHR* check_pModes;
    check_pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)stream->getBe64();
    if (pModes)
    {
        if (!(check_pModes))
        {
            fprintf(stderr, "fatal: pModes inconsistent between guest and host\n");
        }
        stream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_759;
        *countPtr += 1 * 8;
        uint64_t cgen_var_760;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pRectCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pRects)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
            {
                count_VkRect2D(sFeatureBits, (VkRect2D*)(pRects + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDevicePresentRectanglesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDevicePresentRectanglesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDevicePresentRectanglesKHR = OP_vkGetPhysicalDevicePresentRectanglesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_761;
    *&cgen_var_761 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_761, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_762;
    *&cgen_var_762 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_762, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_763 = (uint64_t)(uintptr_t)pRectCount;
    memcpy((*streamPtrPtr), &cgen_var_763, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pRectCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pRectCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_764 = (uint64_t)(uintptr_t)pRects;
    memcpy((*streamPtrPtr), &cgen_var_764, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            reservedmarshal_VkRect2D(stream, (VkRect2D*)(pRects + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pRectCount;
    check_pRectCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pRectCount)
    {
        if (!(check_pRectCount))
        {
            fprintf(stderr, "fatal: pRectCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkRect2D* check_pRects;
    check_pRects = (VkRect2D*)(uintptr_t)stream->getBe64();
    if (pRects)
    {
        if (!(check_pRects))
        {
            fprintf(stderr, "fatal: pRects inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            unmarshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            transform_fromhost_VkRect2D(sResourceTracker, (VkRect2D*)(pRects + i));
        }
    }
    VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAcquireNextImageInfoKHR* local_pAcquireInfo;
    local_device = device;
    local_pAcquireInfo = nullptr;
    if (pAcquireInfo)
    {
        local_pAcquireInfo = (VkAcquireNextImageInfoKHR*)pool->alloc(sizeof(const VkAcquireNextImageInfoKHR));
        deepcopy_VkAcquireNextImageInfoKHR(pool, pAcquireInfo, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    if (local_pAcquireInfo)
    {
        transform_tohost_VkAcquireNextImageInfoKHR(sResourceTracker, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_767;
        *countPtr += 1 * 8;
        count_VkAcquireNextImageInfoKHR(sFeatureBits, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo), countPtr);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkAcquireNextImage2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireNextImage2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireNextImage2KHR = OP_vkAcquireNextImage2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireNextImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireNextImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_768;
    *&cgen_var_768 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_768, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAcquireNextImageInfoKHR(stream, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)pImageIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireNextImage2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display
VkResult VkEncoder::vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_769;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkDisplayPropertiesKHR(sFeatureBits, (VkDisplayPropertiesKHR*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayPropertiesKHR = OP_vkGetPhysicalDeviceDisplayPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_770;
    *&cgen_var_770 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_770, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_771 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_771, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_772 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_772, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPropertiesKHR(sResourceTracker, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_775;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkDisplayPlanePropertiesKHR(sFeatureBits, (VkDisplayPlanePropertiesKHR*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_776;
    *&cgen_var_776 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_776, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_777 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_777, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_778 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_778, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlanePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPlanePropertiesKHR(sResourceTracker, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_planeIndex = planeIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_781;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDisplayCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDisplays)
        {
            if ((*(pDisplayCount)))
            {
                *countPtr += (*(pDisplayCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkGetDisplayPlaneSupportedDisplaysKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayPlaneSupportedDisplaysKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayPlaneSupportedDisplaysKHR = OP_vkGetDisplayPlaneSupportedDisplaysKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_783;
    *&cgen_var_783 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_783, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_planeIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_784 = (uint64_t)(uintptr_t)pDisplayCount;
    memcpy((*streamPtrPtr), &cgen_var_784, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDisplayCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pDisplayCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_785 = (uint64_t)(uintptr_t)pDisplays;
    memcpy((*streamPtrPtr), &cgen_var_785, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDisplays)
    {
        if ((*(pDisplayCount)))
        {
            uint8_t* cgen_var_786_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < (*(pDisplayCount)); ++k)
            {
                uint64_t tmpval = (uint64_t)(pDisplays[k]);
                memcpy(cgen_var_786_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * (*(pDisplayCount));
        }
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint32_t* check_pDisplayCount;
    check_pDisplayCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pDisplayCount)
    {
        if (!(check_pDisplayCount))
        {
            fprintf(stderr, "fatal: pDisplayCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayKHR* check_pDisplays;
    check_pDisplays = (VkDisplayKHR*)(uintptr_t)stream->getBe64();
    if (pDisplays)
    {
        if (!(check_pDisplays))
        {
            fprintf(stderr, "fatal: pDisplays inconsistent between guest and host\n");
        }
        if ((*(pDisplayCount)))
        {
            uint64_t* cgen_var_789;
            stream->alloc((void**)&cgen_var_789, (*(pDisplayCount)) * 8);
            stream->read((uint64_t*)cgen_var_789, (*(pDisplayCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_789, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
        }
    }
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_790;
        *countPtr += 1 * 8;
        uint64_t cgen_var_791;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkDisplayModePropertiesKHR(sFeatureBits, (VkDisplayModePropertiesKHR*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayModePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayModePropertiesKHR = OP_vkGetDisplayModePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayModePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayModePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_792;
    *&cgen_var_792 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_792, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_793;
    *&cgen_var_793 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_793, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_794 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_794, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_795 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_795, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayModePropertiesKHR(sResourceTracker, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    VkDisplayModeCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_display = display;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplayModeCreateInfoKHR*)pool->alloc(sizeof(const VkDisplayModeCreateInfoKHR));
        deepcopy_VkDisplayModeCreateInfoKHR(pool, pCreateInfo, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplayModeCreateInfoKHR(sResourceTracker, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_798;
        *countPtr += 1 * 8;
        uint64_t cgen_var_799;
        *countPtr += 1 * 8;
        count_VkDisplayModeCreateInfoKHR(sFeatureBits, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_800;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDisplayModeKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDisplayModeKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDisplayModeKHR = OP_vkCreateDisplayModeKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDisplayModeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDisplayModeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_801;
    *&cgen_var_801 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_801, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_802;
    *&cgen_var_802 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_802, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayModeCreateInfoKHR(stream, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_803 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_803, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_804;
    *&cgen_var_804 = (uint64_t)((*pMode));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_804, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_805;
    stream->read((uint64_t*)&cgen_var_805, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_805, (VkDisplayModeKHR*)pMode, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDisplayModeKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayModeKHR local_mode;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_mode = mode;
    local_planeIndex = planeIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_806;
        *countPtr += 1 * 8;
        uint64_t cgen_var_807;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        count_VkDisplayPlaneCapabilitiesKHR(sFeatureBits, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilitiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayPlaneCapabilitiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayPlaneCapabilitiesKHR = OP_vkGetDisplayPlaneCapabilitiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_808;
    *&cgen_var_808 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_808, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_809;
    *&cgen_var_809 = get_host_u64_VkDisplayModeKHR((*&local_mode));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_809, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_planeIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    reservedmarshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities), streamPtrPtr);
    unmarshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilitiesKHR(sResourceTracker, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDisplaySurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplaySurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkDisplaySurfaceCreateInfoKHR));
        deepcopy_VkDisplaySurfaceCreateInfoKHR(pool, pCreateInfo, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplaySurfaceCreateInfoKHR(sResourceTracker, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_810;
        *countPtr += 1 * 8;
        count_VkDisplaySurfaceCreateInfoKHR(sFeatureBits, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_811;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDisplayPlaneSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDisplayPlaneSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDisplayPlaneSurfaceKHR = OP_vkCreateDisplayPlaneSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_812;
    *&cgen_var_812 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_812, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplaySurfaceCreateInfoKHR(stream, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_813 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_813, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_814;
    *&cgen_var_814 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_814, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_815;
    stream->read((uint64_t*)&cgen_var_815, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_815, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display_swapchain
VkResult VkEncoder::vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainCreateInfoKHR* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchainCount = swapchainCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkSwapchainCreateInfoKHR*)pool->alloc(((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkSwapchainCreateInfoKHR(pool, pCreateInfos + i, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkSwapchainCreateInfoKHR(sResourceTracker, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_816;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            count_VkSwapchainCreateInfoKHR(sFeatureBits, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((swapchainCount)))
        {
            *countPtr += ((swapchainCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateSharedSwapchainsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSharedSwapchainsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSharedSwapchainsKHR = OP_vkCreateSharedSwapchainsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSharedSwapchainsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSharedSwapchainsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_818;
    *&cgen_var_818 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_818, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        reservedmarshal_VkSwapchainCreateInfoKHR(stream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_819 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_819, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((swapchainCount)))
    {
        uint8_t* cgen_var_820_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((swapchainCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pSwapchains[k]);
            memcpy(cgen_var_820_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((swapchainCount));
    }
    /* is handle, possibly out */;
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_821;
        stream->alloc((void**)&cgen_var_821, ((swapchainCount)) * 8);
        stream->read((uint64_t*)cgen_var_821, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_821, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
    }
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_xlib_surface
VkResult VkEncoder::vkCreateXlibSurfaceKHR(
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkXlibSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXlibSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXlibSurfaceCreateInfoKHR));
        deepcopy_VkXlibSurfaceCreateInfoKHR(pool, pCreateInfo, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXlibSurfaceCreateInfoKHR(sResourceTracker, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_822;
        *countPtr += 1 * 8;
        count_VkXlibSurfaceCreateInfoKHR(sFeatureBits, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_823;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateXlibSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateXlibSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateXlibSurfaceKHR = OP_vkCreateXlibSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateXlibSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateXlibSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_824;
    *&cgen_var_824 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_824, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkXlibSurfaceCreateInfoKHR(stream, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_825 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_825, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_826;
    *&cgen_var_826 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_826, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_827;
    stream->read((uint64_t*)&cgen_var_827, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_827, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateXlibSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VisualID local_visualID;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visualID = visualID;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_828;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(Display);
        *countPtr += sizeof(VisualID);
    }
    uint32_t packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR = OP_vkGetPhysicalDeviceXlibPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_829;
    *&cgen_var_829 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_829, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (Display*)dpy, sizeof(Display));
    *streamPtrPtr += sizeof(Display);
    memcpy(*streamPtrPtr, (VisualID*)&local_visualID, sizeof(VisualID));
    *streamPtrPtr += sizeof(VisualID);
    stream->read((Display*)dpy, sizeof(Display));
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_xcb_surface
VkResult VkEncoder::vkCreateXcbSurfaceKHR(
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkXcbSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXcbSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXcbSurfaceCreateInfoKHR));
        deepcopy_VkXcbSurfaceCreateInfoKHR(pool, pCreateInfo, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXcbSurfaceCreateInfoKHR(sResourceTracker, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_830;
        *countPtr += 1 * 8;
        count_VkXcbSurfaceCreateInfoKHR(sFeatureBits, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_831;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateXcbSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateXcbSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateXcbSurfaceKHR = OP_vkCreateXcbSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateXcbSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateXcbSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_832;
    *&cgen_var_832 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_832, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkXcbSurfaceCreateInfoKHR(stream, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_833 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_833, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_834;
    *&cgen_var_834 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_834, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_835;
    stream->read((uint64_t*)&cgen_var_835, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_835, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateXcbSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    xcb_visualid_t local_visual_id;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visual_id = visual_id;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_836;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(xcb_connection_t);
        *countPtr += sizeof(xcb_visualid_t);
    }
    uint32_t packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR = OP_vkGetPhysicalDeviceXcbPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_837;
    *&cgen_var_837 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_837, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (xcb_connection_t*)connection, sizeof(xcb_connection_t));
    *streamPtrPtr += sizeof(xcb_connection_t);
    memcpy(*streamPtrPtr, (xcb_visualid_t*)&local_visual_id, sizeof(xcb_visualid_t));
    *streamPtrPtr += sizeof(xcb_visualid_t);
    stream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_wayland_surface
VkResult VkEncoder::vkCreateWaylandSurfaceKHR(
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkWaylandSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWaylandSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWaylandSurfaceCreateInfoKHR));
        deepcopy_VkWaylandSurfaceCreateInfoKHR(pool, pCreateInfo, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWaylandSurfaceCreateInfoKHR(sResourceTracker, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_838;
        *countPtr += 1 * 8;
        count_VkWaylandSurfaceCreateInfoKHR(sFeatureBits, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_839;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateWaylandSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateWaylandSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateWaylandSurfaceKHR = OP_vkCreateWaylandSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateWaylandSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateWaylandSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_840;
    *&cgen_var_840 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_840, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkWaylandSurfaceCreateInfoKHR(stream, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_841 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_841, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_842;
    *&cgen_var_842 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_842, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_843;
    stream->read((uint64_t*)&cgen_var_843, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_843, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_844;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(wl_display);
    }
    uint32_t packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR = OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_845;
    *&cgen_var_845 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_845, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (wl_display*)display, sizeof(wl_display));
    *streamPtrPtr += sizeof(wl_display);
    stream->read((wl_display*)display, sizeof(wl_display));
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_mir_surface
VkResult VkEncoder::vkCreateMirSurfaceKHR(
    VkInstance instance,
    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkMirSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMirSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkMirSurfaceCreateInfoKHR));
        deepcopy_VkMirSurfaceCreateInfoKHR(pool, pCreateInfo, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMirSurfaceCreateInfoKHR(sResourceTracker, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_846;
        *countPtr += 1 * 8;
        count_VkMirSurfaceCreateInfoKHR(sFeatureBits, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_847;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateMirSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateMirSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateMirSurfaceKHR = OP_vkCreateMirSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateMirSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateMirSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_848;
    *&cgen_var_848 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_848, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMirSurfaceCreateInfoKHR(stream, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_849 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_849, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_850;
    *&cgen_var_850 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_850, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_851;
    stream->read((uint64_t*)&cgen_var_851, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_851, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateMirSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    MirConnection* connection,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_852;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(MirConnection);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMirPresentationSupportKHR = OP_vkGetPhysicalDeviceMirPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_853;
    *&cgen_var_853 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_853, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (MirConnection*)connection, sizeof(MirConnection));
    *streamPtrPtr += sizeof(MirConnection);
    stream->read((MirConnection*)connection, sizeof(MirConnection));
    VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_android_surface
VkResult VkEncoder::vkCreateAndroidSurfaceKHR(
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkAndroidSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkAndroidSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkAndroidSurfaceCreateInfoKHR));
        deepcopy_VkAndroidSurfaceCreateInfoKHR(pool, pCreateInfo, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkAndroidSurfaceCreateInfoKHR(sResourceTracker, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_854;
        *countPtr += 1 * 8;
        count_VkAndroidSurfaceCreateInfoKHR(sFeatureBits, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_855;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateAndroidSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateAndroidSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateAndroidSurfaceKHR = OP_vkCreateAndroidSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateAndroidSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateAndroidSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_856;
    *&cgen_var_856 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_856, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAndroidSurfaceCreateInfoKHR(stream, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_857 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_857, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_858;
    *&cgen_var_858 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_858, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_859;
    stream->read((uint64_t*)&cgen_var_859, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_859, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_surface
VkResult VkEncoder::vkCreateWin32SurfaceKHR(
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkWin32SurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWin32SurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWin32SurfaceCreateInfoKHR));
        deepcopy_VkWin32SurfaceCreateInfoKHR(pool, pCreateInfo, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWin32SurfaceCreateInfoKHR(sResourceTracker, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_860;
        *countPtr += 1 * 8;
        count_VkWin32SurfaceCreateInfoKHR(sFeatureBits, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_861;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateWin32SurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateWin32SurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateWin32SurfaceKHR = OP_vkCreateWin32SurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateWin32SurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateWin32SurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_862;
    *&cgen_var_862 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_862, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkWin32SurfaceCreateInfoKHR(stream, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_863 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_863, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_864;
    *&cgen_var_864 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_864, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_865;
    stream->read((uint64_t*)&cgen_var_865, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_865, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateWin32SurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_866;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR = OP_vkGetPhysicalDeviceWin32PresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_867;
    *&cgen_var_867 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_867, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkEncoder::vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_868;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceFeatures2(sFeatureBits, (VkPhysicalDeviceFeatures2*)(pFeatures), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFeatures2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFeatures2KHR = OP_vkGetPhysicalDeviceFeatures2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_869;
    *&cgen_var_869 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_869, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures), streamPtrPtr);
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(sResourceTracker, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_870;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceProperties2(sFeatureBits, (VkPhysicalDeviceProperties2*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceProperties2KHR = OP_vkGetPhysicalDeviceProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_871;
    *&cgen_var_871 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_871, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(sResourceTracker, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceProperties2KHR(this, physicalDevice, pProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_872;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        count_VkFormatProperties2(sFeatureBits, (VkFormatProperties2*)(pFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFormatProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2KHR = OP_vkGetPhysicalDeviceFormatProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_873;
    *&cgen_var_873 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_873, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    reservedmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties), streamPtrPtr);
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(sResourceTracker, (VkFormatProperties2*)(pFormatProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_874;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceImageFormatInfo2(sFeatureBits, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), countPtr);
        count_VkImageFormatProperties2(sFeatureBits, (VkImageFormatProperties2*)(pImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2KHR = OP_vkGetPhysicalDeviceImageFormatProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_875;
    *&cgen_var_875 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_875, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceImageFormatInfo2(stream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), streamPtrPtr);
    reservedmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties), streamPtrPtr);
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(sResourceTracker, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_876;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                count_VkQueueFamilyProperties2(sFeatureBits, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR = OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_877;
    *&cgen_var_877 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_877, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_878 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_878, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_879 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    memcpy((*streamPtrPtr), &cgen_var_879, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            reservedmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties2(sResourceTracker, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_882;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceMemoryProperties2(sFeatureBits, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMemoryProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2KHR = OP_vkGetPhysicalDeviceMemoryProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_883;
    *&cgen_var_883 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_883, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(sResourceTracker, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceMemoryProperties2KHR(this, physicalDevice, pMemoryProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_884;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSparseImageFormatInfo2(sFeatureBits, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkSparseImageFormatProperties2(sFeatureBits, (VkSparseImageFormatProperties2*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_885;
    *&cgen_var_885 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_885, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_886 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_886, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_887 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_887, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties2(sResourceTracker, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_device_group
void VkEncoder::vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_890;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkPeerMemoryFeatureFlags);
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR = OP_vkGetDeviceGroupPeerMemoryFeaturesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_891;
    *&cgen_var_891 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_891, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_heapIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    *streamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_892;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetDeviceMaskKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDeviceMaskKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDeviceMaskKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDeviceMaskKHR = OP_vkCmdSetDeviceMaskKHR;
    memcpy(streamPtr, &opcode_vkCmdSetDeviceMaskKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDeviceMaskKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_893;
        *&cgen_var_893 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_893, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_deviceMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_894;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDispatchBaseKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatchBaseKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatchBaseKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatchBaseKHR = OP_vkCmdDispatchBaseKHR;
    memcpy(streamPtr, &opcode_vkCmdDispatchBaseKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatchBaseKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_895;
        *&cgen_var_895 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_895, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
void VkEncoder::vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_896;
        *countPtr += 1 * 8;
        uint64_t cgen_var_897;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandPoolTrimFlags);
    }
    uint32_t packetSize_vkTrimCommandPoolKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkTrimCommandPoolKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkTrimCommandPoolKHR = OP_vkTrimCommandPoolKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkTrimCommandPoolKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkTrimCommandPoolKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_898;
    *&cgen_var_898 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_898, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_899;
    *&cgen_var_899 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_899, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    *streamPtrPtr += sizeof(VkCommandPoolTrimFlags);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_device_group_creation
VkResult VkEncoder::vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    local_instance = instance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_900;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                count_VkPhysicalDeviceGroupProperties(sFeatureBits, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroupsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDeviceGroupsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDeviceGroupsKHR = OP_vkEnumeratePhysicalDeviceGroupsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_901;
    *&cgen_var_901 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_901, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_902 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    memcpy((*streamPtrPtr), &cgen_var_902, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_903 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    memcpy((*streamPtrPtr), &cgen_var_903, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            reservedmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            transform_fromhost_VkPhysicalDeviceGroupProperties(sResourceTracker, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        sResourceTracker->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(local_pExternalBufferInfo, 1);
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(sResourceTracker, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_906;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalBufferInfo(sFeatureBits, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), countPtr);
        count_VkExternalBufferProperties(sFeatureBits, (VkExternalBufferProperties*)(pExternalBufferProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR = OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_907;
    *&cgen_var_907 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_907, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalBufferInfo(stream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), streamPtrPtr);
    reservedmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties), streamPtrPtr);
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        sResourceTracker->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
        transform_fromhost_VkExternalBufferProperties(sResourceTracker, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkMemoryGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkMemoryGetWin32HandleInfoKHR));
        deepcopy_VkMemoryGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkMemoryGetWin32HandleInfoKHR(sResourceTracker, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_908;
        *countPtr += 1 * 8;
        count_VkMemoryGetWin32HandleInfoKHR(sFeatureBits, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), countPtr);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetMemoryWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryWin32HandleKHR = OP_vkGetMemoryWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_909;
    *&cgen_var_909 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_909, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryGetWin32HandleInfoKHR(stream, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    HANDLE local_handle;
    local_device = device;
    local_handleType = handleType;
    local_handle = handle;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_910;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
        *countPtr += sizeof(HANDLE);
        count_VkMemoryWin32HandlePropertiesKHR(sFeatureBits, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties), countPtr);
    }
    uint32_t packetSize_vkGetMemoryWin32HandlePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryWin32HandlePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryWin32HandlePropertiesKHR = OP_vkGetMemoryWin32HandlePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_911;
    *&cgen_var_911 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_911, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*streamPtrPtr, (HANDLE*)&local_handle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    reservedmarshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties), streamPtrPtr);
    unmarshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    if (pMemoryWin32HandleProperties)
    {
        transform_fromhost_VkMemoryWin32HandlePropertiesKHR(sResourceTracker, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_fd
VkResult VkEncoder::vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkMemoryGetFdInfoKHR*)pool->alloc(sizeof(const VkMemoryGetFdInfoKHR));
        deepcopy_VkMemoryGetFdInfoKHR(pool, pGetFdInfo, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkMemoryGetFdInfoKHR(sResourceTracker, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_912;
        *countPtr += 1 * 8;
        count_VkMemoryGetFdInfoKHR(sFeatureBits, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo), countPtr);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetMemoryFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryFdKHR = OP_vkGetMemoryFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_913;
    *&cgen_var_913 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_913, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryGetFdInfoKHR(stream, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (int*)pFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    int local_fd;
    local_device = device;
    local_handleType = handleType;
    local_fd = fd;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_914;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
        *countPtr += sizeof(int);
        count_VkMemoryFdPropertiesKHR(sFeatureBits, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties), countPtr);
    }
    uint32_t packetSize_vkGetMemoryFdPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryFdPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryFdPropertiesKHR = OP_vkGetMemoryFdPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_915;
    *&cgen_var_915 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_915, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*streamPtrPtr, (int*)&local_fd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    reservedmarshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties), streamPtrPtr);
    unmarshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    if (pMemoryFdProperties)
    {
        transform_fromhost_VkMemoryFdPropertiesKHR(sResourceTracker, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(sResourceTracker, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_916;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalSemaphoreInfo(sFeatureBits, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), countPtr);
        count_VkExternalSemaphoreProperties(sFeatureBits, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_917;
    *&cgen_var_917 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_917, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), streamPtrPtr);
    reservedmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), streamPtrPtr);
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(sResourceTracker, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
VkResult VkEncoder::vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportSemaphoreWin32HandleInfoKHR* local_pImportSemaphoreWin32HandleInfo;
    local_device = device;
    local_pImportSemaphoreWin32HandleInfo = nullptr;
    if (pImportSemaphoreWin32HandleInfo)
    {
        local_pImportSemaphoreWin32HandleInfo = (VkImportSemaphoreWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
        deepcopy_VkImportSemaphoreWin32HandleInfoKHR(pool, pImportSemaphoreWin32HandleInfo, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    if (local_pImportSemaphoreWin32HandleInfo)
    {
        transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(sResourceTracker, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_918;
        *countPtr += 1 * 8;
        count_VkImportSemaphoreWin32HandleInfoKHR(sFeatureBits, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo), countPtr);
    }
    uint32_t packetSize_vkImportSemaphoreWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportSemaphoreWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportSemaphoreWin32HandleKHR = OP_vkImportSemaphoreWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_919;
    *&cgen_var_919 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_919, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportSemaphoreWin32HandleInfoKHR(stream, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo), streamPtrPtr);
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkSemaphoreGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
        deepcopy_VkSemaphoreGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(sResourceTracker, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_920;
        *countPtr += 1 * 8;
        count_VkSemaphoreGetWin32HandleInfoKHR(sFeatureBits, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), countPtr);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetSemaphoreWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSemaphoreWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSemaphoreWin32HandleKHR = OP_vkGetSemaphoreWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_921;
    *&cgen_var_921 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_921, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreGetWin32HandleInfoKHR(stream, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
VkResult VkEncoder::vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportSemaphoreFdInfoKHR* local_pImportSemaphoreFdInfo;
    local_device = device;
    local_pImportSemaphoreFdInfo = nullptr;
    if (pImportSemaphoreFdInfo)
    {
        local_pImportSemaphoreFdInfo = (VkImportSemaphoreFdInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreFdInfoKHR));
        deepcopy_VkImportSemaphoreFdInfoKHR(pool, pImportSemaphoreFdInfo, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    if (local_pImportSemaphoreFdInfo)
    {
        transform_tohost_VkImportSemaphoreFdInfoKHR(sResourceTracker, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_922;
        *countPtr += 1 * 8;
        count_VkImportSemaphoreFdInfoKHR(sFeatureBits, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo), countPtr);
    }
    uint32_t packetSize_vkImportSemaphoreFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportSemaphoreFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportSemaphoreFdKHR = OP_vkImportSemaphoreFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_923;
    *&cgen_var_923 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_923, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportSemaphoreFdInfoKHR(stream, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo), streamPtrPtr);
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkSemaphoreGetFdInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetFdInfoKHR));
        deepcopy_VkSemaphoreGetFdInfoKHR(pool, pGetFdInfo, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkSemaphoreGetFdInfoKHR(sResourceTracker, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_924;
        *countPtr += 1 * 8;
        count_VkSemaphoreGetFdInfoKHR(sFeatureBits, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo), countPtr);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetSemaphoreFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSemaphoreFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSemaphoreFdKHR = OP_vkGetSemaphoreFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_925;
    *&cgen_var_925 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_925, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreGetFdInfoKHR(stream, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (int*)pFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSemaphoreFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_push_descriptor
void VkEncoder::vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_set = set;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(sResourceTracker, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_926;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_927;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            count_VkWriteDescriptorSet(sFeatureBits, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPushDescriptorSetKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPushDescriptorSetKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPushDescriptorSetKHR = OP_vkCmdPushDescriptorSetKHR;
    memcpy(streamPtr, &opcode_vkCmdPushDescriptorSetKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPushDescriptorSetKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_928;
        *&cgen_var_928 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_928, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_929;
    *&cgen_var_929 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_929, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_set, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        reservedmarshal_VkWriteDescriptorSet(stream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_layout = layout;
    local_set = set;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_930;
        *countPtr += 1 * 8;
        uint64_t cgen_var_931;
        *countPtr += 1 * 8;
        uint64_t cgen_var_932;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pData)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetWithTemplateKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPushDescriptorSetWithTemplateKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPushDescriptorSetWithTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPushDescriptorSetWithTemplateKHR = OP_vkCmdPushDescriptorSetWithTemplateKHR;
    memcpy(streamPtr, &opcode_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_933;
        *&cgen_var_933 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_933, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_934;
    *&cgen_var_934 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_934, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_935;
    *&cgen_var_935 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_935, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_set, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_936 = (uint64_t)(uintptr_t)local_pData;
    memcpy((*streamPtrPtr), &cgen_var_936, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pData)
    {
        memcpy(*streamPtrPtr, (void*)local_pData, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
VkResult VkEncoder::vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(sResourceTracker, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_937;
        *countPtr += 1 * 8;
        count_VkDescriptorUpdateTemplateCreateInfo(sFeatureBits, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_938;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplateKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorUpdateTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorUpdateTemplateKHR = OP_vkCreateDescriptorUpdateTemplateKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_939;
    *&cgen_var_939 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_939, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorUpdateTemplateCreateInfo(stream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_940 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_940, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_941;
    *&cgen_var_941 = (uint64_t)((*pDescriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_941, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_942;
    stream->read((uint64_t*)&cgen_var_942, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_942, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateDescriptorUpdateTemplateKHR(this, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_943;
        *countPtr += 1 * 8;
        uint64_t cgen_var_944;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplateKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorUpdateTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorUpdateTemplateKHR = OP_vkDestroyDescriptorUpdateTemplateKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_945;
    *&cgen_var_945 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_945, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_946;
    *&cgen_var_946 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_946, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_947 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_947, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_948;
        *countPtr += 1 * 8;
        uint64_t cgen_var_949;
        *countPtr += 1 * 8;
        uint64_t cgen_var_950;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pData)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSetWithTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateKHR = OP_vkUpdateDescriptorSetWithTemplateKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_951;
    *&cgen_var_951 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_951, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_952;
    *&cgen_var_952 = get_host_u64_VkDescriptorSet((*&local_descriptorSet));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_952, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_953;
    *&cgen_var_953 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_953, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_954 = (uint64_t)(uintptr_t)local_pData;
    memcpy((*streamPtrPtr), &cgen_var_954, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pData)
    {
        memcpy(*streamPtrPtr, (void*)local_pData, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_create_renderpass2
VkResult VkEncoder::vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2KHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPassCreateInfo2KHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo2KHR*)pool->alloc(sizeof(const VkRenderPassCreateInfo2KHR));
        deepcopy_VkRenderPassCreateInfo2KHR(pool, pCreateInfo, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo2KHR(sResourceTracker, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_955;
        *countPtr += 1 * 8;
        count_VkRenderPassCreateInfo2KHR(sFeatureBits, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_956;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateRenderPass2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRenderPass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRenderPass2KHR = OP_vkCreateRenderPass2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_957;
    *&cgen_var_957 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_957, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRenderPassCreateInfo2KHR(stream, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_958 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_958, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_959;
    *&cgen_var_959 = (uint64_t)((*pRenderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_959, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_960;
    stream->read((uint64_t*)&cgen_var_960, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_960, (VkRenderPass*)pRenderPass, 1);
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRenderPass2KHR_VkResult_return;
}

void VkEncoder::vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassBeginInfoKHR* local_pSubpassBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfoKHR*)pool->alloc(sizeof(const VkSubpassBeginInfoKHR));
        deepcopy_VkSubpassBeginInfoKHR(pool, pSubpassBeginInfo, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(sResourceTracker, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfoKHR(sResourceTracker, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_961;
        *countPtr += 1 * 8;
        count_VkRenderPassBeginInfo(sFeatureBits, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), countPtr);
        count_VkSubpassBeginInfoKHR(sFeatureBits, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo), countPtr);
    }
    uint32_t packetSize_vkCmdBeginRenderPass2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginRenderPass2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginRenderPass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginRenderPass2KHR = OP_vkCmdBeginRenderPass2KHR;
    memcpy(streamPtr, &opcode_vkCmdBeginRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_962;
        *&cgen_var_962 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_962, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkRenderPassBeginInfo(stream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), streamPtrPtr);
    reservedmarshal_VkSubpassBeginInfoKHR(stream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    const VkSubpassEndInfoKHR* pSubpassEndInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassBeginInfoKHR* local_pSubpassBeginInfo;
    VkSubpassEndInfoKHR* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfoKHR*)pool->alloc(sizeof(const VkSubpassBeginInfoKHR));
        deepcopy_VkSubpassBeginInfoKHR(pool, pSubpassBeginInfo, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfoKHR*)pool->alloc(sizeof(const VkSubpassEndInfoKHR));
        deepcopy_VkSubpassEndInfoKHR(pool, pSubpassEndInfo, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfoKHR(sResourceTracker, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfoKHR(sResourceTracker, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_963;
        *countPtr += 1 * 8;
        count_VkSubpassBeginInfoKHR(sFeatureBits, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo), countPtr);
        count_VkSubpassEndInfoKHR(sFeatureBits, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo), countPtr);
    }
    uint32_t packetSize_vkCmdNextSubpass2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdNextSubpass2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdNextSubpass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdNextSubpass2KHR = OP_vkCmdNextSubpass2KHR;
    memcpy(streamPtr, &opcode_vkCmdNextSubpass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdNextSubpass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_964;
        *&cgen_var_964 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_964, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSubpassBeginInfoKHR(stream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo), streamPtrPtr);
    reservedmarshal_VkSubpassEndInfoKHR(stream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfoKHR* pSubpassEndInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassEndInfoKHR* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfoKHR*)pool->alloc(sizeof(const VkSubpassEndInfoKHR));
        deepcopy_VkSubpassEndInfoKHR(pool, pSubpassEndInfo, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfoKHR(sResourceTracker, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_965;
        *countPtr += 1 * 8;
        count_VkSubpassEndInfoKHR(sFeatureBits, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo), countPtr);
    }
    uint32_t packetSize_vkCmdEndRenderPass2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndRenderPass2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndRenderPass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndRenderPass2KHR = OP_vkCmdEndRenderPass2KHR;
    memcpy(streamPtr, &opcode_vkCmdEndRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_966;
        *&cgen_var_966 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_966, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSubpassEndInfoKHR(stream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_shared_presentable_image
VkResult VkEncoder::vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_967;
        *countPtr += 1 * 8;
        uint64_t cgen_var_968;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkGetSwapchainStatusKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainStatusKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainStatusKHR = OP_vkGetSwapchainStatusKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainStatusKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainStatusKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_969;
    *&cgen_var_969 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_969, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_970;
    *&cgen_var_970 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_970, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainStatusKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(sResourceTracker, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_971;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalFenceInfo(sFeatureBits, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), countPtr);
        count_VkExternalFenceProperties(sFeatureBits, (VkExternalFenceProperties*)(pExternalFenceProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR = OP_vkGetPhysicalDeviceExternalFencePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_972;
    *&cgen_var_972 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_972, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalFenceInfo(stream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), streamPtrPtr);
    reservedmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties), streamPtrPtr);
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(sResourceTracker, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
VkResult VkEncoder::vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportFenceWin32HandleInfoKHR* local_pImportFenceWin32HandleInfo;
    local_device = device;
    local_pImportFenceWin32HandleInfo = nullptr;
    if (pImportFenceWin32HandleInfo)
    {
        local_pImportFenceWin32HandleInfo = (VkImportFenceWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportFenceWin32HandleInfoKHR));
        deepcopy_VkImportFenceWin32HandleInfoKHR(pool, pImportFenceWin32HandleInfo, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    if (local_pImportFenceWin32HandleInfo)
    {
        transform_tohost_VkImportFenceWin32HandleInfoKHR(sResourceTracker, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_973;
        *countPtr += 1 * 8;
        count_VkImportFenceWin32HandleInfoKHR(sFeatureBits, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo), countPtr);
    }
    uint32_t packetSize_vkImportFenceWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportFenceWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportFenceWin32HandleKHR = OP_vkImportFenceWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_974;
    *&cgen_var_974 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_974, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportFenceWin32HandleInfoKHR(stream, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo), streamPtrPtr);
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFenceGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkFenceGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkFenceGetWin32HandleInfoKHR));
        deepcopy_VkFenceGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkFenceGetWin32HandleInfoKHR(sResourceTracker, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_975;
        *countPtr += 1 * 8;
        count_VkFenceGetWin32HandleInfoKHR(sFeatureBits, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), countPtr);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetFenceWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetFenceWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetFenceWin32HandleKHR = OP_vkGetFenceWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_976;
    *&cgen_var_976 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_976, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFenceGetWin32HandleInfoKHR(stream, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetFenceWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_fd
VkResult VkEncoder::vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportFenceFdInfoKHR* local_pImportFenceFdInfo;
    local_device = device;
    local_pImportFenceFdInfo = nullptr;
    if (pImportFenceFdInfo)
    {
        local_pImportFenceFdInfo = (VkImportFenceFdInfoKHR*)pool->alloc(sizeof(const VkImportFenceFdInfoKHR));
        deepcopy_VkImportFenceFdInfoKHR(pool, pImportFenceFdInfo, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    if (local_pImportFenceFdInfo)
    {
        transform_tohost_VkImportFenceFdInfoKHR(sResourceTracker, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_977;
        *countPtr += 1 * 8;
        count_VkImportFenceFdInfoKHR(sFeatureBits, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo), countPtr);
    }
    uint32_t packetSize_vkImportFenceFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportFenceFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportFenceFdKHR = OP_vkImportFenceFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_978;
    *&cgen_var_978 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_978, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportFenceFdInfoKHR(stream, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo), streamPtrPtr);
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportFenceFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFenceGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkFenceGetFdInfoKHR*)pool->alloc(sizeof(const VkFenceGetFdInfoKHR));
        deepcopy_VkFenceGetFdInfoKHR(pool, pGetFdInfo, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkFenceGetFdInfoKHR(sResourceTracker, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_979;
        *countPtr += 1 * 8;
        count_VkFenceGetFdInfoKHR(sFeatureBits, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo), countPtr);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetFenceFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetFenceFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetFenceFdKHR = OP_vkGetFenceFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_980;
    *&cgen_var_980 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_980, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFenceGetFdInfoKHR(stream, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (int*)pFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetFenceFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(sResourceTracker, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_981;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSurfaceInfo2KHR(sFeatureBits, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), countPtr);
        count_VkSurfaceCapabilities2KHR(sFeatureBits, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR = OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_982;
    *&cgen_var_982 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_982, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), streamPtrPtr);
    reservedmarshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities), streamPtrPtr);
    unmarshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2KHR(sResourceTracker, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(sResourceTracker, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_983;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSurfaceInfo2KHR(sFeatureBits, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormatCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                count_VkSurfaceFormat2KHR(sFeatureBits, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormats2KHR = OP_vkGetPhysicalDeviceSurfaceFormats2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_984;
    *&cgen_var_984 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_984, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_985 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    memcpy((*streamPtrPtr), &cgen_var_985, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormatCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_986 = (uint64_t)(uintptr_t)pSurfaceFormats;
    memcpy((*streamPtrPtr), &cgen_var_986, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            reservedmarshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormat2KHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            transform_fromhost_VkSurfaceFormat2KHR(sResourceTracker, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
VkResult VkEncoder::vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_989;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkDisplayProperties2KHR(sFeatureBits, (VkDisplayProperties2KHR*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayProperties2KHR = OP_vkGetPhysicalDeviceDisplayProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_990;
    *&cgen_var_990 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_990, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_991 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_991, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_992 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_992, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayProperties2KHR(sResourceTracker, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_995;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkDisplayPlaneProperties2KHR(sFeatureBits, (VkDisplayPlaneProperties2KHR*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_996;
    *&cgen_var_996 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_996, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_997 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_997, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_998 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_998, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlaneProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPlaneProperties2KHR(sResourceTracker, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1001;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1002;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                count_VkDisplayModeProperties2KHR(sFeatureBits, (VkDisplayModeProperties2KHR*)(pProperties + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModeProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayModeProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayModeProperties2KHR = OP_vkGetDisplayModeProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayModeProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayModeProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1003;
    *&cgen_var_1003 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1003, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1004;
    *&cgen_var_1004 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1004, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1005 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1005, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1006 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_1006, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModeProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayModeProperties2KHR(sResourceTracker, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayPlaneInfo2KHR* local_pDisplayPlaneInfo;
    local_physicalDevice = physicalDevice;
    local_pDisplayPlaneInfo = nullptr;
    if (pDisplayPlaneInfo)
    {
        local_pDisplayPlaneInfo = (VkDisplayPlaneInfo2KHR*)pool->alloc(sizeof(const VkDisplayPlaneInfo2KHR));
        deepcopy_VkDisplayPlaneInfo2KHR(pool, pDisplayPlaneInfo, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    if (local_pDisplayPlaneInfo)
    {
        transform_tohost_VkDisplayPlaneInfo2KHR(sResourceTracker, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1009;
        *countPtr += 1 * 8;
        count_VkDisplayPlaneInfo2KHR(sFeatureBits, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo), countPtr);
        count_VkDisplayPlaneCapabilities2KHR(sFeatureBits, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilities2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayPlaneCapabilities2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayPlaneCapabilities2KHR = OP_vkGetDisplayPlaneCapabilities2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1010;
    *&cgen_var_1010 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1010, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayPlaneInfo2KHR(stream, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo), streamPtrPtr);
    reservedmarshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities), streamPtrPtr);
    unmarshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilities2KHR(sResourceTracker, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkEncoder::vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(sResourceTracker, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1011;
        *countPtr += 1 * 8;
        count_VkImageMemoryRequirementsInfo2(sFeatureBits, (VkImageMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageMemoryRequirements2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageMemoryRequirements2KHR = OP_vkGetImageMemoryRequirements2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1012;
    *&cgen_var_1012 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1012, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageMemoryRequirementsInfo2(stream, (VkImageMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(sResourceTracker, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1013;
        *countPtr += 1 * 8;
        count_VkBufferMemoryRequirementsInfo2(sFeatureBits, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferMemoryRequirements2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferMemoryRequirements2KHR = OP_vkGetBufferMemoryRequirements2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1014;
    *&cgen_var_1014 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1014, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferMemoryRequirementsInfo2(stream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(sResourceTracker, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1015;
        *countPtr += 1 * 8;
        count_VkImageSparseMemoryRequirementsInfo2(sFeatureBits, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirementCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                count_VkSparseImageMemoryRequirements2(sFeatureBits, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSparseMemoryRequirements2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSparseMemoryRequirements2KHR = OP_vkGetImageSparseMemoryRequirements2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1016;
    *&cgen_var_1016 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1016, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageSparseMemoryRequirementsInfo2(stream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1017 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    memcpy((*streamPtrPtr), &cgen_var_1017, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirementCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1018 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    memcpy((*streamPtrPtr), &cgen_var_1018, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            reservedmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements2(sResourceTracker, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult VkEncoder::vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(sResourceTracker, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1021;
        *countPtr += 1 * 8;
        count_VkSamplerYcbcrConversionCreateInfo(sFeatureBits, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1022;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversionKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSamplerYcbcrConversionKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSamplerYcbcrConversionKHR = OP_vkCreateSamplerYcbcrConversionKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1023;
    *&cgen_var_1023 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1023, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSamplerYcbcrConversionCreateInfo(stream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1024 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1024, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1025;
    *&cgen_var_1025 = (uint64_t)((*pYcbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1025, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1026;
    stream->read((uint64_t*)&cgen_var_1026, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_1026, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1027;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1028;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversionKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySamplerYcbcrConversionKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySamplerYcbcrConversionKHR = OP_vkDestroySamplerYcbcrConversionKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1029;
    *&cgen_var_1029 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1029, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1030;
    *&cgen_var_1030 = get_host_u64_VkSamplerYcbcrConversion((*&local_ycbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1030, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1031 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1031, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_bind_memory2
VkResult VkEncoder::vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(sResourceTracker, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1032;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindBufferMemoryInfo(sFeatureBits, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindBufferMemory2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindBufferMemory2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindBufferMemory2KHR = OP_vkBindBufferMemory2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindBufferMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindBufferMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1033;
    *&cgen_var_1033 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1033, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindBufferMemoryInfo(stream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindBufferMemory2KHR_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(sResourceTracker, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1034;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindImageMemoryInfo(sFeatureBits, (VkBindImageMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindImageMemory2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindImageMemory2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindImageMemory2KHR = OP_vkBindImageMemory2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindImageMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindImageMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1035;
    *&cgen_var_1035 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1035, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindImageMemoryInfo(stream, (VkBindImageMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindImageMemory2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance3
void VkEncoder::vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(sResourceTracker, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1036;
        *countPtr += 1 * 8;
        count_VkDescriptorSetLayoutCreateInfo(sFeatureBits, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        count_VkDescriptorSetLayoutSupport(sFeatureBits, (VkDescriptorSetLayoutSupport*)(pSupport), countPtr);
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDescriptorSetLayoutSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDescriptorSetLayoutSupportKHR = OP_vkGetDescriptorSetLayoutSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1037;
    *&cgen_var_1037 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1037, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    reservedmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport), streamPtrPtr);
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(sResourceTracker, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1038;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1039;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_1040;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirectCountKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirectCountKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirectCountKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirectCountKHR = OP_vkCmdDrawIndirectCountKHR;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1041;
        *&cgen_var_1041 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1041, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_1042;
    *&cgen_var_1042 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1042, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1043;
    *&cgen_var_1043 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1043, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1044;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1045;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_1046;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirectCountKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirectCountKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirectCountKHR = OP_vkCmdDrawIndexedIndirectCountKHR;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1047;
        *&cgen_var_1047 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1047, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_1048;
    *&cgen_var_1048 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1048, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1049;
    *&cgen_var_1049 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1049, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_ANDROID_native_buffer
VkResult VkEncoder::vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
    VkFormat format,
    VkImageUsageFlags imageUsage,
    int* grallocUsage,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFormat local_format;
    VkImageUsageFlags local_imageUsage;
    local_device = device;
    local_format = format;
    local_imageUsage = imageUsage;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1050;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetSwapchainGrallocUsageANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainGrallocUsageANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainGrallocUsageANDROID = OP_vkGetSwapchainGrallocUsageANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1051;
    *&cgen_var_1051 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1051, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_imageUsage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (int*)grallocUsage, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)grallocUsage, sizeof(int));
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}

VkResult VkEncoder::vkAcquireImageANDROID(
    VkDevice device,
    VkImage image,
    int nativeFenceFd,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    int local_nativeFenceFd;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_image = image;
    local_nativeFenceFd = nativeFenceFd;
    local_semaphore = semaphore;
    local_fence = fence;
    sResourceTracker->unwrap_vkAcquireImageANDROID_nativeFenceFd(nativeFenceFd, &local_nativeFenceFd);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1052;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1053;
        *countPtr += 1 * 8;
        *countPtr += sizeof(int);
        uint64_t cgen_var_1054;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1055;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkAcquireImageANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireImageANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireImageANDROID = OP_vkAcquireImageANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1056;
    *&cgen_var_1056 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1056, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1057;
    *&cgen_var_1057 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1057, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (int*)&local_nativeFenceFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    uint64_t cgen_var_1058;
    *&cgen_var_1058 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1058, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1059;
    *&cgen_var_1059 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1059, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireImageANDROID_VkResult_return;
}

VkResult VkEncoder::vkQueueSignalReleaseImageANDROID(
    VkQueue queue,
    uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores,
    VkImage image,
    int* pNativeFenceFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_waitSemaphoreCount;
    VkSemaphore* local_pWaitSemaphores;
    VkImage local_image;
    local_queue = queue;
    local_waitSemaphoreCount = waitSemaphoreCount;
    // Avoiding deepcopy for pWaitSemaphores
    local_pWaitSemaphores = (VkSemaphore*)pWaitSemaphores;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1060;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pWaitSemaphores)
        {
            if (((waitSemaphoreCount)))
            {
                *countPtr += ((waitSemaphoreCount)) * 8;
            }
        }
        uint64_t cgen_var_1062;
        *countPtr += 1 * 8;
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkQueueSignalReleaseImageANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSignalReleaseImageANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSignalReleaseImageANDROID = OP_vkQueueSignalReleaseImageANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1063;
    *&cgen_var_1063 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1063, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_waitSemaphoreCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1064 = (uint64_t)(uintptr_t)local_pWaitSemaphores;
    memcpy((*streamPtrPtr), &cgen_var_1064, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pWaitSemaphores)
    {
        if (((waitSemaphoreCount)))
        {
            uint8_t* cgen_var_1065_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((waitSemaphoreCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(local_pWaitSemaphores[k]);
                memcpy(cgen_var_1065_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((waitSemaphoreCount));
        }
    }
    uint64_t cgen_var_1066;
    *&cgen_var_1066 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1066, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (int*)pNativeFenceFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pNativeFenceFd, sizeof(int));
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_debug_report
VkResult VkEncoder::vkCreateDebugReportCallbackEXT(
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugReportCallbackCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugReportCallbackCreateInfoEXT*)pool->alloc(sizeof(const VkDebugReportCallbackCreateInfoEXT));
        deepcopy_VkDebugReportCallbackCreateInfoEXT(pool, pCreateInfo, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugReportCallbackCreateInfoEXT(sResourceTracker, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1067;
        *countPtr += 1 * 8;
        count_VkDebugReportCallbackCreateInfoEXT(sFeatureBits, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1068;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDebugReportCallbackEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDebugReportCallbackEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDebugReportCallbackEXT = OP_vkCreateDebugReportCallbackEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1069;
    *&cgen_var_1069 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1069, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugReportCallbackCreateInfoEXT(stream, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1070 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1070, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1071;
    *&cgen_var_1071 = (uint64_t)((*pCallback));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1071, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1072;
    stream->read((uint64_t*)&cgen_var_1072, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_1072, (VkDebugReportCallbackEXT*)pCallback, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDebugReportCallbackEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugReportCallbackEXT local_callback;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_callback = callback;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1073;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1074;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDebugReportCallbackEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDebugReportCallbackEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDebugReportCallbackEXT = OP_vkDestroyDebugReportCallbackEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1075;
    *&cgen_var_1075 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1075, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1076;
    *&cgen_var_1076 = get_host_u64_VkDebugReportCallbackEXT((*&local_callback));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1076, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1077 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1077, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)&callback);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkDebugReportMessageEXT(
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugReportFlagsEXT local_flags;
    VkDebugReportObjectTypeEXT local_objectType;
    uint64_t local_object;
    size_t local_location;
    int32_t local_messageCode;
    char* local_pLayerPrefix;
    char* local_pMessage;
    local_instance = instance;
    local_flags = flags;
    local_objectType = objectType;
    local_object = object;
    local_location = location;
    local_messageCode = messageCode;
    // Avoiding deepcopy for pLayerPrefix
    local_pLayerPrefix = (char*)pLayerPrefix;
    // Avoiding deepcopy for pMessage
    local_pMessage = (char*)pMessage;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1078;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDebugReportFlagsEXT);
        *countPtr += sizeof(VkDebugReportObjectTypeEXT);
        *countPtr += sizeof(uint64_t);
        *countPtr += 8;
        *countPtr += sizeof(int32_t);
        *countPtr += sizeof(uint32_t) + (local_pLayerPrefix ? strlen(local_pLayerPrefix) : 0);
        *countPtr += sizeof(uint32_t) + (local_pMessage ? strlen(local_pMessage) : 0);
    }
    uint32_t packetSize_vkDebugReportMessageEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDebugReportMessageEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDebugReportMessageEXT = OP_vkDebugReportMessageEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDebugReportMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDebugReportMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1079;
    *&cgen_var_1079 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1079, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDebugReportFlagsEXT*)&local_flags, sizeof(VkDebugReportFlagsEXT));
    *streamPtrPtr += sizeof(VkDebugReportFlagsEXT);
    memcpy(*streamPtrPtr, (VkDebugReportObjectTypeEXT*)&local_objectType, sizeof(VkDebugReportObjectTypeEXT));
    *streamPtrPtr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy(*streamPtrPtr, (uint64_t*)&local_object, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    uint64_t cgen_var_1080 = (uint64_t)local_location;
    memcpy((*streamPtrPtr), &cgen_var_1080, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (int32_t*)&local_messageCode, sizeof(int32_t));
    *streamPtrPtr += sizeof(int32_t);
    {
        uint32_t l = local_pLayerPrefix ? strlen(local_pLayerPrefix): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pLayerPrefix, l);
        *streamPtrPtr += l;
    }
    {
        uint32_t l = local_pMessage ? strlen(local_pMessage): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pMessage, l);
        *streamPtrPtr += l;
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
VkResult VkEncoder::vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugMarkerObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugMarkerObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectTagInfoEXT));
        deepcopy_VkDebugMarkerObjectTagInfoEXT(pool, pTagInfo, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugMarkerObjectTagInfoEXT(sResourceTracker, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1081;
        *countPtr += 1 * 8;
        count_VkDebugMarkerObjectTagInfoEXT(sFeatureBits, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo), countPtr);
    }
    uint32_t packetSize_vkDebugMarkerSetObjectTagEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDebugMarkerSetObjectTagEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDebugMarkerSetObjectTagEXT = OP_vkDebugMarkerSetObjectTagEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1082;
    *&cgen_var_1082 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1082, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugMarkerObjectTagInfoEXT(stream, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo), streamPtrPtr);
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult VkEncoder::vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugMarkerObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugMarkerObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectNameInfoEXT));
        deepcopy_VkDebugMarkerObjectNameInfoEXT(pool, pNameInfo, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugMarkerObjectNameInfoEXT(sResourceTracker, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1083;
        *countPtr += 1 * 8;
        count_VkDebugMarkerObjectNameInfoEXT(sFeatureBits, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo), countPtr);
    }
    uint32_t packetSize_vkDebugMarkerSetObjectNameEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDebugMarkerSetObjectNameEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDebugMarkerSetObjectNameEXT = OP_vkDebugMarkerSetObjectNameEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1084;
    *&cgen_var_1084 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1084, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugMarkerObjectNameInfoEXT(stream, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo), streamPtrPtr);
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

void VkEncoder::vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(sResourceTracker, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1085;
        *countPtr += 1 * 8;
        count_VkDebugMarkerMarkerInfoEXT(sFeatureBits, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), countPtr);
    }
    uint32_t packetSize_vkCmdDebugMarkerBeginEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDebugMarkerBeginEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDebugMarkerBeginEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDebugMarkerBeginEXT = OP_vkCmdDebugMarkerBeginEXT;
    memcpy(streamPtr, &opcode_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1086;
        *&cgen_var_1086 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1086, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugMarkerMarkerInfoEXT(stream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1087;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdDebugMarkerEndEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDebugMarkerEndEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDebugMarkerEndEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDebugMarkerEndEXT = OP_vkCmdDebugMarkerEndEXT;
    memcpy(streamPtr, &opcode_vkCmdDebugMarkerEndEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDebugMarkerEndEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1088;
        *&cgen_var_1088 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1088, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(sResourceTracker, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1089;
        *countPtr += 1 * 8;
        count_VkDebugMarkerMarkerInfoEXT(sFeatureBits, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), countPtr);
    }
    uint32_t packetSize_vkCmdDebugMarkerInsertEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDebugMarkerInsertEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDebugMarkerInsertEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDebugMarkerInsertEXT = OP_vkCmdDebugMarkerInsertEXT;
    memcpy(streamPtr, &opcode_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1090;
        *&cgen_var_1090 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1090, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugMarkerMarkerInfoEXT(stream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1091;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1092;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_1093;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirectCountAMD = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirectCountAMD -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirectCountAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirectCountAMD = OP_vkCmdDrawIndirectCountAMD;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1094;
        *&cgen_var_1094 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1094, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_1095;
    *&cgen_var_1095 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1095, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1096;
    *&cgen_var_1096 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1096, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1097;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1098;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_1099;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountAMD = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirectCountAMD -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirectCountAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirectCountAMD = OP_vkCmdDrawIndexedIndirectCountAMD;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1100;
        *&cgen_var_1100 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1100, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_1101;
    *&cgen_var_1101 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1101, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1102;
    *&cgen_var_1102 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1102, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
VkResult VkEncoder::vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkShaderStageFlagBits local_shaderStage;
    VkShaderInfoTypeAMD local_infoType;
    local_device = device;
    local_pipeline = pipeline;
    local_shaderStage = shaderStage;
    local_infoType = infoType;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1103;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1104;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkShaderStageFlagBits);
        *countPtr += sizeof(VkShaderInfoTypeAMD);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pInfoSize)
        {
            *countPtr += 8;
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pInfo)
        {
            *countPtr += (*(pInfoSize)) * sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkGetShaderInfoAMD = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetShaderInfoAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetShaderInfoAMD = OP_vkGetShaderInfoAMD;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetShaderInfoAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetShaderInfoAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1105;
    *&cgen_var_1105 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1105, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1106;
    *&cgen_var_1106 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1106, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkShaderStageFlagBits*)&local_shaderStage, sizeof(VkShaderStageFlagBits));
    *streamPtrPtr += sizeof(VkShaderStageFlagBits);
    memcpy(*streamPtrPtr, (VkShaderInfoTypeAMD*)&local_infoType, sizeof(VkShaderInfoTypeAMD));
    *streamPtrPtr += sizeof(VkShaderInfoTypeAMD);
    // WARNING PTR CHECK
    uint64_t cgen_var_1107 = (uint64_t)(uintptr_t)pInfoSize;
    memcpy((*streamPtrPtr), &cgen_var_1107, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pInfoSize)
    {
        uint64_t cgen_var_1108 = (uint64_t)(*pInfoSize);
        memcpy((*streamPtrPtr), &cgen_var_1108, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1109 = (uint64_t)(uintptr_t)pInfo;
    memcpy((*streamPtrPtr), &cgen_var_1109, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pInfo)
    {
        memcpy(*streamPtrPtr, (void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
        *streamPtrPtr += (*(pInfoSize)) * sizeof(uint8_t);
    }
    // WARNING PTR CHECK
    size_t* check_pInfoSize;
    check_pInfoSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pInfoSize)
    {
        if (!(check_pInfoSize))
        {
            fprintf(stderr, "fatal: pInfoSize inconsistent between guest and host\n");
        }
        (*pInfoSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pInfo;
    check_pInfo = (void*)(uintptr_t)stream->getBe64();
    if (pInfo)
    {
        if (!(check_pInfo))
        {
            fprintf(stderr, "fatal: pInfo inconsistent between guest and host\n");
        }
        stream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    stream->read(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetShaderInfoAMD_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
VkResult VkEncoder::vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    VkExternalMemoryHandleTypeFlagsNV local_externalHandleType;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    local_externalHandleType = externalHandleType;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1113;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageType);
        *countPtr += sizeof(VkImageTiling);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(VkImageCreateFlags);
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
        count_VkExternalImageFormatPropertiesNV(sFeatureBits, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1114;
    *&cgen_var_1114 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1114, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageType*)&local_type, sizeof(VkImageType));
    *streamPtrPtr += sizeof(VkImageType);
    memcpy(*streamPtrPtr, (VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    *streamPtrPtr += sizeof(VkImageTiling);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    *streamPtrPtr += sizeof(VkImageCreateFlags);
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagsNV*)&local_externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    reservedmarshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties), streamPtrPtr);
    unmarshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    if (pExternalImageFormatProperties)
    {
        transform_fromhost_VkExternalImageFormatPropertiesNV(sResourceTracker, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkExternalMemoryHandleTypeFlagsNV local_handleType;
    local_device = device;
    local_memory = memory;
    local_handleType = handleType;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1115;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1116;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetMemoryWin32HandleNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryWin32HandleNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryWin32HandleNV = OP_vkGetMemoryWin32HandleNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryWin32HandleNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryWin32HandleNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1117;
    *&cgen_var_1117 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1117, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1118;
    *&cgen_var_1118 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1118, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagsNV*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryWin32HandleNV_VkResult_return;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
VkResult VkEncoder::vkCreateViSurfaceNN(
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkViSurfaceCreateInfoNN* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkViSurfaceCreateInfoNN*)pool->alloc(sizeof(const VkViSurfaceCreateInfoNN));
        deepcopy_VkViSurfaceCreateInfoNN(pool, pCreateInfo, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkViSurfaceCreateInfoNN(sResourceTracker, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1119;
        *countPtr += 1 * 8;
        count_VkViSurfaceCreateInfoNN(sFeatureBits, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1120;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateViSurfaceNN = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateViSurfaceNN);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateViSurfaceNN = OP_vkCreateViSurfaceNN;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateViSurfaceNN, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateViSurfaceNN, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1121;
    *&cgen_var_1121 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1121, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkViSurfaceCreateInfoNN(stream, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1122 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1122, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1123;
    *&cgen_var_1123 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1123, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_1124;
    stream->read((uint64_t*)&cgen_var_1124, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1124, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
    stream->read(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateViSurfaceNN_VkResult_return;
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void VkEncoder::vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkConditionalRenderingBeginInfoEXT* local_pConditionalRenderingBegin;
    local_commandBuffer = commandBuffer;
    local_pConditionalRenderingBegin = nullptr;
    if (pConditionalRenderingBegin)
    {
        local_pConditionalRenderingBegin = (VkConditionalRenderingBeginInfoEXT*)pool->alloc(sizeof(const VkConditionalRenderingBeginInfoEXT));
        deepcopy_VkConditionalRenderingBeginInfoEXT(pool, pConditionalRenderingBegin, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    if (local_pConditionalRenderingBegin)
    {
        transform_tohost_VkConditionalRenderingBeginInfoEXT(sResourceTracker, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1125;
        *countPtr += 1 * 8;
        count_VkConditionalRenderingBeginInfoEXT(sFeatureBits, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin), countPtr);
    }
    uint32_t packetSize_vkCmdBeginConditionalRenderingEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginConditionalRenderingEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginConditionalRenderingEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginConditionalRenderingEXT = OP_vkCmdBeginConditionalRenderingEXT;
    memcpy(streamPtr, &opcode_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1126;
        *&cgen_var_1126 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1126, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkConditionalRenderingBeginInfoEXT(stream, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1127;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdEndConditionalRenderingEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndConditionalRenderingEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndConditionalRenderingEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndConditionalRenderingEXT = OP_vkCmdEndConditionalRenderingEXT;
    memcpy(streamPtr, &opcode_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1128;
        *&cgen_var_1128 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1128, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NVX_device_generated_commands
void VkEncoder::vkCmdProcessCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCmdProcessCommandsInfoNVX* local_pProcessCommandsInfo;
    local_commandBuffer = commandBuffer;
    local_pProcessCommandsInfo = nullptr;
    if (pProcessCommandsInfo)
    {
        local_pProcessCommandsInfo = (VkCmdProcessCommandsInfoNVX*)pool->alloc(sizeof(const VkCmdProcessCommandsInfoNVX));
        deepcopy_VkCmdProcessCommandsInfoNVX(pool, pProcessCommandsInfo, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    if (local_pProcessCommandsInfo)
    {
        transform_tohost_VkCmdProcessCommandsInfoNVX(sResourceTracker, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1129;
        *countPtr += 1 * 8;
        count_VkCmdProcessCommandsInfoNVX(sFeatureBits, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo), countPtr);
    }
    uint32_t packetSize_vkCmdProcessCommandsNVX = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdProcessCommandsNVX -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdProcessCommandsNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdProcessCommandsNVX = OP_vkCmdProcessCommandsNVX;
    memcpy(streamPtr, &opcode_vkCmdProcessCommandsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdProcessCommandsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1130;
        *&cgen_var_1130 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1130, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCmdProcessCommandsInfoNVX(stream, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCmdReserveSpaceForCommandsInfoNVX* local_pReserveSpaceInfo;
    local_commandBuffer = commandBuffer;
    local_pReserveSpaceInfo = nullptr;
    if (pReserveSpaceInfo)
    {
        local_pReserveSpaceInfo = (VkCmdReserveSpaceForCommandsInfoNVX*)pool->alloc(sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
        deepcopy_VkCmdReserveSpaceForCommandsInfoNVX(pool, pReserveSpaceInfo, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    if (local_pReserveSpaceInfo)
    {
        transform_tohost_VkCmdReserveSpaceForCommandsInfoNVX(sResourceTracker, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1131;
        *countPtr += 1 * 8;
        count_VkCmdReserveSpaceForCommandsInfoNVX(sFeatureBits, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo), countPtr);
    }
    uint32_t packetSize_vkCmdReserveSpaceForCommandsNVX = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdReserveSpaceForCommandsNVX -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdReserveSpaceForCommandsNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdReserveSpaceForCommandsNVX = OP_vkCmdReserveSpaceForCommandsNVX;
    memcpy(streamPtr, &opcode_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1132;
        *&cgen_var_1132 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1132, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCmdReserveSpaceForCommandsInfoNVX(stream, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateIndirectCommandsLayoutNVX(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkIndirectCommandsLayoutCreateInfoNVX* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIndirectCommandsLayoutCreateInfoNVX*)pool->alloc(sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
        deepcopy_VkIndirectCommandsLayoutCreateInfoNVX(pool, pCreateInfo, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIndirectCommandsLayoutCreateInfoNVX(sResourceTracker, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1133;
        *countPtr += 1 * 8;
        count_VkIndirectCommandsLayoutCreateInfoNVX(sFeatureBits, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1134;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateIndirectCommandsLayoutNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateIndirectCommandsLayoutNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateIndirectCommandsLayoutNVX = OP_vkCreateIndirectCommandsLayoutNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1135;
    *&cgen_var_1135 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1135, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkIndirectCommandsLayoutCreateInfoNVX(stream, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1136 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1136, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1137;
    *&cgen_var_1137 = (uint64_t)((*pIndirectCommandsLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1137, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1138;
    stream->read((uint64_t*)&cgen_var_1138, 8);
    stream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_1138, (VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateIndirectCommandsLayoutNVX_VkResult_return;
}

void VkEncoder::vkDestroyIndirectCommandsLayoutNVX(
    VkDevice device,
    VkIndirectCommandsLayoutNVX indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkIndirectCommandsLayoutNVX local_indirectCommandsLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_indirectCommandsLayout = indirectCommandsLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1139;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1140;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyIndirectCommandsLayoutNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyIndirectCommandsLayoutNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyIndirectCommandsLayoutNVX = OP_vkDestroyIndirectCommandsLayoutNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1141;
    *&cgen_var_1141 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1141, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1142;
    *&cgen_var_1142 = get_host_u64_VkIndirectCommandsLayoutNVX((*&local_indirectCommandsLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1142, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1143 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1143, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateObjectTableNVX(
    VkDevice device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkObjectTableCreateInfoNVX* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkObjectTableCreateInfoNVX*)pool->alloc(sizeof(const VkObjectTableCreateInfoNVX));
        deepcopy_VkObjectTableCreateInfoNVX(pool, pCreateInfo, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkObjectTableCreateInfoNVX(sResourceTracker, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1144;
        *countPtr += 1 * 8;
        count_VkObjectTableCreateInfoNVX(sFeatureBits, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1145;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateObjectTableNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateObjectTableNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateObjectTableNVX = OP_vkCreateObjectTableNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateObjectTableNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateObjectTableNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1146;
    *&cgen_var_1146 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1146, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkObjectTableCreateInfoNVX(stream, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1147 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1147, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1148;
    *&cgen_var_1148 = (uint64_t)((*pObjectTable));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1148, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1149;
    stream->read((uint64_t*)&cgen_var_1149, 8);
    stream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_1149, (VkObjectTableNVX*)pObjectTable, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateObjectTableNVX_VkResult_return;
}

void VkEncoder::vkDestroyObjectTableNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_objectTable = objectTable;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1150;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1151;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyObjectTableNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyObjectTableNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyObjectTableNVX = OP_vkDestroyObjectTableNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyObjectTableNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyObjectTableNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1152;
    *&cgen_var_1152 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1152, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1153;
    *&cgen_var_1153 = get_host_u64_VkObjectTableNVX((*&local_objectTable));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1153, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1154 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1154, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkObjectTableNVX((VkObjectTableNVX*)&objectTable);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkRegisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    uint32_t local_objectCount;
    VkObjectTableEntryNVX** local_ppObjectTableEntries;
    uint32_t* local_pObjectIndices;
    local_device = device;
    local_objectTable = objectTable;
    local_objectCount = objectCount;
    (void)ppObjectTableEntries;
    // Avoiding deepcopy for pObjectIndices
    local_pObjectIndices = (uint32_t*)pObjectIndices;
    (void)local_ppObjectTableEntries;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1155;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1156;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        (void)local_ppObjectTableEntries;
        *countPtr += ((objectCount)) * sizeof(uint32_t);
    }
    uint32_t packetSize_vkRegisterObjectsNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterObjectsNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterObjectsNVX = OP_vkRegisterObjectsNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterObjectsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterObjectsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1157;
    *&cgen_var_1157 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1157, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1158;
    *&cgen_var_1158 = get_host_u64_VkObjectTableNVX((*&local_objectTable));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1158, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_objectCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    (void)local_ppObjectTableEntries;
    memcpy(*streamPtrPtr, (uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((objectCount)) * sizeof(uint32_t);
    VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterObjectsNVX_VkResult_return;
}

VkResult VkEncoder::vkUnregisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    uint32_t local_objectCount;
    VkObjectEntryTypeNVX* local_pObjectEntryTypes;
    uint32_t* local_pObjectIndices;
    local_device = device;
    local_objectTable = objectTable;
    local_objectCount = objectCount;
    // Avoiding deepcopy for pObjectEntryTypes
    local_pObjectEntryTypes = (VkObjectEntryTypeNVX*)pObjectEntryTypes;
    // Avoiding deepcopy for pObjectIndices
    local_pObjectIndices = (uint32_t*)pObjectIndices;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1159;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1160;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += ((objectCount)) * sizeof(VkObjectEntryTypeNVX);
        *countPtr += ((objectCount)) * sizeof(uint32_t);
    }
    uint32_t packetSize_vkUnregisterObjectsNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUnregisterObjectsNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUnregisterObjectsNVX = OP_vkUnregisterObjectsNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUnregisterObjectsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUnregisterObjectsNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1161;
    *&cgen_var_1161 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1161, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1162;
    *&cgen_var_1162 = get_host_u64_VkObjectTableNVX((*&local_objectTable));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1162, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_objectCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkObjectEntryTypeNVX*)local_pObjectEntryTypes, ((objectCount)) * sizeof(VkObjectEntryTypeNVX));
    *streamPtrPtr += ((objectCount)) * sizeof(VkObjectEntryTypeNVX);
    memcpy(*streamPtrPtr, (uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((objectCount)) * sizeof(uint32_t);
    VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkUnregisterObjectsNVX_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1163;
        *countPtr += 1 * 8;
        count_VkDeviceGeneratedCommandsFeaturesNVX(sFeatureBits, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures), countPtr);
        count_VkDeviceGeneratedCommandsLimitsNVX(sFeatureBits, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1164;
    *&cgen_var_1164 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1164, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures), streamPtrPtr);
    reservedmarshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits), streamPtrPtr);
    unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkDeviceGeneratedCommandsFeaturesNVX(sResourceTracker, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    }
    unmarshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    if (pLimits)
    {
        transform_fromhost_VkDeviceGeneratedCommandsLimitsNVX(sResourceTracker, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void VkEncoder::vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewportWScalingNV* local_pViewportWScalings;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewportWScalings = nullptr;
    if (pViewportWScalings)
    {
        local_pViewportWScalings = (VkViewportWScalingNV*)pool->alloc(((viewportCount)) * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewportWScalingNV(pool, pViewportWScalings + i, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    if (local_pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewportWScalingNV(sResourceTracker, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1165;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            count_VkViewportWScalingNV(sFeatureBits, (VkViewportWScalingNV*)(local_pViewportWScalings + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetViewportWScalingNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetViewportWScalingNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetViewportWScalingNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetViewportWScalingNV = OP_vkCmdSetViewportWScalingNV;
    memcpy(streamPtr, &opcode_vkCmdSetViewportWScalingNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetViewportWScalingNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1166;
        *&cgen_var_1166 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1166, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstViewport, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_viewportCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        reservedmarshal_VkViewportWScalingNV(stream, (VkViewportWScalingNV*)(local_pViewportWScalings + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_direct_mode_display
VkResult VkEncoder::vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1167;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1168;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkReleaseDisplayEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkReleaseDisplayEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkReleaseDisplayEXT = OP_vkReleaseDisplayEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkReleaseDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkReleaseDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1169;
    *&cgen_var_1169 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1169, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1170;
    *&cgen_var_1170 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1170, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkReleaseDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_acquire_xlib_display
VkResult VkEncoder::vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1171;
        *countPtr += 1 * 8;
        *countPtr += sizeof(Display);
        uint64_t cgen_var_1172;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkAcquireXlibDisplayEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireXlibDisplayEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireXlibDisplayEXT = OP_vkAcquireXlibDisplayEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireXlibDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireXlibDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1173;
    *&cgen_var_1173 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1173, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (Display*)dpy, sizeof(Display));
    *streamPtrPtr += sizeof(Display);
    uint64_t cgen_var_1174;
    *&cgen_var_1174 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1174, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->read((Display*)dpy, sizeof(Display));
    VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult VkEncoder::vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    RROutput local_rrOutput;
    local_physicalDevice = physicalDevice;
    local_rrOutput = rrOutput;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1175;
        *countPtr += 1 * 8;
        *countPtr += sizeof(Display);
        *countPtr += sizeof(RROutput);
        uint64_t cgen_var_1176;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetRandROutputDisplayEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRandROutputDisplayEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRandROutputDisplayEXT = OP_vkGetRandROutputDisplayEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRandROutputDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRandROutputDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1177;
    *&cgen_var_1177 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1177, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (Display*)dpy, sizeof(Display));
    *streamPtrPtr += sizeof(Display);
    memcpy(*streamPtrPtr, (RROutput*)&local_rrOutput, sizeof(RROutput));
    *streamPtrPtr += sizeof(RROutput);
    /* is handle, possibly out */;
    uint64_t cgen_var_1178;
    *&cgen_var_1178 = (uint64_t)((*pDisplay));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1178, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->read((Display*)dpy, sizeof(Display));
    uint64_t cgen_var_1179;
    stream->read((uint64_t*)&cgen_var_1179, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_1179, (VkDisplayKHR*)pDisplay, 1);
    VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRandROutputDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_surface_counter
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1180;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1181;
        *countPtr += 1 * 8;
        count_VkSurfaceCapabilities2EXT(sFeatureBits, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT = OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1182;
    *&cgen_var_1182 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1182, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1183;
    *&cgen_var_1183 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1183, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities), streamPtrPtr);
    unmarshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2EXT(sResourceTracker, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_control
VkResult VkEncoder::vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayPowerInfoEXT* local_pDisplayPowerInfo;
    local_device = device;
    local_display = display;
    local_pDisplayPowerInfo = nullptr;
    if (pDisplayPowerInfo)
    {
        local_pDisplayPowerInfo = (VkDisplayPowerInfoEXT*)pool->alloc(sizeof(const VkDisplayPowerInfoEXT));
        deepcopy_VkDisplayPowerInfoEXT(pool, pDisplayPowerInfo, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    if (local_pDisplayPowerInfo)
    {
        transform_tohost_VkDisplayPowerInfoEXT(sResourceTracker, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1184;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1185;
        *countPtr += 1 * 8;
        count_VkDisplayPowerInfoEXT(sFeatureBits, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo), countPtr);
    }
    uint32_t packetSize_vkDisplayPowerControlEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDisplayPowerControlEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDisplayPowerControlEXT = OP_vkDisplayPowerControlEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDisplayPowerControlEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDisplayPowerControlEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1186;
    *&cgen_var_1186 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1186, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1187;
    *&cgen_var_1187 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1187, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayPowerInfoEXT(stream, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo), streamPtrPtr);
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDisplayPowerControlEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceEventInfoEXT* local_pDeviceEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pDeviceEventInfo = nullptr;
    if (pDeviceEventInfo)
    {
        local_pDeviceEventInfo = (VkDeviceEventInfoEXT*)pool->alloc(sizeof(const VkDeviceEventInfoEXT));
        deepcopy_VkDeviceEventInfoEXT(pool, pDeviceEventInfo, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDeviceEventInfo)
    {
        transform_tohost_VkDeviceEventInfoEXT(sResourceTracker, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1188;
        *countPtr += 1 * 8;
        count_VkDeviceEventInfoEXT(sFeatureBits, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1189;
        *countPtr += 8;
    }
    uint32_t packetSize_vkRegisterDeviceEventEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterDeviceEventEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterDeviceEventEXT = OP_vkRegisterDeviceEventEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterDeviceEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterDeviceEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1190;
    *&cgen_var_1190 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1190, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceEventInfoEXT(stream, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1191 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1191, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1192;
    *&cgen_var_1192 = (uint64_t)((*pFence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1192, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_1193;
    stream->read((uint64_t*)&cgen_var_1193, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_1193, (VkFence*)pFence, 1);
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayEventInfoEXT* local_pDisplayEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_display = display;
    local_pDisplayEventInfo = nullptr;
    if (pDisplayEventInfo)
    {
        local_pDisplayEventInfo = (VkDisplayEventInfoEXT*)pool->alloc(sizeof(const VkDisplayEventInfoEXT));
        deepcopy_VkDisplayEventInfoEXT(pool, pDisplayEventInfo, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDisplayEventInfo)
    {
        transform_tohost_VkDisplayEventInfoEXT(sResourceTracker, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1194;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1195;
        *countPtr += 1 * 8;
        count_VkDisplayEventInfoEXT(sFeatureBits, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1196;
        *countPtr += 8;
    }
    uint32_t packetSize_vkRegisterDisplayEventEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterDisplayEventEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterDisplayEventEXT = OP_vkRegisterDisplayEventEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterDisplayEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterDisplayEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1197;
    *&cgen_var_1197 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1197, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1198;
    *&cgen_var_1198 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1198, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayEventInfoEXT(stream, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1199 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1199, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1200;
    *&cgen_var_1200 = (uint64_t)((*pFence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1200, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_1201;
    stream->read((uint64_t*)&cgen_var_1201, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_1201, (VkFence*)pFence, 1);
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult VkEncoder::vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkSurfaceCounterFlagBitsEXT local_counter;
    local_device = device;
    local_swapchain = swapchain;
    local_counter = counter;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1202;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1203;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkSurfaceCounterFlagBitsEXT);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkGetSwapchainCounterEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainCounterEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainCounterEXT = OP_vkGetSwapchainCounterEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainCounterEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainCounterEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1204;
    *&cgen_var_1204 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1204, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1205;
    *&cgen_var_1205 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1205, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkSurfaceCounterFlagBitsEXT*)&local_counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    *streamPtrPtr += sizeof(VkSurfaceCounterFlagBitsEXT);
    memcpy(*streamPtrPtr, (uint64_t*)pCounterValue, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    stream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainCounterEXT_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_display_timing
VkResult VkEncoder::vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1206;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1207;
        *countPtr += 1 * 8;
        count_VkRefreshCycleDurationGOOGLE(sFeatureBits, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties), countPtr);
    }
    uint32_t packetSize_vkGetRefreshCycleDurationGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRefreshCycleDurationGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRefreshCycleDurationGOOGLE = OP_vkGetRefreshCycleDurationGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1208;
    *&cgen_var_1208 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1208, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1209;
    *&cgen_var_1209 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1209, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties), streamPtrPtr);
    unmarshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    if (pDisplayTimingProperties)
    {
        transform_fromhost_VkRefreshCycleDurationGOOGLE(sResourceTracker, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1210;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1211;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentationTimingCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentationTimings)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
            {
                count_VkPastPresentationTimingGOOGLE(sFeatureBits, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetPastPresentationTimingGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPastPresentationTimingGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPastPresentationTimingGOOGLE = OP_vkGetPastPresentationTimingGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1212;
    *&cgen_var_1212 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1212, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1213;
    *&cgen_var_1213 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1213, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1214 = (uint64_t)(uintptr_t)pPresentationTimingCount;
    memcpy((*streamPtrPtr), &cgen_var_1214, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentationTimingCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1215 = (uint64_t)(uintptr_t)pPresentationTimings;
    memcpy((*streamPtrPtr), &cgen_var_1215, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            reservedmarshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentationTimingCount;
    check_pPresentationTimingCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentationTimingCount)
    {
        if (!(check_pPresentationTimingCount))
        {
            fprintf(stderr, "fatal: pPresentationTimingCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPastPresentationTimingGOOGLE* check_pPresentationTimings;
    check_pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)stream->getBe64();
    if (pPresentationTimings)
    {
        if (!(check_pPresentationTimings))
        {
            fprintf(stderr, "fatal: pPresentationTimings inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            unmarshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            transform_fromhost_VkPastPresentationTimingGOOGLE(sResourceTracker, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
void VkEncoder::vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstDiscardRectangle;
    uint32_t local_discardRectangleCount;
    VkRect2D* local_pDiscardRectangles;
    local_commandBuffer = commandBuffer;
    local_firstDiscardRectangle = firstDiscardRectangle;
    local_discardRectangleCount = discardRectangleCount;
    local_pDiscardRectangles = nullptr;
    if (pDiscardRectangles)
    {
        local_pDiscardRectangles = (VkRect2D*)pool->alloc(((discardRectangleCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            deepcopy_VkRect2D(pool, pDiscardRectangles + i, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    if (local_pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            transform_tohost_VkRect2D(sResourceTracker, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1218;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            count_VkRect2D(sFeatureBits, (VkRect2D*)(local_pDiscardRectangles + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetDiscardRectangleEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDiscardRectangleEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDiscardRectangleEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDiscardRectangleEXT = OP_vkCmdSetDiscardRectangleEXT;
    memcpy(streamPtr, &opcode_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1219;
        *&cgen_var_1219 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1219, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstDiscardRectangle, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_discardRectangleCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        reservedmarshal_VkRect2D(stream, (VkRect2D*)(local_pDiscardRectangles + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void VkEncoder::vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainKHR* local_pSwapchains;
    VkHdrMetadataEXT* local_pMetadata;
    local_device = device;
    local_swapchainCount = swapchainCount;
    // Avoiding deepcopy for pSwapchains
    local_pSwapchains = (VkSwapchainKHR*)pSwapchains;
    local_pMetadata = nullptr;
    if (pMetadata)
    {
        local_pMetadata = (VkHdrMetadataEXT*)pool->alloc(((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkHdrMetadataEXT(pool, pMetadata + i, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    if (local_pMetadata)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkHdrMetadataEXT(sResourceTracker, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1220;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((swapchainCount)))
        {
            *countPtr += ((swapchainCount)) * 8;
        }
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            count_VkHdrMetadataEXT(sFeatureBits, (VkHdrMetadataEXT*)(local_pMetadata + i), countPtr);
        }
    }
    uint32_t packetSize_vkSetHdrMetadataEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetHdrMetadataEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetHdrMetadataEXT = OP_vkSetHdrMetadataEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetHdrMetadataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetHdrMetadataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1222;
    *&cgen_var_1222 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1222, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((swapchainCount)))
    {
        uint8_t* cgen_var_1223_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((swapchainCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkSwapchainKHR(local_pSwapchains[k]);
            memcpy(cgen_var_1223_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((swapchainCount));
    }
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        reservedmarshal_VkHdrMetadataEXT(stream, (VkHdrMetadataEXT*)(local_pMetadata + i), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_MVK_ios_surface
VkResult VkEncoder::vkCreateIOSSurfaceMVK(
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkIOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkIOSSurfaceCreateInfoMVK));
        deepcopy_VkIOSSurfaceCreateInfoMVK(pool, pCreateInfo, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIOSSurfaceCreateInfoMVK(sResourceTracker, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1224;
        *countPtr += 1 * 8;
        count_VkIOSSurfaceCreateInfoMVK(sFeatureBits, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1225;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateIOSSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateIOSSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateIOSSurfaceMVK = OP_vkCreateIOSSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateIOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateIOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1226;
    *&cgen_var_1226 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1226, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkIOSSurfaceCreateInfoMVK(stream, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1227 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1227, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1228;
    *&cgen_var_1228 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1228, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_1229;
    stream->read((uint64_t*)&cgen_var_1229, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1229, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateIOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_macos_surface
VkResult VkEncoder::vkCreateMacOSSurfaceMVK(
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkMacOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMacOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkMacOSSurfaceCreateInfoMVK));
        deepcopy_VkMacOSSurfaceCreateInfoMVK(pool, pCreateInfo, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMacOSSurfaceCreateInfoMVK(sResourceTracker, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1230;
        *countPtr += 1 * 8;
        count_VkMacOSSurfaceCreateInfoMVK(sFeatureBits, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1231;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateMacOSSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateMacOSSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateMacOSSurfaceMVK = OP_vkCreateMacOSSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateMacOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateMacOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1232;
    *&cgen_var_1232 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1232, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMacOSSurfaceCreateInfoMVK(stream, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1233 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1233, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1234;
    *&cgen_var_1234 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1234, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_1235;
    stream->read((uint64_t*)&cgen_var_1235, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1235, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateMacOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
VkResult VkEncoder::vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugUtilsObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugUtilsObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectNameInfoEXT));
        deepcopy_VkDebugUtilsObjectNameInfoEXT(pool, pNameInfo, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugUtilsObjectNameInfoEXT(sResourceTracker, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1236;
        *countPtr += 1 * 8;
        count_VkDebugUtilsObjectNameInfoEXT(sFeatureBits, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo), countPtr);
    }
    uint32_t packetSize_vkSetDebugUtilsObjectNameEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetDebugUtilsObjectNameEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetDebugUtilsObjectNameEXT = OP_vkSetDebugUtilsObjectNameEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1237;
    *&cgen_var_1237 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1237, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsObjectNameInfoEXT(stream, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo), streamPtrPtr);
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult VkEncoder::vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugUtilsObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugUtilsObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectTagInfoEXT));
        deepcopy_VkDebugUtilsObjectTagInfoEXT(pool, pTagInfo, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugUtilsObjectTagInfoEXT(sResourceTracker, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1238;
        *countPtr += 1 * 8;
        count_VkDebugUtilsObjectTagInfoEXT(sFeatureBits, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo), countPtr);
    }
    uint32_t packetSize_vkSetDebugUtilsObjectTagEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetDebugUtilsObjectTagEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetDebugUtilsObjectTagEXT = OP_vkSetDebugUtilsObjectTagEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1239;
    *&cgen_var_1239 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1239, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsObjectTagInfoEXT(stream, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo), streamPtrPtr);
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

void VkEncoder::vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1240;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkQueueBeginDebugUtilsLabelEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueBeginDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueBeginDebugUtilsLabelEXT = OP_vkQueueBeginDebugUtilsLabelEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1241;
    *&cgen_var_1241 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1241, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1242;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueEndDebugUtilsLabelEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueEndDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueEndDebugUtilsLabelEXT = OP_vkQueueEndDebugUtilsLabelEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1243;
    *&cgen_var_1243 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1243, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1244;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkQueueInsertDebugUtilsLabelEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueInsertDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueInsertDebugUtilsLabelEXT = OP_vkQueueInsertDebugUtilsLabelEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1245;
    *&cgen_var_1245 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1245, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1246;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkCmdBeginDebugUtilsLabelEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginDebugUtilsLabelEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginDebugUtilsLabelEXT = OP_vkCmdBeginDebugUtilsLabelEXT;
    memcpy(streamPtr, &opcode_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1247;
        *&cgen_var_1247 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1247, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1248;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdEndDebugUtilsLabelEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndDebugUtilsLabelEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndDebugUtilsLabelEXT = OP_vkCmdEndDebugUtilsLabelEXT;
    memcpy(streamPtr, &opcode_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1249;
        *&cgen_var_1249 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1249, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1250;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkCmdInsertDebugUtilsLabelEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdInsertDebugUtilsLabelEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdInsertDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdInsertDebugUtilsLabelEXT = OP_vkCmdInsertDebugUtilsLabelEXT;
    memcpy(streamPtr, &opcode_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1251;
        *&cgen_var_1251 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1251, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugUtilsMessengerCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugUtilsMessengerCreateInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
        deepcopy_VkDebugUtilsMessengerCreateInfoEXT(pool, pCreateInfo, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(sResourceTracker, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1252;
        *countPtr += 1 * 8;
        count_VkDebugUtilsMessengerCreateInfoEXT(sFeatureBits, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1253;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDebugUtilsMessengerEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDebugUtilsMessengerEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDebugUtilsMessengerEXT = OP_vkCreateDebugUtilsMessengerEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1254;
    *&cgen_var_1254 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1254, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsMessengerCreateInfoEXT(stream, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1255 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1255, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1256;
    *&cgen_var_1256 = (uint64_t)((*pMessenger));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1256, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1257;
    stream->read((uint64_t*)&cgen_var_1257, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_1257, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugUtilsMessengerEXT local_messenger;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_messenger = messenger;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1258;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1259;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDebugUtilsMessengerEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDebugUtilsMessengerEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDebugUtilsMessengerEXT = OP_vkDestroyDebugUtilsMessengerEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1260;
    *&cgen_var_1260 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1260, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1261;
    *&cgen_var_1261 = get_host_u64_VkDebugUtilsMessengerEXT((*&local_messenger));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1261, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1262 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1262, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)&messenger);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugUtilsMessageSeverityFlagBitsEXT local_messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT local_messageTypes;
    VkDebugUtilsMessengerCallbackDataEXT* local_pCallbackData;
    local_instance = instance;
    local_messageSeverity = messageSeverity;
    local_messageTypes = messageTypes;
    local_pCallbackData = nullptr;
    if (pCallbackData)
    {
        local_pCallbackData = (VkDebugUtilsMessengerCallbackDataEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
        deepcopy_VkDebugUtilsMessengerCallbackDataEXT(pool, pCallbackData, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    if (local_pCallbackData)
    {
        transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(sResourceTracker, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1263;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT);
        *countPtr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
        count_VkDebugUtilsMessengerCallbackDataEXT(sFeatureBits, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData), countPtr);
    }
    uint32_t packetSize_vkSubmitDebugUtilsMessageEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSubmitDebugUtilsMessageEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSubmitDebugUtilsMessageEXT = OP_vkSubmitDebugUtilsMessageEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1264;
    *&cgen_var_1264 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1264, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDebugUtilsMessageSeverityFlagBitsEXT*)&local_messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    *streamPtrPtr += sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT);
    memcpy(*streamPtrPtr, (VkDebugUtilsMessageTypeFlagsEXT*)&local_messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    *streamPtrPtr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    reservedmarshal_VkDebugUtilsMessengerCallbackDataEXT(stream, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData), streamPtrPtr);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
VkResult VkEncoder::vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    AHardwareBuffer* local_buffer;
    local_device = device;
    // Avoiding deepcopy for buffer
    local_buffer = (AHardwareBuffer*)buffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1265;
        *countPtr += 1 * 8;
        *countPtr += sizeof(AHardwareBuffer);
        count_VkAndroidHardwareBufferPropertiesANDROID(sFeatureBits, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetAndroidHardwareBufferPropertiesANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetAndroidHardwareBufferPropertiesANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetAndroidHardwareBufferPropertiesANDROID = OP_vkGetAndroidHardwareBufferPropertiesANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1266;
    *&cgen_var_1266 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1266, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (AHardwareBuffer*)local_buffer, sizeof(AHardwareBuffer));
    *streamPtrPtr += sizeof(AHardwareBuffer);
    reservedmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties), streamPtrPtr);
    unmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(sResourceTracker, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryGetAndroidHardwareBufferInfoANDROID* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkMemoryGetAndroidHardwareBufferInfoANDROID*)pool->alloc(sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
        deepcopy_VkMemoryGetAndroidHardwareBufferInfoANDROID(pool, pInfo, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(sResourceTracker, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1267;
        *countPtr += 1 * 8;
        count_VkMemoryGetAndroidHardwareBufferInfoANDROID(sFeatureBits, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo), countPtr);
        *countPtr += sizeof(AHardwareBuffer*);
    }
    uint32_t packetSize_vkGetMemoryAndroidHardwareBufferANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryAndroidHardwareBufferANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryAndroidHardwareBufferANDROID = OP_vkGetMemoryAndroidHardwareBufferANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1268;
    *&cgen_var_1268 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1268, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(stream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    *streamPtrPtr += sizeof(AHardwareBuffer*);
    stream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void VkEncoder::vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSampleLocationsInfoEXT* local_pSampleLocationsInfo;
    local_commandBuffer = commandBuffer;
    local_pSampleLocationsInfo = nullptr;
    if (pSampleLocationsInfo)
    {
        local_pSampleLocationsInfo = (VkSampleLocationsInfoEXT*)pool->alloc(sizeof(const VkSampleLocationsInfoEXT));
        deepcopy_VkSampleLocationsInfoEXT(pool, pSampleLocationsInfo, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    if (local_pSampleLocationsInfo)
    {
        transform_tohost_VkSampleLocationsInfoEXT(sResourceTracker, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1269;
        *countPtr += 1 * 8;
        count_VkSampleLocationsInfoEXT(sFeatureBits, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo), countPtr);
    }
    uint32_t packetSize_vkCmdSetSampleLocationsEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetSampleLocationsEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetSampleLocationsEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetSampleLocationsEXT = OP_vkCmdSetSampleLocationsEXT;
    memcpy(streamPtr, &opcode_vkCmdSetSampleLocationsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetSampleLocationsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1270;
        *&cgen_var_1270 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1270, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSampleLocationsInfoEXT(stream, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSampleCountFlagBits local_samples;
    local_physicalDevice = physicalDevice;
    local_samples = samples;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1271;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkSampleCountFlagBits);
        count_VkMultisamplePropertiesEXT(sFeatureBits, (VkMultisamplePropertiesEXT*)(pMultisampleProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT = OP_vkGetPhysicalDeviceMultisamplePropertiesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1272;
    *&cgen_var_1272 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1272, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    *streamPtrPtr += sizeof(VkSampleCountFlagBits);
    reservedmarshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties), streamPtrPtr);
    unmarshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    if (pMultisampleProperties)
    {
        transform_fromhost_VkMultisamplePropertiesEXT(sResourceTracker, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
VkResult VkEncoder::vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkValidationCacheCreateInfoEXT*)pool->alloc(sizeof(const VkValidationCacheCreateInfoEXT));
        deepcopy_VkValidationCacheCreateInfoEXT(pool, pCreateInfo, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkValidationCacheCreateInfoEXT(sResourceTracker, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1273;
        *countPtr += 1 * 8;
        count_VkValidationCacheCreateInfoEXT(sFeatureBits, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1274;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateValidationCacheEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateValidationCacheEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateValidationCacheEXT = OP_vkCreateValidationCacheEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1275;
    *&cgen_var_1275 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1275, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkValidationCacheCreateInfoEXT(stream, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1276 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1276, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1277;
    *&cgen_var_1277 = (uint64_t)((*pValidationCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1277, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1278;
    stream->read((uint64_t*)&cgen_var_1278, 8);
    stream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_1278, (VkValidationCacheEXT*)pValidationCache, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateValidationCacheEXT_VkResult_return;
}

void VkEncoder::vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_validationCache = validationCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1279;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1280;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyValidationCacheEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyValidationCacheEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyValidationCacheEXT = OP_vkDestroyValidationCacheEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1281;
    *&cgen_var_1281 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1281, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1282;
    *&cgen_var_1282 = get_host_u64_VkValidationCacheEXT((*&local_validationCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1282, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1283 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1283, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)&validationCache);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheEXT local_dstCache;
    uint32_t local_srcCacheCount;
    VkValidationCacheEXT* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    // Avoiding deepcopy for pSrcCaches
    local_pSrcCaches = (VkValidationCacheEXT*)pSrcCaches;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1284;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1285;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((srcCacheCount)))
        {
            *countPtr += ((srcCacheCount)) * 8;
        }
    }
    uint32_t packetSize_vkMergeValidationCachesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkMergeValidationCachesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkMergeValidationCachesEXT = OP_vkMergeValidationCachesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkMergeValidationCachesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkMergeValidationCachesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1287;
    *&cgen_var_1287 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1287, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1288;
    *&cgen_var_1288 = get_host_u64_VkValidationCacheEXT((*&local_dstCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1288, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((srcCacheCount)))
    {
        uint8_t* cgen_var_1289_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkValidationCacheEXT(local_pSrcCaches[k]);
            memcpy(cgen_var_1289_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((srcCacheCount));
    }
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkMergeValidationCachesEXT_VkResult_return;
}

VkResult VkEncoder::vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    local_device = device;
    local_validationCache = validationCache;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1290;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1291;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDataSize)
        {
            *countPtr += 8;
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pData)
        {
            *countPtr += (*(pDataSize)) * sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkGetValidationCacheDataEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetValidationCacheDataEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetValidationCacheDataEXT = OP_vkGetValidationCacheDataEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetValidationCacheDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetValidationCacheDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1292;
    *&cgen_var_1292 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1292, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1293;
    *&cgen_var_1293 = get_host_u64_VkValidationCacheEXT((*&local_validationCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1293, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1294 = (uint64_t)(uintptr_t)pDataSize;
    memcpy((*streamPtrPtr), &cgen_var_1294, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDataSize)
    {
        uint64_t cgen_var_1295 = (uint64_t)(*pDataSize);
        memcpy((*streamPtrPtr), &cgen_var_1295, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1296 = (uint64_t)(uintptr_t)pData;
    memcpy((*streamPtrPtr), &cgen_var_1296, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pData)
    {
        memcpy(*streamPtrPtr, (void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        *streamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
    }
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetValidationCacheDataEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
VkResult VkEncoder::vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    void* local_pHostPointer;
    local_device = device;
    local_handleType = handleType;
    // Avoiding deepcopy for pHostPointer
    local_pHostPointer = (void*)pHostPointer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1300;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pHostPointer)
        {
            *countPtr += sizeof(uint8_t);
        }
        count_VkMemoryHostPointerPropertiesEXT(sFeatureBits, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties), countPtr);
    }
    uint32_t packetSize_vkGetMemoryHostPointerPropertiesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryHostPointerPropertiesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryHostPointerPropertiesEXT = OP_vkGetMemoryHostPointerPropertiesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1301;
    *&cgen_var_1301 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1301, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_1302 = (uint64_t)(uintptr_t)local_pHostPointer;
    memcpy((*streamPtrPtr), &cgen_var_1302, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pHostPointer)
    {
        memcpy(*streamPtrPtr, (void*)local_pHostPointer, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    reservedmarshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties), streamPtrPtr);
    unmarshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    if (pMemoryHostPointerProperties)
    {
        transform_fromhost_VkMemoryHostPointerPropertiesEXT(sResourceTracker, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_buffer_marker
void VkEncoder::vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    uint32_t local_marker;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_marker = marker;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1303;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlagBits);
        uint64_t cgen_var_1304;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdWriteBufferMarkerAMD = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWriteBufferMarkerAMD -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWriteBufferMarkerAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWriteBufferMarkerAMD = OP_vkCmdWriteBufferMarkerAMD;
    memcpy(streamPtr, &opcode_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1305;
        *&cgen_var_1305 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1305, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    *streamPtrPtr += sizeof(VkPipelineStageFlagBits);
    uint64_t cgen_var_1306;
    *&cgen_var_1306 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1306, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_marker, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void VkEncoder::vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    void* local_pCheckpointMarker;
    local_commandBuffer = commandBuffer;
    // Avoiding deepcopy for pCheckpointMarker
    local_pCheckpointMarker = (void*)pCheckpointMarker;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1307;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCheckpointMarker)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkCmdSetCheckpointNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetCheckpointNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetCheckpointNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetCheckpointNV = OP_vkCmdSetCheckpointNV;
    memcpy(streamPtr, &opcode_vkCmdSetCheckpointNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetCheckpointNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1308;
        *&cgen_var_1308 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1308, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1309 = (uint64_t)(uintptr_t)local_pCheckpointMarker;
    memcpy((*streamPtrPtr), &cgen_var_1309, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCheckpointMarker)
    {
        memcpy(*streamPtrPtr, (void*)local_pCheckpointMarker, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetQueueCheckpointDataNV(
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1310;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCheckpointDataCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCheckpointData)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
            {
                count_VkCheckpointDataNV(sFeatureBits, (VkCheckpointDataNV*)(pCheckpointData + i), countPtr);
            }
        }
    }
    uint32_t packetSize_vkGetQueueCheckpointDataNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetQueueCheckpointDataNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetQueueCheckpointDataNV = OP_vkGetQueueCheckpointDataNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetQueueCheckpointDataNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetQueueCheckpointDataNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1311;
    *&cgen_var_1311 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1311, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1312 = (uint64_t)(uintptr_t)pCheckpointDataCount;
    memcpy((*streamPtrPtr), &cgen_var_1312, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCheckpointDataCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1313 = (uint64_t)(uintptr_t)pCheckpointData;
    memcpy((*streamPtrPtr), &cgen_var_1313, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            reservedmarshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pCheckpointDataCount;
    check_pCheckpointDataCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pCheckpointDataCount)
    {
        if (!(check_pCheckpointDataCount))
        {
            fprintf(stderr, "fatal: pCheckpointDataCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkCheckpointDataNV* check_pCheckpointData;
    check_pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)stream->getBe64();
    if (pCheckpointData)
    {
        if (!(check_pCheckpointData))
        {
            fprintf(stderr, "fatal: pCheckpointData inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            unmarshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            transform_fromhost_VkCheckpointDataNV(sResourceTracker, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_GOOGLE_address_space
VkResult VkEncoder::vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    sResourceTracker->on_vkMapMemoryIntoAddressSpaceGOOGLE_pre(this, VK_SUCCESS, device, memory, pAddress);
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1316;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1317;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pAddress)
        {
            *countPtr += sizeof(uint64_t);
        }
    }
    uint32_t packetSize_vkMapMemoryIntoAddressSpaceGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkMapMemoryIntoAddressSpaceGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkMapMemoryIntoAddressSpaceGOOGLE = OP_vkMapMemoryIntoAddressSpaceGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1318;
    *&cgen_var_1318 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1318, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1319;
    *&cgen_var_1319 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1319, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1320 = (uint64_t)(uintptr_t)pAddress;
    memcpy((*streamPtrPtr), &cgen_var_1320, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pAddress)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pAddress, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkMapMemoryIntoAddressSpaceGOOGLE(this, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_color_buffer
VkResult VkEncoder::vkRegisterImageColorBufferGOOGLE(
    VkDevice device,
    VkImage image,
    uint32_t colorBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    uint32_t local_colorBuffer;
    local_device = device;
    local_image = image;
    local_colorBuffer = colorBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1322;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1323;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkRegisterImageColorBufferGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterImageColorBufferGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterImageColorBufferGOOGLE = OP_vkRegisterImageColorBufferGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterImageColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterImageColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1324;
    *&cgen_var_1324 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1324, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1325;
    *&cgen_var_1325 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1325, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterImageColorBufferGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkRegisterBufferColorBufferGOOGLE(
    VkDevice device,
    VkBuffer buffer,
    uint32_t colorBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    uint32_t local_colorBuffer;
    local_device = device;
    local_buffer = buffer;
    local_colorBuffer = colorBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1326;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1327;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkRegisterBufferColorBufferGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterBufferColorBufferGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterBufferColorBufferGOOGLE = OP_vkRegisterBufferColorBufferGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterBufferColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterBufferColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1328;
    *&cgen_var_1328 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1328, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1329;
    *&cgen_var_1329 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1329, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterBufferColorBufferGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
void VkEncoder::vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    uint32_t imageInfoCount,
    uint32_t bufferInfoCount,
    uint32_t bufferViewCount,
    const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    uint32_t local_imageInfoCount;
    uint32_t local_bufferInfoCount;
    uint32_t local_bufferViewCount;
    uint32_t* local_pImageInfoEntryIndices;
    uint32_t* local_pBufferInfoEntryIndices;
    uint32_t* local_pBufferViewEntryIndices;
    VkDescriptorImageInfo* local_pImageInfos;
    VkDescriptorBufferInfo* local_pBufferInfos;
    VkBufferView* local_pBufferViews;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_imageInfoCount = imageInfoCount;
    local_bufferInfoCount = bufferInfoCount;
    local_bufferViewCount = bufferViewCount;
    // Avoiding deepcopy for pImageInfoEntryIndices
    local_pImageInfoEntryIndices = (uint32_t*)pImageInfoEntryIndices;
    // Avoiding deepcopy for pBufferInfoEntryIndices
    local_pBufferInfoEntryIndices = (uint32_t*)pBufferInfoEntryIndices;
    // Avoiding deepcopy for pBufferViewEntryIndices
    local_pBufferViewEntryIndices = (uint32_t*)pBufferViewEntryIndices;
    local_pImageInfos = nullptr;
    if (pImageInfos)
    {
        local_pImageInfos = (VkDescriptorImageInfo*)pool->alloc(((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            deepcopy_VkDescriptorImageInfo(pool, pImageInfos + i, (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    local_pBufferInfos = nullptr;
    if (pBufferInfos)
    {
        local_pBufferInfos = (VkDescriptorBufferInfo*)pool->alloc(((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            deepcopy_VkDescriptorBufferInfo(pool, pBufferInfos + i, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    // Avoiding deepcopy for pBufferViews
    local_pBufferViews = (VkBufferView*)pBufferViews;
    if (local_pImageInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            transform_tohost_VkDescriptorImageInfo(sResourceTracker, (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    if (local_pBufferInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            transform_tohost_VkDescriptorBufferInfo(sResourceTracker, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1330;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1331;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1332;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pImageInfoEntryIndices)
        {
            *countPtr += ((imageInfoCount)) * sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferInfoEntryIndices)
        {
            *countPtr += ((bufferInfoCount)) * sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferViewEntryIndices)
        {
            *countPtr += ((bufferViewCount)) * sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pImageInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
            {
                count_VkDescriptorImageInfo(sFeatureBits, (VkDescriptorImageInfo*)(local_pImageInfos + i), countPtr);
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
            {
                count_VkDescriptorBufferInfo(sFeatureBits, (VkDescriptorBufferInfo*)(local_pBufferInfos + i), countPtr);
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferViews)
        {
            if (((bufferViewCount)))
            {
                *countPtr += ((bufferViewCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateSizedGOOGLE = OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSetWithTemplateSizedGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1334;
    *&cgen_var_1334 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1334, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1335;
    *&cgen_var_1335 = get_host_u64_VkDescriptorSet((*&local_descriptorSet));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1335, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1336;
    *&cgen_var_1336 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1336, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_imageInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferViewCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1337 = (uint64_t)(uintptr_t)local_pImageInfoEntryIndices;
    memcpy((*streamPtrPtr), &cgen_var_1337, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pImageInfoEntryIndices)
    {
        memcpy(*streamPtrPtr, (uint32_t*)local_pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(uint32_t));
        *streamPtrPtr += ((imageInfoCount)) * sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1338 = (uint64_t)(uintptr_t)local_pBufferInfoEntryIndices;
    memcpy((*streamPtrPtr), &cgen_var_1338, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferInfoEntryIndices)
    {
        memcpy(*streamPtrPtr, (uint32_t*)local_pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(uint32_t));
        *streamPtrPtr += ((bufferInfoCount)) * sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1339 = (uint64_t)(uintptr_t)local_pBufferViewEntryIndices;
    memcpy((*streamPtrPtr), &cgen_var_1339, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferViewEntryIndices)
    {
        memcpy(*streamPtrPtr, (uint32_t*)local_pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(uint32_t));
        *streamPtrPtr += ((bufferViewCount)) * sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1340 = (uint64_t)(uintptr_t)local_pImageInfos;
    memcpy((*streamPtrPtr), &cgen_var_1340, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pImageInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            reservedmarshal_VkDescriptorImageInfo(stream, (VkDescriptorImageInfo*)(local_pImageInfos + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1341 = (uint64_t)(uintptr_t)local_pBufferInfos;
    memcpy((*streamPtrPtr), &cgen_var_1341, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            reservedmarshal_VkDescriptorBufferInfo(stream, (VkDescriptorBufferInfo*)(local_pBufferInfos + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1342 = (uint64_t)(uintptr_t)local_pBufferViews;
    memcpy((*streamPtrPtr), &cgen_var_1342, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferViews)
    {
        if (((bufferViewCount)))
        {
            uint8_t* cgen_var_1343_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((bufferViewCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkBufferView(local_pBufferViews[k]);
                memcpy(cgen_var_1343_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((bufferViewCount));
        }
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_GOOGLE_async_command_buffers
void VkEncoder::vkBeginCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(sResourceTracker, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1344;
        *countPtr += 1 * 8;
        count_VkCommandBufferBeginInfo(sFeatureBits, (VkCommandBufferBeginInfo*)(local_pBeginInfo), countPtr);
    }
    uint32_t packetSize_vkBeginCommandBufferAsyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkBeginCommandBufferAsyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBeginCommandBufferAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBeginCommandBufferAsyncGOOGLE = OP_vkBeginCommandBufferAsyncGOOGLE;
    memcpy(streamPtr, &opcode_vkBeginCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBeginCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1345;
        *&cgen_var_1345 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1345, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCommandBufferBeginInfo(stream, (VkCommandBufferBeginInfo*)(local_pBeginInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkEndCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1346;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkEndCommandBufferAsyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkEndCommandBufferAsyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEndCommandBufferAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEndCommandBufferAsyncGOOGLE = OP_vkEndCommandBufferAsyncGOOGLE;
    memcpy(streamPtr, &opcode_vkEndCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEndCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1347;
        *&cgen_var_1347 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1347, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkResetCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1348;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandBufferResetFlags);
    }
    uint32_t packetSize_vkResetCommandBufferAsyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkResetCommandBufferAsyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetCommandBufferAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetCommandBufferAsyncGOOGLE = OP_vkResetCommandBufferAsyncGOOGLE;
    memcpy(streamPtr, &opcode_vkResetCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1349;
        *&cgen_var_1349 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1349, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    *streamPtrPtr += sizeof(VkCommandBufferResetFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCommandBufferHostSyncGOOGLE(
    VkCommandBuffer commandBuffer,
    uint32_t needHostSync,
    uint32_t sequenceNumber,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_needHostSync;
    uint32_t local_sequenceNumber;
    local_commandBuffer = commandBuffer;
    local_needHostSync = needHostSync;
    local_sequenceNumber = sequenceNumber;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1350;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCommandBufferHostSyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCommandBufferHostSyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCommandBufferHostSyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCommandBufferHostSyncGOOGLE = OP_vkCommandBufferHostSyncGOOGLE;
    memcpy(streamPtr, &opcode_vkCommandBufferHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCommandBufferHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_1351;
        *&cgen_var_1351 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1351, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_needHostSync, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_sequenceNumber, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
VkResult VkEncoder::vkCreateImageWithRequirementsGOOGLE(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    sResourceTracker->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(sResourceTracker, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1352;
        *countPtr += 1 * 8;
        count_VkImageCreateInfo(sFeatureBits, (VkImageCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1353;
        *countPtr += 8;
        count_VkMemoryRequirements(sFeatureBits, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkCreateImageWithRequirementsGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImageWithRequirementsGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImageWithRequirementsGOOGLE = OP_vkCreateImageWithRequirementsGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImageWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImageWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1354;
    *&cgen_var_1354 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1354, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageCreateInfo(stream, (VkImageCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1355 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1355, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1356;
    *&cgen_var_1356 = (uint64_t)((*pImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1356, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    reservedmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1357;
    stream->read((uint64_t*)&cgen_var_1357, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_1357, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(sResourceTracker, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1358;
        *countPtr += 1 * 8;
        count_VkBufferCreateInfo(sFeatureBits, (VkBufferCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1359;
        *countPtr += 8;
        count_VkMemoryRequirements(sFeatureBits, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkCreateBufferWithRequirementsGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateBufferWithRequirementsGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateBufferWithRequirementsGOOGLE = OP_vkCreateBufferWithRequirementsGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateBufferWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateBufferWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1360;
    *&cgen_var_1360 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1360, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferCreateInfo(stream, (VkBufferCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1361 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1361, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1362;
    *&cgen_var_1362 = (uint64_t)((*pBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1362, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    reservedmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_1363;
    stream->read((uint64_t*)&cgen_var_1363, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1363, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_address_space_info
VkResult VkEncoder::vkGetMemoryHostAddressInfoGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint64_t* pSize,
    uint64_t* pHostmemId,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1364;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1365;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pAddress)
        {
            *countPtr += sizeof(uint64_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSize)
        {
            *countPtr += sizeof(uint64_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pHostmemId)
        {
            *countPtr += sizeof(uint64_t);
        }
    }
    uint32_t packetSize_vkGetMemoryHostAddressInfoGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryHostAddressInfoGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryHostAddressInfoGOOGLE = OP_vkGetMemoryHostAddressInfoGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryHostAddressInfoGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryHostAddressInfoGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1366;
    *&cgen_var_1366 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1366, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1367;
    *&cgen_var_1367 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1367, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1368 = (uint64_t)(uintptr_t)pAddress;
    memcpy((*streamPtrPtr), &cgen_var_1368, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pAddress)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pAddress, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1369 = (uint64_t)(uintptr_t)pSize;
    memcpy((*streamPtrPtr), &cgen_var_1369, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSize)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pSize, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1370 = (uint64_t)(uintptr_t)pHostmemId;
    memcpy((*streamPtrPtr), &cgen_var_1370, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pHostmemId)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pHostmemId, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pSize;
    check_pSize = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pSize)
    {
        if (!(check_pSize))
        {
            fprintf(stderr, "fatal: pSize inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pSize, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pHostmemId;
    check_pHostmemId = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pHostmemId)
    {
        if (!(check_pHostmemId))
        {
            fprintf(stderr, "fatal: pHostmemId inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pHostmemId, sizeof(uint64_t));
    }
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_free_memory_sync
VkResult VkEncoder::vkFreeMemorySyncGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1374;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1375;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkFreeMemorySyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeMemorySyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeMemorySyncGOOGLE = OP_vkFreeMemorySyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeMemorySyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeMemorySyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1376;
    *&cgen_var_1376 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1376, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1377;
    *&cgen_var_1377 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1377, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1378 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1378, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
    sResourceTracker->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_async_queue_submit
void VkEncoder::vkQueueHostSyncGOOGLE(
    VkQueue queue,
    uint32_t needHostSync,
    uint32_t sequenceNumber,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_needHostSync;
    uint32_t local_sequenceNumber;
    local_queue = queue;
    local_needHostSync = needHostSync;
    local_sequenceNumber = sequenceNumber;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1379;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkQueueHostSyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueHostSyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueHostSyncGOOGLE = OP_vkQueueHostSyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1380;
    *&cgen_var_1380 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1380, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_needHostSync, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_sequenceNumber, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueSubmitAsyncGOOGLE(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_submitCount;
    VkSubmitInfo* local_pSubmits;
    VkFence local_fence;
    local_queue = queue;
    local_submitCount = submitCount;
    local_pSubmits = nullptr;
    if (pSubmits)
    {
        local_pSubmits = (VkSubmitInfo*)pool->alloc(((submitCount)) * sizeof(const VkSubmitInfo));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            deepcopy_VkSubmitInfo(pool, pSubmits + i, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    local_fence = fence;
    if (local_pSubmits)
    {
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            transform_tohost_VkSubmitInfo(sResourceTracker, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1381;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            count_VkSubmitInfo(sFeatureBits, (VkSubmitInfo*)(local_pSubmits + i), countPtr);
        }
        uint64_t cgen_var_1382;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueSubmitAsyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSubmitAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSubmitAsyncGOOGLE = OP_vkQueueSubmitAsyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSubmitAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSubmitAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1383;
    *&cgen_var_1383 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1383, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_submitCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        reservedmarshal_VkSubmitInfo(stream, (VkSubmitInfo*)(local_pSubmits + i), streamPtrPtr);
    }
    uint64_t cgen_var_1384;
    *&cgen_var_1384 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1384, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueWaitIdleAsyncGOOGLE(
    VkQueue queue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1385;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueWaitIdleAsyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueWaitIdleAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueWaitIdleAsyncGOOGLE = OP_vkQueueWaitIdleAsyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueWaitIdleAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueWaitIdleAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1386;
    *&cgen_var_1386 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1386, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueBindSparseAsyncGOOGLE(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_bindInfoCount;
    VkBindSparseInfo* local_pBindInfo;
    VkFence local_fence;
    local_queue = queue;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfo = nullptr;
    if (pBindInfo)
    {
        local_pBindInfo = (VkBindSparseInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindSparseInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindSparseInfo(pool, pBindInfo + i, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    local_fence = fence;
    if (local_pBindInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindSparseInfo(sResourceTracker, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1387;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindSparseInfo(sFeatureBits, (VkBindSparseInfo*)(local_pBindInfo + i), countPtr);
        }
        uint64_t cgen_var_1388;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueBindSparseAsyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueBindSparseAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueBindSparseAsyncGOOGLE = OP_vkQueueBindSparseAsyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueBindSparseAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueBindSparseAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1389;
    *&cgen_var_1389 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1389, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindSparseInfo(stream, (VkBindSparseInfo*)(local_pBindInfo + i), streamPtrPtr);
    }
    uint64_t cgen_var_1390;
    *&cgen_var_1390 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1390, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_GOOGLE_linear_image_layout
void VkEncoder::vkGetLinearImageLayoutGOOGLE(
    VkDevice device,
    VkFormat format,
    VkDeviceSize* pOffset,
    VkDeviceSize* pRowPitchAlignment,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFormat local_format;
    local_device = device;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1391;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkGetLinearImageLayoutGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetLinearImageLayoutGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetLinearImageLayoutGOOGLE = OP_vkGetLinearImageLayoutGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetLinearImageLayoutGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetLinearImageLayoutGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1392;
    *&cgen_var_1392 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1392, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    stream->read((VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
    stream->read((VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_MVK_moltenvk
void VkEncoder::vkGetMTLDeviceMVK(
    VkPhysicalDevice physicalDevice,
    void** pMTLDevice,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1393;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetMTLDeviceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMTLDeviceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMTLDeviceMVK = OP_vkGetMTLDeviceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMTLDeviceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMTLDeviceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1394;
    *&cgen_var_1394 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1394, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pMTLDevice, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pMTLDevice, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkSetMTLTextureMVK(
    VkImage image,
    void* mtlTexture,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1395;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint8_t);
    }
    uint32_t packetSize_vkSetMTLTextureMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetMTLTextureMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetMTLTextureMVK = OP_vkSetMTLTextureMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1396;
    *&cgen_var_1396 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1396, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void*)mtlTexture, sizeof(uint8_t));
    *streamPtrPtr += sizeof(uint8_t);
    stream->read((void*)mtlTexture, sizeof(uint8_t));
    VkResult vkSetMTLTextureMVK_VkResult_return = (VkResult)0;
    stream->read(&vkSetMTLTextureMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetMTLTextureMVK_VkResult_return;
}

void VkEncoder::vkGetMTLTextureMVK(
    VkImage image,
    void** pMTLTexture,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1397;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetMTLTextureMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMTLTextureMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMTLTextureMVK = OP_vkGetMTLTextureMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1398;
    *&cgen_var_1398 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1398, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pMTLTexture, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pMTLTexture, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetMTLBufferMVK(
    VkBuffer buffer,
    void** pMTLBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkBuffer local_buffer;
    local_buffer = buffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1399;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetMTLBufferMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMTLBufferMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMTLBufferMVK = OP_vkGetMTLBufferMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMTLBufferMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMTLBufferMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1400;
    *&cgen_var_1400 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1400, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pMTLBuffer, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pMTLBuffer, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkUseIOSurfaceMVK(
    VkImage image,
    void* ioSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1401;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint8_t);
    }
    uint32_t packetSize_vkUseIOSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUseIOSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUseIOSurfaceMVK = OP_vkUseIOSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUseIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUseIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1402;
    *&cgen_var_1402 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1402, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void*)ioSurface, sizeof(uint8_t));
    *streamPtrPtr += sizeof(uint8_t);
    stream->read((void*)ioSurface, sizeof(uint8_t));
    VkResult vkUseIOSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkUseIOSurfaceMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkUseIOSurfaceMVK_VkResult_return;
}

void VkEncoder::vkGetIOSurfaceMVK(
    VkImage image,
    void** pIOSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_1403;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetIOSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetIOSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetIOSurfaceMVK = OP_vkGetIOSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_1404;
    *&cgen_var_1404 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1404, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pIOSurface, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pIOSurface, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_GOOGLE_queue_submit_with_commands
void VkEncoder::vkQueueFlushCommandsGOOGLE(
    VkQueue queue,
    VkCommandBuffer commandBuffer,
    VkDeviceSize dataSize,
    const void* pData,
    uint32_t doLock)
{
    #include "vkQueueFlushCommandsGOOGLE_encode_impl.cpp.inl"
}

#endif

} // namespace goldfish_vk
