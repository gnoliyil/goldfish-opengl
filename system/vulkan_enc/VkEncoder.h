// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkEncoder
// (header) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#pragma once

#include <vulkan/vulkan.h>


#include "goldfish_vk_private_defs.h"
#include <memory>
class IOStream;


namespace goldfish_vk {


class VkEncoder {
public:
    VkEncoder(IOStream* stream);
    ~VkEncoder();

#include "VkEncoder.h.inl"
#ifdef VK_VERSION_1_0
    VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkInstance* pInstance,
        uint32_t doLock);
    void vkDestroyInstance(
    VkInstance instance,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkEnumeratePhysicalDevices(
    VkInstance instance,
        uint32_t* pPhysicalDeviceCount,
        VkPhysicalDevice* pPhysicalDevices,
        uint32_t doLock);
    void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceFeatures* pFeatures,
        uint32_t doLock);
    void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkFormatProperties* pFormatProperties,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags,
        VkImageFormatProperties* pImageFormatProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceProperties* pProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
        uint32_t* pQueueFamilyPropertyCount,
        VkQueueFamilyProperties* pQueueFamilyProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceMemoryProperties* pMemoryProperties,
        uint32_t doLock);
    PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance instance,
        const char* pName,
        uint32_t doLock);
    PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice device,
        const char* pName,
        uint32_t doLock);
    VkResult vkCreateDevice(
    VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDevice* pDevice,
        uint32_t doLock);
    void vkDestroyDevice(
    VkDevice device,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
        uint32_t* pPropertyCount,
        VkExtensionProperties* pProperties,
        uint32_t doLock);
    VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
        const char* pLayerName,
        uint32_t* pPropertyCount,
        VkExtensionProperties* pProperties,
        uint32_t doLock);
    VkResult vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
        VkLayerProperties* pProperties,
        uint32_t doLock);
    VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
        uint32_t* pPropertyCount,
        VkLayerProperties* pProperties,
        uint32_t doLock);
    void vkGetDeviceQueue(
    VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex,
        VkQueue* pQueue,
        uint32_t doLock);
    VkResult vkQueueSubmit(
    VkQueue queue,
        uint32_t submitCount,
        const VkSubmitInfo* pSubmits,
        VkFence fence,
        uint32_t doLock);
    VkResult vkQueueWaitIdle(
    VkQueue queue,
        uint32_t doLock);
    VkResult vkDeviceWaitIdle(
    VkDevice device,
        uint32_t doLock);
    VkResult vkAllocateMemory(
    VkDevice device,
        const VkMemoryAllocateInfo* pAllocateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDeviceMemory* pMemory,
        uint32_t doLock);
    void vkFreeMemory(
    VkDevice device,
        VkDeviceMemory memory,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkMapMemory(
    VkDevice device,
        VkDeviceMemory memory,
        VkDeviceSize offset,
        VkDeviceSize size,
        VkMemoryMapFlags flags,
        void** ppData,
        uint32_t doLock);
    void vkUnmapMemory(
    VkDevice device,
        VkDeviceMemory memory,
        uint32_t doLock);
    VkResult vkFlushMappedMemoryRanges(
    VkDevice device,
        uint32_t memoryRangeCount,
        const VkMappedMemoryRange* pMemoryRanges,
        uint32_t doLock);
    VkResult vkInvalidateMappedMemoryRanges(
    VkDevice device,
        uint32_t memoryRangeCount,
        const VkMappedMemoryRange* pMemoryRanges,
        uint32_t doLock);
    void vkGetDeviceMemoryCommitment(
    VkDevice device,
        VkDeviceMemory memory,
        VkDeviceSize* pCommittedMemoryInBytes,
        uint32_t doLock);
    VkResult vkBindBufferMemory(
    VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset,
        uint32_t doLock);
    VkResult vkBindImageMemory(
    VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset,
        uint32_t doLock);
    void vkGetBufferMemoryRequirements(
    VkDevice device,
        VkBuffer buffer,
        VkMemoryRequirements* pMemoryRequirements,
        uint32_t doLock);
    void vkGetImageMemoryRequirements(
    VkDevice device,
        VkImage image,
        VkMemoryRequirements* pMemoryRequirements,
        uint32_t doLock);
    void vkGetImageSparseMemoryRequirements(
    VkDevice device,
        VkImage image,
        uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements* pSparseMemoryRequirements,
        uint32_t doLock);
    void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling,
        uint32_t* pPropertyCount,
        VkSparseImageFormatProperties* pProperties,
        uint32_t doLock);
    VkResult vkQueueBindSparse(
    VkQueue queue,
        uint32_t bindInfoCount,
        const VkBindSparseInfo* pBindInfo,
        VkFence fence,
        uint32_t doLock);
    VkResult vkCreateFence(
    VkDevice device,
        const VkFenceCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkFence* pFence,
        uint32_t doLock);
    void vkDestroyFence(
    VkDevice device,
        VkFence fence,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkResetFences(
    VkDevice device,
        uint32_t fenceCount,
        const VkFence* pFences,
        uint32_t doLock);
    VkResult vkGetFenceStatus(
    VkDevice device,
        VkFence fence,
        uint32_t doLock);
    VkResult vkWaitForFences(
    VkDevice device,
        uint32_t fenceCount,
        const VkFence* pFences,
        VkBool32 waitAll,
        uint64_t timeout,
        uint32_t doLock);
    VkResult vkCreateSemaphore(
    VkDevice device,
        const VkSemaphoreCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSemaphore* pSemaphore,
        uint32_t doLock);
    void vkDestroySemaphore(
    VkDevice device,
        VkSemaphore semaphore,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateEvent(
    VkDevice device,
        const VkEventCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkEvent* pEvent,
        uint32_t doLock);
    void vkDestroyEvent(
    VkDevice device,
        VkEvent event,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkGetEventStatus(
    VkDevice device,
        VkEvent event,
        uint32_t doLock);
    VkResult vkSetEvent(
    VkDevice device,
        VkEvent event,
        uint32_t doLock);
    VkResult vkResetEvent(
    VkDevice device,
        VkEvent event,
        uint32_t doLock);
    VkResult vkCreateQueryPool(
    VkDevice device,
        const VkQueryPoolCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkQueryPool* pQueryPool,
        uint32_t doLock);
    void vkDestroyQueryPool(
    VkDevice device,
        VkQueryPool queryPool,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkGetQueryPoolResults(
    VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        void* pData,
        VkDeviceSize stride,
        VkQueryResultFlags flags,
        uint32_t doLock);
    VkResult vkCreateBuffer(
    VkDevice device,
        const VkBufferCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkBuffer* pBuffer,
        uint32_t doLock);
    void vkDestroyBuffer(
    VkDevice device,
        VkBuffer buffer,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateBufferView(
    VkDevice device,
        const VkBufferViewCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkBufferView* pView,
        uint32_t doLock);
    void vkDestroyBufferView(
    VkDevice device,
        VkBufferView bufferView,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateImage(
    VkDevice device,
        const VkImageCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkImage* pImage,
        uint32_t doLock);
    void vkDestroyImage(
    VkDevice device,
        VkImage image,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    void vkGetImageSubresourceLayout(
    VkDevice device,
        VkImage image,
        const VkImageSubresource* pSubresource,
        VkSubresourceLayout* pLayout,
        uint32_t doLock);
    VkResult vkCreateImageView(
    VkDevice device,
        const VkImageViewCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkImageView* pView,
        uint32_t doLock);
    void vkDestroyImageView(
    VkDevice device,
        VkImageView imageView,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateShaderModule(
    VkDevice device,
        const VkShaderModuleCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkShaderModule* pShaderModule,
        uint32_t doLock);
    void vkDestroyShaderModule(
    VkDevice device,
        VkShaderModule shaderModule,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreatePipelineCache(
    VkDevice device,
        const VkPipelineCacheCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkPipelineCache* pPipelineCache,
        uint32_t doLock);
    void vkDestroyPipelineCache(
    VkDevice device,
        VkPipelineCache pipelineCache,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkGetPipelineCacheData(
    VkDevice device,
        VkPipelineCache pipelineCache,
        size_t* pDataSize,
        void* pData,
        uint32_t doLock);
    VkResult vkMergePipelineCaches(
    VkDevice device,
        VkPipelineCache dstCache,
        uint32_t srcCacheCount,
        const VkPipelineCache* pSrcCaches,
        uint32_t doLock);
    VkResult vkCreateGraphicsPipelines(
    VkDevice device,
        VkPipelineCache pipelineCache,
        uint32_t createInfoCount,
        const VkGraphicsPipelineCreateInfo* pCreateInfos,
        const VkAllocationCallbacks* pAllocator,
        VkPipeline* pPipelines,
        uint32_t doLock);
    VkResult vkCreateComputePipelines(
    VkDevice device,
        VkPipelineCache pipelineCache,
        uint32_t createInfoCount,
        const VkComputePipelineCreateInfo* pCreateInfos,
        const VkAllocationCallbacks* pAllocator,
        VkPipeline* pPipelines,
        uint32_t doLock);
    void vkDestroyPipeline(
    VkDevice device,
        VkPipeline pipeline,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreatePipelineLayout(
    VkDevice device,
        const VkPipelineLayoutCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkPipelineLayout* pPipelineLayout,
        uint32_t doLock);
    void vkDestroyPipelineLayout(
    VkDevice device,
        VkPipelineLayout pipelineLayout,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateSampler(
    VkDevice device,
        const VkSamplerCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSampler* pSampler,
        uint32_t doLock);
    void vkDestroySampler(
    VkDevice device,
        VkSampler sampler,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateDescriptorSetLayout(
    VkDevice device,
        const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorSetLayout* pSetLayout,
        uint32_t doLock);
    void vkDestroyDescriptorSetLayout(
    VkDevice device,
        VkDescriptorSetLayout descriptorSetLayout,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateDescriptorPool(
    VkDevice device,
        const VkDescriptorPoolCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorPool* pDescriptorPool,
        uint32_t doLock);
    void vkDestroyDescriptorPool(
    VkDevice device,
        VkDescriptorPool descriptorPool,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkResetDescriptorPool(
    VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags,
        uint32_t doLock);
    VkResult vkAllocateDescriptorSets(
    VkDevice device,
        const VkDescriptorSetAllocateInfo* pAllocateInfo,
        VkDescriptorSet* pDescriptorSets,
        uint32_t doLock);
    VkResult vkFreeDescriptorSets(
    VkDevice device,
        VkDescriptorPool descriptorPool,
        uint32_t descriptorSetCount,
        const VkDescriptorSet* pDescriptorSets,
        uint32_t doLock);
    void vkUpdateDescriptorSets(
    VkDevice device,
        uint32_t descriptorWriteCount,
        const VkWriteDescriptorSet* pDescriptorWrites,
        uint32_t descriptorCopyCount,
        const VkCopyDescriptorSet* pDescriptorCopies,
        uint32_t doLock);
    VkResult vkCreateFramebuffer(
    VkDevice device,
        const VkFramebufferCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkFramebuffer* pFramebuffer,
        uint32_t doLock);
    void vkDestroyFramebuffer(
    VkDevice device,
        VkFramebuffer framebuffer,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateRenderPass(
    VkDevice device,
        const VkRenderPassCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkRenderPass* pRenderPass,
        uint32_t doLock);
    void vkDestroyRenderPass(
    VkDevice device,
        VkRenderPass renderPass,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    void vkGetRenderAreaGranularity(
    VkDevice device,
        VkRenderPass renderPass,
        VkExtent2D* pGranularity,
        uint32_t doLock);
    VkResult vkCreateCommandPool(
    VkDevice device,
        const VkCommandPoolCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkCommandPool* pCommandPool,
        uint32_t doLock);
    void vkDestroyCommandPool(
    VkDevice device,
        VkCommandPool commandPool,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkResetCommandPool(
    VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags,
        uint32_t doLock);
    VkResult vkAllocateCommandBuffers(
    VkDevice device,
        const VkCommandBufferAllocateInfo* pAllocateInfo,
        VkCommandBuffer* pCommandBuffers,
        uint32_t doLock);
    void vkFreeCommandBuffers(
    VkDevice device,
        VkCommandPool commandPool,
        uint32_t commandBufferCount,
        const VkCommandBuffer* pCommandBuffers,
        uint32_t doLock);
    VkResult vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo* pBeginInfo,
        uint32_t doLock);
    VkResult vkEndCommandBuffer(
    VkCommandBuffer commandBuffer,
        uint32_t doLock);
    VkResult vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags,
        uint32_t doLock);
    void vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline,
        uint32_t doLock);
    void vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        uint32_t viewportCount,
        const VkViewport* pViewports,
        uint32_t doLock);
    void vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        uint32_t scissorCount,
        const VkRect2D* pScissors,
        uint32_t doLock);
    void vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
        float lineWidth,
        uint32_t doLock);
    void vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor,
        uint32_t doLock);
    void vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
        const float blendConstants[4],
        uint32_t doLock);
    void vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds,
        uint32_t doLock);
    void vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask,
        uint32_t doLock);
    void vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask,
        uint32_t doLock);
    void vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference,
        uint32_t doLock);
    void vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        uint32_t descriptorSetCount,
        const VkDescriptorSet* pDescriptorSets,
        uint32_t dynamicOffsetCount,
        const uint32_t* pDynamicOffsets,
        uint32_t doLock);
    void vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType,
        uint32_t doLock);
    void vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        uint32_t bindingCount,
        const VkBuffer* pBuffers,
        const VkDeviceSize* pOffsets,
        uint32_t doLock);
    void vkCmdDraw(
    VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance,
        uint32_t doLock);
    void vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance,
        uint32_t doLock);
    void vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride,
        uint32_t doLock);
    void vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride,
        uint32_t doLock);
    void vkCmdDispatch(
    VkCommandBuffer commandBuffer,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ,
        uint32_t doLock);
    void vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t doLock);
    void vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        uint32_t regionCount,
        const VkBufferCopy* pRegions,
        uint32_t doLock);
    void vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        uint32_t regionCount,
        const VkImageCopy* pRegions,
        uint32_t doLock);
    void vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        uint32_t regionCount,
        const VkImageBlit* pRegions,
        VkFilter filter,
        uint32_t doLock);
    void vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        uint32_t regionCount,
        const VkBufferImageCopy* pRegions,
        uint32_t doLock);
    void vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        uint32_t regionCount,
        const VkBufferImageCopy* pRegions,
        uint32_t doLock);
    void vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize dataSize,
        const void* pData,
        uint32_t doLock);
    void vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data,
        uint32_t doLock);
    void vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue* pColor,
        uint32_t rangeCount,
        const VkImageSubresourceRange* pRanges,
        uint32_t doLock);
    void vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue* pDepthStencil,
        uint32_t rangeCount,
        const VkImageSubresourceRange* pRanges,
        uint32_t doLock);
    void vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
        uint32_t attachmentCount,
        const VkClearAttachment* pAttachments,
        uint32_t rectCount,
        const VkClearRect* pRects,
        uint32_t doLock);
    void vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        uint32_t regionCount,
        const VkImageResolve* pRegions,
        uint32_t doLock);
    void vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask,
        uint32_t doLock);
    void vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask,
        uint32_t doLock);
    void vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
        uint32_t eventCount,
        const VkEvent* pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        uint32_t memoryBarrierCount,
        const VkMemoryBarrier* pMemoryBarriers,
        uint32_t bufferMemoryBarrierCount,
        const VkBufferMemoryBarrier* pBufferMemoryBarriers,
        uint32_t imageMemoryBarrierCount,
        const VkImageMemoryBarrier* pImageMemoryBarriers,
        uint32_t doLock);
    void vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        uint32_t memoryBarrierCount,
        const VkMemoryBarrier* pMemoryBarriers,
        uint32_t bufferMemoryBarrierCount,
        const VkBufferMemoryBarrier* pBufferMemoryBarriers,
        uint32_t imageMemoryBarrierCount,
        const VkImageMemoryBarrier* pImageMemoryBarriers,
        uint32_t doLock);
    void vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags,
        uint32_t doLock);
    void vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        uint32_t doLock);
    void vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        uint32_t doLock);
    void vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query,
        uint32_t doLock);
    void vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags,
        uint32_t doLock);
    void vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
        VkPipelineLayout layout,
        VkShaderStageFlags stageFlags,
        uint32_t offset,
        uint32_t size,
        const void* pValues,
        uint32_t doLock);
    void vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo* pRenderPassBegin,
        VkSubpassContents contents,
        uint32_t doLock);
    void vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
        VkSubpassContents contents,
        uint32_t doLock);
    void vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer,
        uint32_t doLock);
    void vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
        uint32_t commandBufferCount,
        const VkCommandBuffer* pCommandBuffers,
        uint32_t doLock);
#endif
#ifdef VK_VERSION_1_1
    VkResult vkEnumerateInstanceVersion(
    uint32_t* pApiVersion,
        uint32_t doLock);
    VkResult vkBindBufferMemory2(
    VkDevice device,
        uint32_t bindInfoCount,
        const VkBindBufferMemoryInfo* pBindInfos,
        uint32_t doLock);
    VkResult vkBindImageMemory2(
    VkDevice device,
        uint32_t bindInfoCount,
        const VkBindImageMemoryInfo* pBindInfos,
        uint32_t doLock);
    void vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex,
        VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
        uint32_t doLock);
    void vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
        uint32_t deviceMask,
        uint32_t doLock);
    void vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ,
        uint32_t doLock);
    VkResult vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
        uint32_t* pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
        uint32_t doLock);
    void vkGetImageMemoryRequirements2(
    VkDevice device,
        const VkImageMemoryRequirementsInfo2* pInfo,
        VkMemoryRequirements2* pMemoryRequirements,
        uint32_t doLock);
    void vkGetBufferMemoryRequirements2(
    VkDevice device,
        const VkBufferMemoryRequirementsInfo2* pInfo,
        VkMemoryRequirements2* pMemoryRequirements,
        uint32_t doLock);
    void vkGetImageSparseMemoryRequirements2(
    VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2* pInfo,
        uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
        uint32_t doLock);
    void vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceFeatures2* pFeatures,
        uint32_t doLock);
    void vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceProperties2* pProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkFormatProperties2* pFormatProperties,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
        VkImageFormatProperties2* pImageFormatProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
        uint32_t* pQueueFamilyPropertyCount,
        VkQueueFamilyProperties2* pQueueFamilyProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
        uint32_t* pPropertyCount,
        VkSparseImageFormatProperties2* pProperties,
        uint32_t doLock);
    void vkTrimCommandPool(
    VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlags flags,
        uint32_t doLock);
    void vkGetDeviceQueue2(
    VkDevice device,
        const VkDeviceQueueInfo2* pQueueInfo,
        VkQueue* pQueue,
        uint32_t doLock);
    VkResult vkCreateSamplerYcbcrConversion(
    VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSamplerYcbcrConversion* pYcbcrConversion,
        uint32_t doLock);
    void vkDestroySamplerYcbcrConversion(
    VkDevice device,
        VkSamplerYcbcrConversion ycbcrConversion,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateDescriptorUpdateTemplate(
    VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
        uint32_t doLock);
    void vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    void vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
        VkDescriptorSet descriptorSet,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        const void* pData,
        uint32_t doLock);
    void vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
        VkExternalBufferProperties* pExternalBufferProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
        VkExternalFenceProperties* pExternalFenceProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties* pExternalSemaphoreProperties,
        uint32_t doLock);
    void vkGetDescriptorSetLayoutSupport(
    VkDevice device,
        const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
        VkDescriptorSetLayoutSupport* pSupport,
        uint32_t doLock);
#endif
#ifdef VK_KHR_surface
    void vkDestroySurfaceKHR(
    VkInstance instance,
        VkSurfaceKHR surface,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface,
        VkBool32* pSupported,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface,
        VkSurfaceCapabilitiesKHR* pSurfaceCapabilities,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface,
        uint32_t* pSurfaceFormatCount,
        VkSurfaceFormatKHR* pSurfaceFormats,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface,
        uint32_t* pPresentModeCount,
        VkPresentModeKHR* pPresentModes,
        uint32_t doLock);
#endif
#ifdef VK_KHR_swapchain
    VkResult vkCreateSwapchainKHR(
    VkDevice device,
        const VkSwapchainCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSwapchainKHR* pSwapchain,
        uint32_t doLock);
    void vkDestroySwapchainKHR(
    VkDevice device,
        VkSwapchainKHR swapchain,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkGetSwapchainImagesKHR(
    VkDevice device,
        VkSwapchainKHR swapchain,
        uint32_t* pSwapchainImageCount,
        VkImage* pSwapchainImages,
        uint32_t doLock);
    VkResult vkAcquireNextImageKHR(
    VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence,
        uint32_t* pImageIndex,
        uint32_t doLock);
    VkResult vkQueuePresentKHR(
    VkQueue queue,
        const VkPresentInfoKHR* pPresentInfo,
        uint32_t doLock);
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
        VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities,
        uint32_t doLock);
    VkResult vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
        VkSurfaceKHR surface,
        VkDeviceGroupPresentModeFlagsKHR* pModes,
        uint32_t doLock);
    VkResult vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface,
        uint32_t* pRectCount,
        VkRect2D* pRects,
        uint32_t doLock);
    VkResult vkAcquireNextImage2KHR(
    VkDevice device,
        const VkAcquireNextImageInfoKHR* pAcquireInfo,
        uint32_t* pImageIndex,
        uint32_t doLock);
#endif
#ifdef VK_KHR_display
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t* pPropertyCount,
        VkDisplayPropertiesKHR* pProperties,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t* pPropertyCount,
        VkDisplayPlanePropertiesKHR* pProperties,
        uint32_t doLock);
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t planeIndex,
        uint32_t* pDisplayCount,
        VkDisplayKHR* pDisplays,
        uint32_t doLock);
    VkResult vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        uint32_t* pPropertyCount,
        VkDisplayModePropertiesKHR* pProperties,
        uint32_t doLock);
    VkResult vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDisplayModeKHR* pMode,
        uint32_t doLock);
    VkResult vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex,
        VkDisplayPlaneCapabilitiesKHR* pCapabilities,
        uint32_t doLock);
    VkResult vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
#endif
#ifdef VK_KHR_display_swapchain
    VkResult vkCreateSharedSwapchainsKHR(
    VkDevice device,
        uint32_t swapchainCount,
        const VkSwapchainCreateInfoKHR* pCreateInfos,
        const VkAllocationCallbacks* pAllocator,
        VkSwapchainKHR* pSwapchains,
        uint32_t doLock);
#endif
#ifdef VK_KHR_xlib_surface
    VkResult vkCreateXlibSurfaceKHR(
    VkInstance instance,
        const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        Display* dpy,
        VisualID visualID,
        uint32_t doLock);
#endif
#ifdef VK_KHR_xcb_surface
    VkResult vkCreateXcbSurfaceKHR(
    VkInstance instance,
        const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        xcb_connection_t* connection,
        xcb_visualid_t visual_id,
        uint32_t doLock);
#endif
#ifdef VK_KHR_wayland_surface
    VkResult vkCreateWaylandSurfaceKHR(
    VkInstance instance,
        const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        wl_display* display,
        uint32_t doLock);
#endif
#ifdef VK_KHR_mir_surface
    VkResult vkCreateMirSurfaceKHR(
    VkInstance instance,
        const VkMirSurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
    VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        MirConnection* connection,
        uint32_t doLock);
#endif
#ifdef VK_KHR_android_surface
    VkResult vkCreateAndroidSurfaceKHR(
    VkInstance instance,
        const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
#endif
#ifdef VK_KHR_win32_surface
    VkResult vkCreateWin32SurfaceKHR(
    VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        uint32_t doLock);
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
    void vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceFeatures2* pFeatures,
        uint32_t doLock);
    void vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceProperties2* pProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkFormatProperties2* pFormatProperties,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
        VkImageFormatProperties2* pImageFormatProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
        uint32_t* pQueueFamilyPropertyCount,
        VkQueueFamilyProperties2* pQueueFamilyProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
        uint32_t doLock);
    void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
        uint32_t* pPropertyCount,
        VkSparseImageFormatProperties2* pProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_device_group
    void vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex,
        VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
        uint32_t doLock);
    void vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
        uint32_t deviceMask,
        uint32_t doLock);
    void vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ,
        uint32_t doLock);
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
    void vkTrimCommandPoolKHR(
    VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlags flags,
        uint32_t doLock);
#endif
#ifdef VK_KHR_device_group_creation
    VkResult vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
        uint32_t* pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_memory_capabilities
    void vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
        VkExternalBufferProperties* pExternalBufferProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
    VkResult vkGetMemoryWin32HandleKHR(
    VkDevice device,
        const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
        HANDLE* pHandle,
        uint32_t doLock);
    VkResult vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        HANDLE handle,
        VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_memory_fd
    VkResult vkGetMemoryFdKHR(
    VkDevice device,
        const VkMemoryGetFdInfoKHR* pGetFdInfo,
        int* pFd,
        uint32_t doLock);
    VkResult vkGetMemoryFdPropertiesKHR(
    VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        int fd,
        VkMemoryFdPropertiesKHR* pMemoryFdProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties* pExternalSemaphoreProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
    VkResult vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
        const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo,
        uint32_t doLock);
    VkResult vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
        const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
        HANDLE* pHandle,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_semaphore_fd
    VkResult vkImportSemaphoreFdKHR(
    VkDevice device,
        const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo,
        uint32_t doLock);
    VkResult vkGetSemaphoreFdKHR(
    VkDevice device,
        const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
        int* pFd,
        uint32_t doLock);
#endif
#ifdef VK_KHR_push_descriptor
    void vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t set,
        uint32_t descriptorWriteCount,
        const VkWriteDescriptorSet* pDescriptorWrites,
        uint32_t doLock);
    void vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        VkPipelineLayout layout,
        uint32_t set,
        const void* pData,
        uint32_t doLock);
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
    VkResult vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
        uint32_t doLock);
    void vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    void vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
        VkDescriptorSet descriptorSet,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        const void* pData,
        uint32_t doLock);
#endif
#ifdef VK_KHR_create_renderpass2
    VkResult vkCreateRenderPass2KHR(
    VkDevice device,
        const VkRenderPassCreateInfo2KHR* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkRenderPass* pRenderPass,
        uint32_t doLock);
    void vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo* pRenderPassBegin,
        const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
        uint32_t doLock);
    void vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
        const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
        const VkSubpassEndInfoKHR* pSubpassEndInfo,
        uint32_t doLock);
    void vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
        const VkSubpassEndInfoKHR* pSubpassEndInfo,
        uint32_t doLock);
#endif
#ifdef VK_KHR_shared_presentable_image
    VkResult vkGetSwapchainStatusKHR(
    VkDevice device,
        VkSwapchainKHR swapchain,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_fence_capabilities
    void vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
        VkExternalFenceProperties* pExternalFenceProperties,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
    VkResult vkImportFenceWin32HandleKHR(
    VkDevice device,
        const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo,
        uint32_t doLock);
    VkResult vkGetFenceWin32HandleKHR(
    VkDevice device,
        const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
        HANDLE* pHandle,
        uint32_t doLock);
#endif
#ifdef VK_KHR_external_fence_fd
    VkResult vkImportFenceFdKHR(
    VkDevice device,
        const VkImportFenceFdInfoKHR* pImportFenceFdInfo,
        uint32_t doLock);
    VkResult vkGetFenceFdKHR(
    VkDevice device,
        const VkFenceGetFdInfoKHR* pGetFdInfo,
        int* pFd,
        uint32_t doLock);
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
        VkSurfaceCapabilities2KHR* pSurfaceCapabilities,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
        uint32_t* pSurfaceFormatCount,
        VkSurfaceFormat2KHR* pSurfaceFormats,
        uint32_t doLock);
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
        uint32_t* pPropertyCount,
        VkDisplayProperties2KHR* pProperties,
        uint32_t doLock);
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
        uint32_t* pPropertyCount,
        VkDisplayPlaneProperties2KHR* pProperties,
        uint32_t doLock);
    VkResult vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        uint32_t* pPropertyCount,
        VkDisplayModeProperties2KHR* pProperties,
        uint32_t doLock);
    VkResult vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
        const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
        VkDisplayPlaneCapabilities2KHR* pCapabilities,
        uint32_t doLock);
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
    void vkGetImageMemoryRequirements2KHR(
    VkDevice device,
        const VkImageMemoryRequirementsInfo2* pInfo,
        VkMemoryRequirements2* pMemoryRequirements,
        uint32_t doLock);
    void vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
        const VkBufferMemoryRequirementsInfo2* pInfo,
        VkMemoryRequirements2* pMemoryRequirements,
        uint32_t doLock);
    void vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2* pInfo,
        uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
        uint32_t doLock);
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    VkResult vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSamplerYcbcrConversion* pYcbcrConversion,
        uint32_t doLock);
    void vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
        VkSamplerYcbcrConversion ycbcrConversion,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
#endif
#ifdef VK_KHR_bind_memory2
    VkResult vkBindBufferMemory2KHR(
    VkDevice device,
        uint32_t bindInfoCount,
        const VkBindBufferMemoryInfo* pBindInfos,
        uint32_t doLock);
    VkResult vkBindImageMemory2KHR(
    VkDevice device,
        uint32_t bindInfoCount,
        const VkBindImageMemoryInfo* pBindInfos,
        uint32_t doLock);
#endif
#ifdef VK_KHR_maintenance3
    void vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
        const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
        VkDescriptorSetLayoutSupport* pSupport,
        uint32_t doLock);
#endif
#ifdef VK_KHR_draw_indirect_count
    void vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride,
        uint32_t doLock);
    void vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride,
        uint32_t doLock);
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_ANDROID_native_buffer
    VkResult vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
        VkFormat format,
        VkImageUsageFlags imageUsage,
        int* grallocUsage,
        uint32_t doLock);
    VkResult vkAcquireImageANDROID(
    VkDevice device,
        VkImage image,
        int nativeFenceFd,
        VkSemaphore semaphore,
        VkFence fence,
        uint32_t doLock);
    VkResult vkQueueSignalReleaseImageANDROID(
    VkQueue queue,
        uint32_t waitSemaphoreCount,
        const VkSemaphore* pWaitSemaphores,
        VkImage image,
        int* pNativeFenceFd,
        uint32_t doLock);
#endif
#ifdef VK_EXT_debug_report
    VkResult vkCreateDebugReportCallbackEXT(
    VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDebugReportCallbackEXT* pCallback,
        uint32_t doLock);
    void vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
        VkDebugReportCallbackEXT callback,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    void vkDebugReportMessageEXT(
    VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage,
        uint32_t doLock);
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
    VkResult vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
        const VkDebugMarkerObjectTagInfoEXT* pTagInfo,
        uint32_t doLock);
    VkResult vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
        const VkDebugMarkerObjectNameInfoEXT* pNameInfo,
        uint32_t doLock);
    void vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
        const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
        uint32_t doLock);
    void vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer,
        uint32_t doLock);
    void vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
        const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
        uint32_t doLock);
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
    void vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride,
        uint32_t doLock);
    void vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride,
        uint32_t doLock);
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
    VkResult vkGetShaderInfoAMD(
    VkDevice device,
        VkPipeline pipeline,
        VkShaderStageFlagBits shaderStage,
        VkShaderInfoTypeAMD infoType,
        size_t* pInfoSize,
        void* pInfo,
        uint32_t doLock);
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags,
        VkExternalMemoryHandleTypeFlagsNV externalHandleType,
        VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties,
        uint32_t doLock);
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
    VkResult vkGetMemoryWin32HandleNV(
    VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType,
        HANDLE* pHandle,
        uint32_t doLock);
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
    VkResult vkCreateViSurfaceNN(
    VkInstance instance,
        const VkViSurfaceCreateInfoNN* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
    void vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
        const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin,
        uint32_t doLock);
    void vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
        uint32_t doLock);
#endif
#ifdef VK_NVX_device_generated_commands
    void vkCmdProcessCommandsNVX(
    VkCommandBuffer commandBuffer,
        const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo,
        uint32_t doLock);
    void vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer commandBuffer,
        const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo,
        uint32_t doLock);
    VkResult vkCreateIndirectCommandsLayoutNVX(
    VkDevice device,
        const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout,
        uint32_t doLock);
    void vkDestroyIndirectCommandsLayoutNVX(
    VkDevice device,
        VkIndirectCommandsLayoutNVX indirectCommandsLayout,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkCreateObjectTableNVX(
    VkDevice device,
        const VkObjectTableCreateInfoNVX* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkObjectTableNVX* pObjectTable,
        uint32_t doLock);
    void vkDestroyObjectTableNVX(
    VkDevice device,
        VkObjectTableNVX objectTable,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkRegisterObjectsNVX(
    VkDevice device,
        VkObjectTableNVX objectTable,
        uint32_t objectCount,
        const VkObjectTableEntryNVX* const* ppObjectTableEntries,
        const uint32_t* pObjectIndices,
        uint32_t doLock);
    VkResult vkUnregisterObjectsNVX(
    VkDevice device,
        VkObjectTableNVX objectTable,
        uint32_t objectCount,
        const VkObjectEntryTypeNVX* pObjectEntryTypes,
        const uint32_t* pObjectIndices,
        uint32_t doLock);
    void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice physicalDevice,
        VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
        VkDeviceGeneratedCommandsLimitsNVX* pLimits,
        uint32_t doLock);
#endif
#ifdef VK_NV_clip_space_w_scaling
    void vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        uint32_t viewportCount,
        const VkViewportWScalingNV* pViewportWScalings,
        uint32_t doLock);
#endif
#ifdef VK_EXT_direct_mode_display
    VkResult vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        uint32_t doLock);
#endif
#ifdef VK_EXT_acquire_xlib_display
    VkResult vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
        Display* dpy,
        VkDisplayKHR display,
        uint32_t doLock);
    VkResult vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
        Display* dpy,
        RROutput rrOutput,
        VkDisplayKHR* pDisplay,
        uint32_t doLock);
#endif
#ifdef VK_EXT_display_surface_counter
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface,
        VkSurfaceCapabilities2EXT* pSurfaceCapabilities,
        uint32_t doLock);
#endif
#ifdef VK_EXT_display_control
    VkResult vkDisplayPowerControlEXT(
    VkDevice device,
        VkDisplayKHR display,
        const VkDisplayPowerInfoEXT* pDisplayPowerInfo,
        uint32_t doLock);
    VkResult vkRegisterDeviceEventEXT(
    VkDevice device,
        const VkDeviceEventInfoEXT* pDeviceEventInfo,
        const VkAllocationCallbacks* pAllocator,
        VkFence* pFence,
        uint32_t doLock);
    VkResult vkRegisterDisplayEventEXT(
    VkDevice device,
        VkDisplayKHR display,
        const VkDisplayEventInfoEXT* pDisplayEventInfo,
        const VkAllocationCallbacks* pAllocator,
        VkFence* pFence,
        uint32_t doLock);
    VkResult vkGetSwapchainCounterEXT(
    VkDevice device,
        VkSwapchainKHR swapchain,
        VkSurfaceCounterFlagBitsEXT counter,
        uint64_t* pCounterValue,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_display_timing
    VkResult vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
        VkSwapchainKHR swapchain,
        VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties,
        uint32_t doLock);
    VkResult vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
        VkSwapchainKHR swapchain,
        uint32_t* pPresentationTimingCount,
        VkPastPresentationTimingGOOGLE* pPresentationTimings,
        uint32_t doLock);
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
    void vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
        uint32_t firstDiscardRectangle,
        uint32_t discardRectangleCount,
        const VkRect2D* pDiscardRectangles,
        uint32_t doLock);
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
    void vkSetHdrMetadataEXT(
    VkDevice device,
        uint32_t swapchainCount,
        const VkSwapchainKHR* pSwapchains,
        const VkHdrMetadataEXT* pMetadata,
        uint32_t doLock);
#endif
#ifdef VK_MVK_ios_surface
    VkResult vkCreateIOSSurfaceMVK(
    VkInstance instance,
        const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
#endif
#ifdef VK_MVK_macos_surface
    VkResult vkCreateMacOSSurfaceMVK(
    VkInstance instance,
        const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkSurfaceKHR* pSurface,
        uint32_t doLock);
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
    VkResult vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
        const VkDebugUtilsObjectNameInfoEXT* pNameInfo,
        uint32_t doLock);
    VkResult vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
        const VkDebugUtilsObjectTagInfoEXT* pTagInfo,
        uint32_t doLock);
    void vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
        const VkDebugUtilsLabelEXT* pLabelInfo,
        uint32_t doLock);
    void vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue,
        uint32_t doLock);
    void vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
        const VkDebugUtilsLabelEXT* pLabelInfo,
        uint32_t doLock);
    void vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
        const VkDebugUtilsLabelEXT* pLabelInfo,
        uint32_t doLock);
    void vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
        uint32_t doLock);
    void vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
        const VkDebugUtilsLabelEXT* pLabelInfo,
        uint32_t doLock);
    VkResult vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
        const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDebugUtilsMessengerEXT* pMessenger,
        uint32_t doLock);
    void vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
        VkDebugUtilsMessengerEXT messenger,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    void vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
        VkDebugUtilsMessageTypeFlagsEXT messageTypes,
        const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
        uint32_t doLock);
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
        const AHardwareBuffer* buffer,
        VkAndroidHardwareBufferPropertiesANDROID* pProperties,
        uint32_t doLock);
    VkResult vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
        const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
        AHardwareBuffer** pBuffer,
        uint32_t doLock);
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
    void vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
        const VkSampleLocationsInfoEXT* pSampleLocationsInfo,
        uint32_t doLock);
    void vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
        VkSampleCountFlagBits samples,
        VkMultisamplePropertiesEXT* pMultisampleProperties,
        uint32_t doLock);
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
    VkResult vkCreateValidationCacheEXT(
    VkDevice device,
        const VkValidationCacheCreateInfoEXT* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkValidationCacheEXT* pValidationCache,
        uint32_t doLock);
    void vkDestroyValidationCacheEXT(
    VkDevice device,
        VkValidationCacheEXT validationCache,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
    VkResult vkMergeValidationCachesEXT(
    VkDevice device,
        VkValidationCacheEXT dstCache,
        uint32_t srcCacheCount,
        const VkValidationCacheEXT* pSrcCaches,
        uint32_t doLock);
    VkResult vkGetValidationCacheDataEXT(
    VkDevice device,
        VkValidationCacheEXT validationCache,
        size_t* pDataSize,
        void* pData,
        uint32_t doLock);
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
    VkResult vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        const void* pHostPointer,
        VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties,
        uint32_t doLock);
#endif
#ifdef VK_AMD_buffer_marker
    void vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        uint32_t marker,
        uint32_t doLock);
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    void vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
        const void* pCheckpointMarker,
        uint32_t doLock);
    void vkGetQueueCheckpointDataNV(
    VkQueue queue,
        uint32_t* pCheckpointDataCount,
        VkCheckpointDataNV* pCheckpointData,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_address_space
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
        VkDeviceMemory memory,
        uint64_t* pAddress,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_color_buffer
    VkResult vkRegisterImageColorBufferGOOGLE(
    VkDevice device,
        VkImage image,
        uint32_t colorBuffer,
        uint32_t doLock);
    VkResult vkRegisterBufferColorBufferGOOGLE(
    VkDevice device,
        VkBuffer buffer,
        uint32_t colorBuffer,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
    void vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device,
        VkDescriptorSet descriptorSet,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        uint32_t imageInfoCount,
        uint32_t bufferInfoCount,
        uint32_t bufferViewCount,
        const uint32_t* pImageInfoEntryIndices,
        const uint32_t* pBufferInfoEntryIndices,
        const uint32_t* pBufferViewEntryIndices,
        const VkDescriptorImageInfo* pImageInfos,
        const VkDescriptorBufferInfo* pBufferInfos,
        const VkBufferView* pBufferViews,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_async_command_buffers
    void vkBeginCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo* pBeginInfo,
        uint32_t doLock);
    void vkEndCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
        uint32_t doLock);
    void vkResetCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags,
        uint32_t doLock);
    void vkCommandBufferHostSyncGOOGLE(
    VkCommandBuffer commandBuffer,
        uint32_t needHostSync,
        uint32_t sequenceNumber,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
    VkResult vkCreateImageWithRequirementsGOOGLE(
    VkDevice device,
        const VkImageCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkImage* pImage,
        VkMemoryRequirements* pMemoryRequirements,
        uint32_t doLock);
    VkResult vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device,
        const VkBufferCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkBuffer* pBuffer,
        VkMemoryRequirements* pMemoryRequirements,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_address_space_info
    VkResult vkGetMemoryHostAddressInfoGOOGLE(
    VkDevice device,
        VkDeviceMemory memory,
        uint64_t* pAddress,
        uint64_t* pSize,
        uint64_t* pHostmemId,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_free_memory_sync
    VkResult vkFreeMemorySyncGOOGLE(
    VkDevice device,
        VkDeviceMemory memory,
        const VkAllocationCallbacks* pAllocator,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_async_queue_submit
    void vkQueueHostSyncGOOGLE(
    VkQueue queue,
        uint32_t needHostSync,
        uint32_t sequenceNumber,
        uint32_t doLock);
    void vkQueueSubmitAsyncGOOGLE(
    VkQueue queue,
        uint32_t submitCount,
        const VkSubmitInfo* pSubmits,
        VkFence fence,
        uint32_t doLock);
    void vkQueueWaitIdleAsyncGOOGLE(
    VkQueue queue,
        uint32_t doLock);
    void vkQueueBindSparseAsyncGOOGLE(
    VkQueue queue,
        uint32_t bindInfoCount,
        const VkBindSparseInfo* pBindInfo,
        VkFence fence,
        uint32_t doLock);
#endif
#ifdef VK_GOOGLE_linear_image_layout
    void vkGetLinearImageLayoutGOOGLE(
    VkDevice device,
        VkFormat format,
        VkDeviceSize* pOffset,
        VkDeviceSize* pRowPitchAlignment,
        uint32_t doLock);
#endif
#ifdef VK_MVK_moltenvk
    void vkGetMTLDeviceMVK(
    VkPhysicalDevice physicalDevice,
        void** pMTLDevice,
        uint32_t doLock);
    VkResult vkSetMTLTextureMVK(
    VkImage image,
        void* mtlTexture,
        uint32_t doLock);
    void vkGetMTLTextureMVK(
    VkImage image,
        void** pMTLTexture,
        uint32_t doLock);
    void vkGetMTLBufferMVK(
    VkBuffer buffer,
        void** pMTLBuffer,
        uint32_t doLock);
    VkResult vkUseIOSurfaceMVK(
    VkImage image,
        void* ioSurface,
        uint32_t doLock);
    void vkGetIOSurfaceMVK(
    VkImage image,
        void** pIOSurface,
        uint32_t doLock);
#endif

private:
    class Impl;
    std::unique_ptr<Impl> mImpl;
};

} // namespace goldfish_vk
